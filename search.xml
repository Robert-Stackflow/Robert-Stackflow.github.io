<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2022/08/23/tree/"/>
      <url>/2022/08/23/tree/</url>
      
        <content type="html"><![CDATA[<p>树形 DP，即在树上进行的 DP。由于树固有的递归性质，树形 DP 一般都是递归进行的。</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>以下面这道题为例，介绍一下树形 DP 的一般过程。</p><p>???+note “ 例题 <a href="https://www.luogu.com.cn/problem/P1352">洛谷 P1352 没有上司的舞会</a>“<br>    某大学有 $n$ 个职员，编号为 $1 \sim N$。他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数 $a_i$，但是呢，如果某个职员的上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。</p><p>我们设 $f(i,0&#x2F;1)$ 代表以 $i$ 为根的子树的最优解（第二维的值为 0 代表 $i$ 不参加舞会的情况，1 代表 $i$ 参加舞会的情况）。</p><p>对于每个状态，都存在两种决策（其中下面的 $x$ 都是 $i$ 的儿子）：</p><ul><li>上司不参加舞会时，下属可以参加，也可以不参加，此时有 $f(i,0) &#x3D; \sum\max {f(x,1),f(x,0)}$；</li><li>上司参加舞会时，下属都不会参加，此时有 $f(i,1) &#x3D; \sum{f(x,0)} + a_i$。</li></ul><p>我们可以通过 DFS，在返回上一层时更新当前结点的最优解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">-8</span>&lt;-- <span class="string">&quot;docs/dp/code/tree/tree_1.cpp&quot;</span></span><br></pre></td></tr></table></figure><h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><ul><li><p><a href="https://vjudge.net/problem/HDU-2196">HDU 2196 Computer</a></p></li><li><p><a href="http://poj.org/problem?id=1463">POJ 1463 Strategic game</a></p></li><li><p><a href="https://www.luogu.com.cn/problem/P3574">[POI2014]FAR-FarmCraft</a></p></li></ul><h2 id="树上背包"><a href="#树上背包" class="headerlink" title="树上背包"></a>树上背包</h2><p>树上的背包问题，简单来说就是背包问题与树形 DP 的结合。</p><p>???+note “例题 <a href="https://www.luogu.com.cn/problem/P2014">洛谷 P2014 CTSC1997 选课</a>“<br>    现在有 $n$ 门课程，第 $i$ 门课程的学分为 $a_i$，每门课程有零门或一门先修课，有先修课的课程需要先学完其先修课，才能学习该课程。</p><pre><code>一位学生要学习 $m$ 门课程，求其能获得的最多学分数。$n,m \leq 300$</code></pre><p>每门课最多只有一门先修课的特点，与有根树中一个点最多只有一个父亲结点的特点类似。</p><p>因此可以想到根据这一性质建树，从而所有课程组成了一个森林的结构。为了方便起见，我们可以新增一门 $0$ 学分的课程（设这个课程的编号为 $0$），作为所有无先修课课程的先修课，这样我们就将森林变成了一棵以 $0$ 号课程为根的树。</p><p>我们设 $f(u,i,j)$ 表示以 $u$ 号点为根的子树中，已经遍历了 $u$ 号点的前 $i$ 棵子树，选了 $j$ 门课程的最大学分。</p><p>转移的过程结合了树形 DP 和 <a href="./knapsack.md">背包 DP</a> 的特点，我们枚举 $u$ 点的每个子结点 $v$，同时枚举以 $v$ 为根的子树选了几门课程，将子树的结果合并到 $u$ 上。</p><p>记点 $x$ 的儿子个数为 $s_x$，以 $x$ 为根的子树大小为 $\textit{siz_x}$，可以写出下面的状态转移方程：</p><p>$$<br>f(u,i,j)&#x3D;\max_{v,k \leq j,k \leq \textit{siz_v}} f(u,i-1,j-k)+f(v,s_v,k)<br>$$</p><p>注意上面状态转移方程中的几个限制条件，这些限制条件确保了一些无意义的状态不会被访问到。</p><p>$f$ 的第二维可以很轻松地用滚动数组的方式省略掉，注意这时需要倒序枚举 $j$ 的值。</p><p>可以证明，该做法的时间复杂度为 $O(nm)$[^note1]。</p><p>??? note “参考代码”<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">-8</span>&lt;-- <span class="string">&quot;docs/dp/code/tree/tree_2.cpp&quot;</span></span><br></pre></td></tr></table></figure></p><h3 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h3><ul><li><p><a href="https://www.luogu.com.cn/problem/P2014">「CTSC1997」选课</a></p></li><li><p><a href="https://loj.ac/problem/2546">「JSOI2018」潜入行动</a></p></li><li><p><a href="https://loj.ac/problem/2268">「SDOI2017」苹果树</a></p></li></ul><h2 id="换根-DP"><a href="#换根-DP" class="headerlink" title="换根 DP"></a>换根 DP</h2><p>树形 DP 中的换根 DP 问题又被称为二次扫描，通常不会指定根结点，并且根结点的变化会对一些值，例如子结点深度和、点权和等产生影响。</p><p>通常需要两次 DFS，第一次 DFS 预处理诸如深度，点权和之类的信息，在第二次 DFS 开始运行换根动态规划。</p><p>接下来以一些例题来带大家熟悉这个内容。</p><p>???+note “例题 <a href="https://www.luogu.com.cn/problem/P3478">[POI2008]STA-Station</a>“<br>    给定一个 $n$ 个点的树，请求出一个结点，使得以这个结点为根时，所有结点的深度之和最大。</p><p>不妨令 $u$ 为当前结点，$v$ 为当前结点的子结点。首先需要用 $s_i$ 来表示以 $i$ 为根的子树中的结点个数，并且有 $s_u&#x3D;1+\sum s_v$。显然需要一次 DFS 来计算所有的 $s_i$，这次的 DFS 就是预处理，我们得到了以某个结点为根时其子树中的结点总数。</p><p>考虑状态转移，这里就是体现＂换根＂的地方了。令 $f_u$ 为以 $u$ 为根时，所有结点的深度之和。</p><p>$f_v\leftarrow f_u$ 可以体现换根，即以 $u$ 为根转移到以 $v$ 为根。显然在换根的转移过程中，以 $v$ 为根或以 $u$ 为根会导致其子树中的结点的深度产生改变。具体表现为：</p><ul><li><p>所有在 $v$ 的子树上的结点深度都减少了一，那么总深度和就减少了 $s_v$；</p></li><li><p>所有不在 $v$ 的子树上的结点深度都增加了一，那么总深度和就增加了 $n-s_v$；</p></li></ul><p>根据这两个条件就可以推出状态转移方程 $f_v &#x3D; f_u - s_v + n - s_v&#x3D;f_u + n - 2 \times s_v$。</p><p>于是在第二次 DFS 遍历整棵树并状态转移 $f_v&#x3D;f_u + n - 2 \times s_v$，那么就能求出以每个结点为根时的深度和了。最后只需要遍历一次所有根结点深度和就可以求出答案。</p><p>??? note “参考代码”<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">-8</span>&lt;-- <span class="string">&quot;docs/dp/code/tree/tree_3.cpp&quot;</span></span><br></pre></td></tr></table></figure></p><h3 id="习题-2"><a href="#习题-2" class="headerlink" title="习题"></a>习题</h3><ul><li><p><a href="http://poj.org/problem?id=3585">POJ 3585 Accumulation Degree</a></p></li><li><p><a href="https://www.luogu.com.cn/problem/P3478">[POI2008]STA-Station</a></p></li><li><p><a href="https://www.luogu.com.cn/problem/P2986">[USACO10MAR]Great Cow Gathering G</a></p></li><li><p><a href="http://codeforces.com/problemset/problem/708/C">CodeForce 708C Centroids</a></p></li></ul><h2 id="参考资料与注释"><a href="#参考资料与注释" class="headerlink" title="参考资料与注释"></a>参考资料与注释</h2><p>[^note1]: <a href="https://blog.csdn.net/lyd_7_29/article/details/79854245">子树合并背包类型的 dp 的复杂度证明 - LYD729 的 CSDN 博客</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/08/23/state/"/>
      <url>/2022/08/23/state/</url>
      
        <content type="html"><![CDATA[<p>状压 DP 是动态规划的一种，通过将状态压缩为整数来达到优化转移的目的。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>???+note “<a href="https://loj.ac/problem/2153">「SCOI2005」互不侵犯</a>“<br>    在 $N\times N$ 的棋盘里面放 $K$ 个国王（$1 \leq N \leq 9，$ 1\leq K\leq N\times N$），使他们互不攻击，共有多少种摆放方案。</p><pre><code>国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共 $8$ 个格子。</code></pre><p>设 $f(i,j,l)$ 表示前 $i$ 行，第 $i$ 行的状态为 $j$，且棋盘上已经放置 $l$ 个国王时的合法方案数。</p><p>对于编号为 $j$ 的状态，我们用二进制整数 $sit(j)$ 表示国王的放置情况，$sit(j)$ 的某个二进制位为 $0$ 表示对应位置不放国王，为 $1$ 表示在对应位置上放置国王；用 $sta(j)$ 表示该状态的国王个数，即二进制数 $sit(j)$ 中 $1$ 的个数。例如，如下图所示的状态可用二进制数 $100101$ 来表示（棋盘左边对应二进制低位），则有 $sit(j)&#x3D;100101_{(2)}&#x3D;37, sta(j)&#x3D;3$。</p><p><img src="/./images/SCOI2005-%E4%BA%92%E4%B8%8D%E4%BE%B5%E7%8A%AF.png"></p><p>设当前行的状态为 $j$，上一行的状态为 $x$，可以得到下面的状态转移方程：$f(i,j,l) &#x3D; \sum f(i-1,x,l-sta(x))$。</p><p>设上一行的状态编号为 $x$，在保证当前行和上一行不冲突的前提下，枚举所有可能的 $x$ 进行转移，转移方程：</p><p>$$<br>f(i,j,l) &#x3D; \sum f(i-1,x,l-sta(j))<br>$$</p><p>??? “参考代码”<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">-8</span>&lt;-- <span class="string">&quot;docs/dp/code/state/state_1.cpp&quot;</span></span><br></pre></td></tr></table></figure></p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><ul><li><a href="https://loj.ac/problem/10173">「NOI2001」炮兵阵地</a></li><li><a href="https://www.luogu.com.cn/problem/P1879">「USACO06NOV」玉米田 Corn Fields</a></li><li><a href="https://www.luogu.com.cn/problem/P2051">「AHOI2009」中国象棋</a></li><li><a href="https://loj.ac/problem/2471">「九省联考 2018」一双木棋</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/08/23/probability/"/>
      <url>/2022/08/23/probability/</url>
      
        <content type="html"><![CDATA[<p>概率 DP 用于解决概率问题与期望问题，建议先对 <a href="../math/expectation.md">概率 &amp; 期望</a> 的内容有一定了解。一般情况下，解决概率问题需要顺序循环，而解决期望问题使用逆序循环，如果定义的状态转移方程存在后效性问题，还需要用到 <a href="../math/gauss.md">高斯消元</a> 来优化。概率 DP 也会结合其他知识进行考察，例如 <a href="./state.md">状态压缩</a>，树上进行 DP 转移等。</p><h2 id="DP-求概率"><a href="#DP-求概率" class="headerlink" title="DP 求概率"></a>DP 求概率</h2><p>这类题目采用顺推，也就是从初始状态推向结果。同一般的 DP 类似的，难点依然是对状态转移方程的刻画，只是这类题目经过了概率论知识的包装。</p><p>???+note “例题 <a href="https://codeforces.com/problemset/problem/148/D">Codeforces 148 D Bag of mice</a>“<br>    题目大意：袋子里有 $w$ 只白鼠和 $b$ 只黑鼠，公主和龙轮流从袋子里抓老鼠。谁先抓到白色老鼠谁就赢，如果袋子里没有老鼠了并且没有谁抓到白色老鼠，那么算龙赢。公主每次抓一只老鼠，龙每次抓完一只老鼠之后会有一只老鼠跑出来。每次抓的老鼠和跑出来的老鼠都是随机的。公主先抓。问公主赢的概率。</p><p>设 $f_{i,j}$ 为轮到公主时袋子里有 $i$ 只白鼠，$j$ 只黑鼠，公主赢的概率。初始化边界，$f_{0,j}&#x3D;0$ 因为没有白鼠了算龙赢，$f_{i,0}&#x3D;1$ 因为抓一只就是白鼠，公主赢。<br>考虑 $f_{i,j}$ 的转移：</p><ul><li>公主抓到一只白鼠，公主赢了。概率为 $\frac{i}{i+j}$；</li><li>公主抓到一只黑鼠，龙抓到一只白鼠，龙赢了。概率为 $\frac{j}{i+j}\cdot \frac{i}{i+j-1}$；</li><li>公主抓到一只黑鼠，龙抓到一只黑鼠，跑出来一只黑鼠，转移到 $f_{i,j-3}$。概率为 $\frac{j}{i+j}\cdot\frac{j-1}{i+j-1}\cdot\frac{j-2}{i+j-2}$；</li><li>公主抓到一只黑鼠，龙抓到一只黑鼠，跑出来一只白鼠，转移到 $f_{i-1,j-2}$。概率为 $\frac{j}{i+j}\cdot\frac{j-1}{i+j-1}\cdot\frac{i}{i+j-2}$；</li></ul><p>考虑公主赢的概率，第二种情况不参与计算。并且要保证后两种情况合法，所以还要判断 $i,j$ 的大小，满足第三种情况至少要有 3 只黑鼠，满足第四种情况要有 1 只白鼠和 2 只黑鼠。</p><p>??? note “参考实现”<br>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">-8</span>&lt;-- <span class="string">&quot;docs/dp/code/probability/probability_1.cpp&quot;</span></span><br></pre></td></tr></table></figure></p><h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><ul><li><a href="https://codeforces.com/problemset/problem/148/D">CodeForces 148 D Bag of mice</a></li><li><a href="http://poj.org/problem?id=3071">POJ3071 Football</a></li><li><a href="https://codeforces.com/problemset/problem/768/D">CodeForces 768 D Jon and Orbs</a></li></ul><h2 id="DP-求期望"><a href="#DP-求期望" class="headerlink" title="DP 求期望"></a>DP 求期望</h2><p>???+note “ 例题 <a href="http://poj.org/problem?id=2096">POJ2096 Collecting Bugs</a>“<br>    题目大意：一个软件有 $s$ 个子系统，会产生 $n$ 种 bug。某人一天发现一个 bug，这个 bug 属于某种 bug 分类，也属于某个子系统。每个 bug 属于某个子系统的概率是 $\frac{1}{s}$，属于某种 bug 分类的概率是 $\frac{1}{n}$。求发现 $n$ 种 bug，且 $s$ 个子系统都找到 bug 的期望天数。</p><p>令 $f_{i,j}$ 为已经找到 $i$ 种 bug 分类，$j$ 个子系统的 bug，达到目标状态的期望天数。这里的目标状态是找到 $n$ 种 bug 分类，$s$ 个子系统的 bug。那么就有 $f_{n,s}&#x3D;0$，因为已经达到了目标状态，不需要用更多的天数去发现 bug 了，于是就以目标状态为起点开始递推，答案是 $f_{0,0}$。</p><p>考虑 $f_{i,j}$ 的状态转移：</p><ul><li>$f_{i,j}$，发现一个 bug 属于已经发现的 $i$ 种 bug 分类，$j$ 个子系统，概率为 $p_1&#x3D;\frac{i}{n}\cdot\frac{j}{s}$</li><li>$f_{i,j+1}$，发现一个 bug 属于已经发现的 $i$ 种 bug 分类，不属于已经发现的子系统，概率为 $p_2&#x3D;\frac{i}{n}\cdot(1-\frac{j}{s})$</li><li>$f_{i+1,j}$，发现一个 bug 不属于已经发现 bug 分类，属于 $j$ 个子系统，概率为 $p_3&#x3D;(1-\frac{i}{n})\cdot\frac{j}{s}$</li><li>$f_{i+1,j+1}$，发现一个 bug 不属于已经发现 bug 分类，不属于已经发现的子系统，概率为 $p_4&#x3D;(1-\frac{i}{n})\cdot(1-\frac{j}{s})$</li></ul><p>再根据期望的线性性质，就可以得到状态转移方程：</p><p>$$<br>\begin{aligned}<br>f_{i,j} &amp;&#x3D; p_1\cdot f_{i,j}+p_2\cdot f_{i,j+1}+p_3\cdot f_{i+1,j}+p_4\cdot f_{i+1,j+1} + 1\<br>&amp;&#x3D; \frac{p_2\cdot f_{i,j+1}+p_3\cdot f_{i+1,j}+p_4\cdot f_{i+1,j+1}+1}{1-p_1}<br>\end{aligned}<br>$$</p><p>??? note “参考实现”<br>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">-8</span>&lt;-- <span class="string">&quot;docs/dp/code/probability/probability_2.cpp&quot;</span></span><br></pre></td></tr></table></figure></p><p>???+note “例题 <a href="http://uoj.ac/problem/262">「NOIP2016」换教室</a>“<br>    题目大意：牛牛要上 $n$ 个时间段的课，第 $i$ 个时间段在 $c_i$ 号教室，可以申请换到 $d_i$ 号教室，申请成功的概率为 $p_i$，至多可以申请 $m$ 节课进行交换。第 $i$ 个时间段的课上完后要走到第 $i+1$ 个时间段的教室，给出一张图 $v$ 个教室 $e$ 条路，移动会消耗体力，申请哪几门课程可以使他因在教室间移动耗费的体力值的总和的期望值最小，也就是求出最小的期望路程和。</p><p>对于这个无向连通图，先用 Floyd 求出最短路，为后续的状态转移带来便利。以移动一步为一个阶段（从第 $i$ 个时间段到达第 $i+1$ 个时间段就是移动了一步），那么每一步就有 $p_i$ 的概率到 $d_i$，不过在所有的 $d_i$ 中只能选 $m$ 个，有 $1-p_i$ 的概率到 $c_i$，求出在 $n$ 个阶段走完后的最小期望路程和。<br>定义 $f_{i,j,0&#x2F;1}$ 为在第 $i$ 个时间段，连同这一个时间段已经用了 $j$ 次换教室的机会，在这个时间段换（1）或者不换（0）教室的最小期望路程和，那么答案就是 $max {f_{n,i,0},f_{n,i,1}} ,i\in[0,m]$。注意边界 $f_{1,0,0}&#x3D;f_{1,1,1}&#x3D;0$。</p><p>考虑 $f_{i,j,0&#x2F;1}$ 的状态转移：</p><ul><li>如果这一阶段不换，即 $f_{i,j,0}$。可能是由上一次不换的状态转移来的，那么就是 $f_{i-1,j,0}+w_{c_{i-1},c_{i}}$, 也有可能是由上一次交换的状态转移来的，这里结合条件概率和全概率的知识分析可以得到 $f_{i-1,j,1}+w_{d_{i-1},c_{i}}\cdot p_{i-1}+w_{c_{i-1},c_{i}}\cdot (1-p_{i-1})$，状态转移方程就有</li></ul><p>$$<br>\begin{aligned}<br>f_{i,j,0}&#x3D;min(f_{i-1,j,0}+w_{c_{i-1},c_{i}},f_{i-1,j,1}+w_{d_{i-1},c_{i}}\cdot p_{i-1}+w_{c_{i-1},c_{i}}\cdot (1-p_{i-1}))<br>\end{aligned}<br>$$</p><ul><li>如果这一阶段交换，即 $f_{i,j,1}$。类似地，可能由上一次不换的状态转移来，也可能由上一次交换的状态转移来。那么遇到不换的就乘上 $(1-p_i)$，遇到交换的就乘上 $p_i$，将所有会出现的情况都枚举一遍出进行计算就好了。这里不再赘述各种转移情况，相信通过上一种阶段例子，这里的状态转移应该能够很容易写出来。</li></ul><p>??? note “参考实现”<br>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">-8</span>&lt;-- <span class="string">&quot;docs/dp/code/probability/probability_3.cpp&quot;</span></span><br></pre></td></tr></table></figure></p><p>比较这两个问题可以发现，DP 求期望题目在对具体是求一个值或是最优化问题上会对方程得到转移方式有一些影响，但无论是 DP 求概率还是 DP 求期望，总是离不开概率知识和列出、化简计算公式的步骤，在写状态转移方程时需要思考的细节也类似。</p><h3 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h3><ul><li><a href="http://poj.org/problem?id=2096">POJ2096 Collecting Bugs</a></li><li><a href="https://vjudge.net/problem/HDU-3853">HDU3853 LOOPS</a></li><li><a href="https://vjudge.net/problem/HDU-4035">HDU4035 Maze</a></li><li><a href="http://uoj.ac/problem/262">「NOIP2016」换教室</a></li><li><a href="https://www.luogu.com.cn/problem/P2473">「SCOI2008」奖励关</a></li></ul><h2 id="有后效性-DP"><a href="#有后效性-DP" class="headerlink" title="有后效性 DP"></a>有后效性 DP</h2><p>???+note “<a href="https://codeforces.com/problemset/problem/24/D">CodeForces 24 D Broken robot</a>“<br>    题目大意：给出一个 $n \times m$ 的矩阵区域，一个机器人初始在第 $x$ 行第 $y$ 列，每一步机器人会等概率地选择停在原地，左移一步，右移一步，下移一步，如果机器人在边界则不会往区域外移动，问机器人到达最后一行的期望步数。</p><p>在 $m&#x3D;1$ 时每次有 $\frac{1}{2}$ 的概率不动，有 $\frac{1}{2}$ 的概率向下移动一格，答案为 $2\cdot (n-x)$。<br>设 $f_{i,j}$ 为机器人机器人从第 i 行第 j 列出发到达第 $n$ 行的期望步数，最终状态为 $f_{n,j}&#x3D;0$。<br>由于机器人会等概率地选择停在原地，左移一步，右移一步，下移一步，考虑 $f_{i,j}$ 的状态转移：</p><ul><li>$f_{i,1}&#x3D;\frac{1}{3}\cdot(f_{i+1,1}+f_{i,2}+f_{i,1})+1$</li><li>$f_{i,j}&#x3D;\frac{1}{4}\cdot(f_{i,j}+f_{i,j-1}+f_{i,j+1}+f_{i+1,j})+1$</li><li>$f_{i,m}&#x3D;\frac{1}{3}\cdot(f_{i,m}+f_{i,m-1}+f_{i+1,m})+1$</li></ul><p>在行之间由于只能向下移动，是满足无后效性的。在列之间可以左右移动，在移动过程中可能产生环，不满足无后效性。<br>将方程变换后可以得到：</p><ul><li>$2f_{i,1}-f_{i,2}&#x3D;3+f_{i+1,1}$</li><li>$3f_{i,j}-f_{i,j-1}-f_{i,j+1}&#x3D;4+f_{i+1,j}$</li><li>$2f_{i,m}-f_{i,m-1}&#x3D;3+f_{i+1,m}$</li></ul><p>由于是逆序的递推，所以每一个 $f_{i+1,j}$ 是已知的。<br>由于有 $m$ 列，所以右边相当于是一个 $m$ 行的列向量，那么左边就是 $m$ 行 $m$ 列的矩阵。使用增广矩阵，就变成了 m 行 m+1 列的矩阵，然后进行 <a href="../math/gauss.md">高斯消元</a> 即可解出答案。</p><p>??? note “参考实现”<br>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> a[maxn][maxn], f[maxn];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">      a[i][i] = <span class="number">2</span>;</span><br><span class="line">      a[i][i + <span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">      a[i][m + <span class="number">1</span>] = <span class="number">3</span> + f[i];</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == m) &#123;</span><br><span class="line">      a[i][i] = <span class="number">2</span>;</span><br><span class="line">      a[i][i - <span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">      a[i][m + <span class="number">1</span>] = <span class="number">3</span> + f[i];</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    a[i][i] = <span class="number">3</span>;</span><br><span class="line">    a[i][i + <span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">    a[i][i - <span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">    a[i][m + <span class="number">1</span>] = <span class="number">4</span> + f[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="type">double</span> p = a[i + <span class="number">1</span>][i] / a[i][i];</span><br><span class="line">    a[i + <span class="number">1</span>][i] = <span class="number">0</span>;</span><br><span class="line">    a[i + <span class="number">1</span>][i + <span class="number">1</span>] -= a[i][i + <span class="number">1</span>] * p;</span><br><span class="line">    a[i + <span class="number">1</span>][m + <span class="number">1</span>] -= a[i][m + <span class="number">1</span>] * p;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f[m] = a[m][m + <span class="number">1</span>] / a[m][m];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    f[i] = (a[i][m + <span class="number">1</span>] - f[i + <span class="number">1</span>] * a[i][i + <span class="number">1</span>]) / a[i][i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="type">int</span> st, ed;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;st, &amp;ed);</span><br><span class="line">  <span class="keyword">if</span> (m == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.10f\n&quot;</span>, <span class="number">2.0</span> * (n - st));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= st; i--) &#123;</span><br><span class="line">    <span class="built_in">solve</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%.10f\n&quot;</span>, f[ed]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="习题-2"><a href="#习题-2" class="headerlink" title="习题"></a>习题</h3><ul><li><a href="https://codeforces.com/problemset/problem/24/D">CodeForce 24 D Broken robot</a></li><li><a href="https://vjudge.net/problem/HDU-4418">HDU Time Travel</a></li><li><a href="https://loj.ac/problem/2383">「HNOI2013」游走</a></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.cnblogs.com/kuangbin/archive/2012/10/02/2710606.html">kuangbin 概率 DP 总结</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/08/23/plug/"/>
      <url>/2022/08/23/plug/</url>
      
        <content type="html"><![CDATA[<p>有些 <a href="./state.md">状压 DP</a> 问题要求我们记录状态的连通性信息，这类问题一般被形象的称为插头 DP 或连通性状态压缩 DP。例如格点图的哈密顿路径计数，求棋盘的黑白染色方案满足相同颜色之间形成一个连通块的方案数，以及特定图的生成树计数等等。这些问题通常需要我们对状态的连通性进行编码，讨论状态转移过程中连通性的变化。</p><h2 id="骨牌覆盖与轮廓线-DP"><a href="#骨牌覆盖与轮廓线-DP" class="headerlink" title="骨牌覆盖与轮廓线 DP"></a>骨牌覆盖与轮廓线 DP</h2><p>温故而知新，在开始学习插头 DP 之前，不妨先让我们回顾一个经典问题。</p><p>???+note “ 例题 <a href="https://vjudge.net/problem/HDU-1400">「HDU 1400」Mondriaan’s Dream</a>“<br>    题目大意：在 $N\times M$ 的棋盘内铺满 $1\times 2$ 或 $2\times 1$ 的多米诺骨牌，求方案数。</p><p>当 $n$ 或 $m$ 规模不大的时候，这类问题可以使用 <a href="./state.md">状压 DP</a> 解决。逐行划分阶段，设 $dp(i,s)$ 表示当前已考虑过前 $i$ 行，且第 $i$ 行的状态为 $s$ 的方案数。这里的状态 $s$ 的每一位可以表示这个这个位置是否已被上一行覆盖。</p><p><img src="/./images/domino.svg" alt="domino"></p><p>另一种划分阶段的方法是逐格 DP，或者称之为轮廓线 DP。$dp(i,j,s)$ 表示已经考虑到第 $i$ 行第 $j$ 列，且当前轮廓线上的状态为 $s$ 的方案数。</p><p>虽然逐格 DP 中我们的状态增加了一个维度，但是转移的时间复杂度减少为 $O(1)$，所以时间复杂度未变。我们用 $f_0$ 表示当前阶段的状态，用 $f_1$ 表示下一阶段的状态，$u &#x3D; f_0(s)$ 表示当前枚举的函数值，那么有如下的状态转移方程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s &gt;&gt; j &amp; <span class="number">1</span>) &#123;       <span class="comment">// 如果已被覆盖</span></span><br><span class="line">  f1[s ^ <span class="number">1</span> &lt;&lt; j] += u;  <span class="comment">// 不放</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;                <span class="comment">// 如果未被覆盖</span></span><br><span class="line">  <span class="keyword">if</span> (j != m - <span class="number">1</span> &amp;&amp; (!(s &gt;&gt; j + <span class="number">1</span> &amp; <span class="number">1</span>))) f1[s ^ <span class="number">1</span> &lt;&lt; j + <span class="number">1</span>] += u;  <span class="comment">// 横放</span></span><br><span class="line">  f1[s ^ <span class="number">1</span> &lt;&lt; j] += u;                                             <span class="comment">// 竖放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察到这里不放和竖放的方程可以合并。</p><p>??? 例题代码<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">11</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[<span class="number">2</span>][<span class="number">1</span> &lt;&lt; N], *f0, *f1;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m &amp;&amp; n) &#123;</span><br><span class="line">    f0 = f[<span class="number">0</span>];</span><br><span class="line">    f1 = f[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">fill</span>(f1, f1 + (<span class="number">1</span> &lt;&lt; m), <span class="number">0</span>);</span><br><span class="line">    f1[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(f0, f1);</span><br><span class="line">        <span class="built_in">fill</span>(f1, f1 + (<span class="number">1</span> &lt;&lt; m), <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> u f0[s]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; <span class="number">1</span> &lt;&lt; m; ++s)</span><br><span class="line">          <span class="keyword">if</span> (u) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j != m - <span class="number">1</span> &amp;&amp; (!(s &gt;&gt; j &amp; <span class="number">3</span>))) f1[s ^ <span class="number">1</span> &lt;&lt; j + <span class="number">1</span>] += u;  <span class="comment">// 横放</span></span><br><span class="line">            f1[s ^ <span class="number">1</span> &lt;&lt; j] += u;  <span class="comment">// 竖放或不放</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f1[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>??? note “ 习题 <a href="https://competitiveprogramming.info/topcoder/srm/round/16551/div/1">「SRM 671. Div 1 900」BearDestroys</a>“<br>    题目大意：给定 $n\times m$ 的矩阵，每个格子有 <code>E</code> 或 <code>S</code>。<br>    对于一个矩阵，有一个计分方案。按照行优先的规则扫描每个格子，如果这个格子之前被骨牌占据，则 skip。<br>    否则尝试放多米诺骨牌。如果放骨牌的方向在矩阵外或被其他骨牌占据，则放置失败，切换另一种方案或 skip。<br>    如果是 <code>E</code> 则优先放一个 $1\times 2$ 的骨牌，<br>    如果是 <code>S</code> 则优先放一个 $2\times 1$ 的骨牌。<br>    一个矩阵的得分为最后放的骨牌数。<br>    问所有 $2^{nm}$ 种矩阵的得分的和。</p><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>阶段：动态规划执行的顺序，后续阶段的结果只与前序阶段的结果有关（无后效性）。很多 DP 问题可以有多种划分阶段的方式。例如在背包问题中，我们通常既可以按照物品划分阶段，也可以按照背包容量划分阶段（外层循环先枚举什么）。而在多米诺骨牌问题中，我们可以按照行、列、格子以及对角线等特征划分阶段。</p><p>轮廓线：已决策状态和未决策状态的分界线。</p><p><img src="/./images/contour_line.svg" alt="contour line"></p><p>插头：一个格子某个方向的插头存在，表示这个格子在这个方向与相邻格子相连。</p><p><img src="/./images/plug.svg" alt="plug"></p><h2 id="路径模型"><a href="#路径模型" class="headerlink" title="路径模型"></a>路径模型</h2><h3 id="多条回路"><a href="#多条回路" class="headerlink" title="多条回路"></a>多条回路</h3><p>???+note “ 例题 <a href="https://vjudge.net/problem/HDU-1693">「HDU 1693」Eat the Trees</a>“<br>    题目大意：求用若干条回路覆盖 $N\times M$ 棋盘的方案数，有些位置有障碍。</p><p>严格来说，多条回路问题并不属于插头 DP，因为我们只需要和上面的骨牌覆盖问题一样，记录插头是否存在，然后成对的合并和生成插头就可以了。</p><p>注意对于一个宽度为 $m$ 的棋盘，轮廓线的宽度为 $m+1$，因为包含 $m$ 个上插头，和 $1$ 个左插头。注意，当一行迭代完成之后，最右边的左插头通常是不合法的状态，同时我们需要补上下一行第一个左插头，这需要我们调整当前轮廓线的状态，通常是所有状态进行左移，我们把这个操作称为滚动 <code>roll()</code>。</p><p>??? 例题代码<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">-8</span>&lt;-- <span class="string">&quot;docs/dp/code/plug/plug_1.cpp&quot;</span></span><br></pre></td></tr></table></figure></p><p>??? note “ 习题 <a href="https://vjudge.net/problem/ZOJ-3466">「ZJU 4231」The Hive II</a>“<br>    题目大意：同上题，但格子变成了六边形。</p><h3 id="一条回路"><a href="#一条回路" class="headerlink" title="一条回路"></a>一条回路</h3><h4 id="例题「Andrew-Stankevich-Contest-16-Problem-F」Pipe-Layout"><a href="#例题「Andrew-Stankevich-Contest-16-Problem-F」Pipe-Layout" class="headerlink" title="例题「Andrew Stankevich Contest 16 - Problem F」Pipe Layout"></a>例题「Andrew Stankevich Contest 16 - Problem F」Pipe Layout</h4><p>???+note “ 例题 <a href="https://codeforces.com/gym/100220">「Andrew Stankevich Contest 16 - Problem F」Pipe Layout</a>“<br>    题目大意：求用一条回路覆盖 $N\times M$ 棋盘的方案数。</p><p>在上面的状态表示中我们每合并一组连通的插头，就会生成一条独立的回路，因而在本题中，我们还需要区分插头之间的连通性（出现了！）。这需要我们对状态进行额外的编码。</p><h4 id="状态编码"><a href="#状态编码" class="headerlink" title="状态编码"></a>状态编码</h4><p>通常的编码方案有括号表示和最小表示，这里着重介绍泛用性更好的最小表示。我们用长度 $m+1$ 的整形数组，记录轮廓线上每个插头的状态，$0$ 表示没有插头，并约定连通的插头用相同的数字进行标记。</p><p>那么下面两组编码方式表示的是相同的状态：</p><ul><li><code>0 3 1 0 1 3</code></li><li><code>0 1 2 0 2 1</code></li></ul><p>我们将相同的状态都映射成字典序最小表示，例如在上例中的 <code>0 1 2 0 2 1</code> 就是一组最小表示。</p><p>我们用 <code>b[]</code> 数组表示轮廓线上插头的状态。<code>bb[]</code> 表示在最小表示的编码的过程中，每个数字被映射到的最小数字。注意 $0$ 表示插头不存在，不能被映射成其他值。</p><p>??? note “代码实现”<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b[M + <span class="number">1</span>], bb[M + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">encode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(bb, <span class="number">-1</span>, <span class="built_in">sizeof</span>(bb));</span><br><span class="line">  <span class="type">int</span> bn = <span class="number">1</span>;</span><br><span class="line">  bb[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = m; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bi bb[b[i]]</span></span><br><span class="line">    <span class="keyword">if</span> (!~bi) bi = bn++;</span><br><span class="line">    s &lt;&lt;= offset;</span><br><span class="line">    s |= bi;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decode</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">REP</span>(i, m + <span class="number">1</span>) &#123;</span><br><span class="line">    b[i] = s &amp; mask;</span><br><span class="line">    s &gt;&gt;= offset;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们注意到插头总是成对出现，成对消失的。因而 <code>0 1 2 0 1 2</code> 这样的状态是不合法的。合法的状态构成一组括号序列，实际中合法状态可能是非常稀疏的。</p><h4 id="手写哈希"><a href="#手写哈希" class="headerlink" title="手写哈希"></a>手写哈希</h4><p>在一些 <a href="./state.md">状压 DP</a> 的问题中，合法的状态可能是稀疏的（例如本题），为了优化时空复杂度，我们可以使用哈希表存储合法的 DP 状态。对于 C++ 选手，我们可以使用 <a href="http://www.cplusplus.com/reference/unordered_map/unordered_map/">std::unordered_map</a>，当然也可以直接手写，这样可以灵活的将状态转移函数也封装于其中。</p><p>???+note “代码实现”<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MaxSZ = <span class="number">16796</span>, Prime = <span class="number">9973</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hashTable</span> &#123;</span><br><span class="line">  <span class="type">int</span> head[Prime], next[MaxSZ], sz;</span><br><span class="line">  <span class="type">int</span> state[MaxSZ];</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> key[MaxSZ];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sz = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = s % Prime;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; ~i; i = next[i]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (state[i] == s) &#123;</span><br><span class="line">        key[i] += d;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    state[sz] = s, key[sz] = d;</span><br><span class="line">    next[sz] = head[x];</span><br><span class="line">    head[x] = sz++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">roll</span><span class="params">()</span> </span>&#123; <span class="built_in">REP</span>(i, sz) state[i] &lt;&lt;= offset; &#125;</span><br><span class="line">&#125; H[<span class="number">2</span>], *H0, *H1;</span><br></pre></td></tr></table></figure></p><p>上面的代码中：</p><ul><li><code>MaxSZ</code> 表示合法状态的上界，可以估计，也可以预处理出较为精确的值。</li><li><code>Prime</code> 一个小于 <code>MaxSZ</code> 的大素数。</li><li><code>head[]</code> 表头节点的指针。</li><li><code>next[]</code> 后续状态的指针。</li><li><code>state[]</code> 节点的状态。</li><li><code>key[]</code> 节点的关键字，在本题中是方案数。</li><li><code>clear()</code> 初始化函数，和手写邻接表类似，我们只需要初始化表头节点的指针。</li><li><code>push()</code> 状态转移函数，其中 <code>d</code> 是一个全局变量（偷懒），表示每次状态转移所带来的增量。如果找到的话就 <code>+=</code>，否则就创建一个状态为 <code>s</code>，关键字为 <code>d</code> 的新节点。</li><li><code>roll()</code> 迭代完一整行之后，滚动轮廓线。</li></ul><p>关于哈希表的复杂度分析，以及开哈希和闭哈希的不同，可以参见 <a href="https://oi-wiki.org/intro/resources/#_5">《算法导论》</a> 中关于散列表的相关章节。</p><h4 id="状态转移讨论"><a href="#状态转移讨论" class="headerlink" title="状态转移讨论"></a>状态转移讨论</h4><p>???+note “代码实现”<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">REP</span>(ii, H0-&gt;sz) &#123;</span><br><span class="line">  <span class="built_in">decode</span>(H0-&gt;state[ii]);                  <span class="comment">// 取出状态，并解码</span></span><br><span class="line">  d = H0-&gt;key[ii];                        <span class="comment">// 得到增量 delta</span></span><br><span class="line">  <span class="type">int</span> lt = b[j], up = b[j + <span class="number">1</span>];           <span class="comment">// 左插头，上插头</span></span><br><span class="line">  <span class="type">bool</span> dn = i != n - <span class="number">1</span>, rt = j != m - <span class="number">1</span>;  <span class="comment">// 下插头，右插头</span></span><br><span class="line">  <span class="keyword">if</span> (lt &amp;&amp; up) &#123;                         <span class="comment">// 如果左、上均有插头</span></span><br><span class="line">    <span class="keyword">if</span> (lt == up) &#123;                       <span class="comment">// 来自同一个连通块</span></span><br><span class="line">      <span class="keyword">if</span> (i == n - <span class="number">1</span> &amp;&amp;</span><br><span class="line">          j == m - <span class="number">1</span>) &#123;  <span class="comment">// 只有在最后一个格子时，才能合并，封闭回路。</span></span><br><span class="line">        <span class="built_in">push</span>(j, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 否则，必须合并这两个连通块，因为本题中需要回路覆盖</span></span><br><span class="line">      <span class="built_in">REP</span>(i, m + <span class="number">1</span>) <span class="keyword">if</span> (b[i] == lt) b[i] = up;</span><br><span class="line">      <span class="built_in">push</span>(j, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lt || up) &#123;  <span class="comment">// 如果左、上之中有一个插头</span></span><br><span class="line">    <span class="type">int</span> t = lt | up;      <span class="comment">// 得到这个插头</span></span><br><span class="line">    <span class="keyword">if</span> (dn) &#123;             <span class="comment">// 如果可以向下延伸</span></span><br><span class="line">      <span class="built_in">push</span>(j, t, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rt) &#123;  <span class="comment">// 如果可以向右延伸</span></span><br><span class="line">      <span class="built_in">push</span>(j, <span class="number">0</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;           <span class="comment">// 如果左、上均没有插头</span></span><br><span class="line">    <span class="keyword">if</span> (dn &amp;&amp; rt) &#123;  <span class="comment">// 生成一对新插头</span></span><br><span class="line">      <span class="built_in">push</span>(j, m, m);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>??? 例题代码<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">-8</span>&lt;-- <span class="string">&quot;docs/dp/code/plug/plug_2.cpp&quot;</span></span><br></pre></td></tr></table></figure></p><h4 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h4><p>??? note “ 习题 <a href="https://acm.timus.ru/problem.aspx?space=1&num=1519">「Ural 1519」Formula 1</a>“<br>    题目大意：有障碍。</p><p>??? note “ 习题 <a href="http://oj.jzxx.net/problem.php?id=1695">「USACO 5.4.4」Betsy’s Tours</a>“<br>    题目大意：一个 $N\times N$ 的方阵（$N\le 7$），求从左上角出发到左下角结束经过每个格子的路径总数。虽然是一条路径，但因为起点和终点固定，可以转化为一条回路问题。</p><p>??? note “ 习题 <a href="http://poj.org/problem?id=1739">「POJ 1739」Tony’s Tour</a>“<br>    题目大意：著名的男人八题系列之一。解法同上。</p><p>??? note “ 习题 <a href="https://vjudge.net/problem/UVALive-2738">「USACO 6.1.1」Postal Vans</a>“<br>    题目大意：$n\le 1000,m&#x3D;4$，每个回路需要统计两次（逆时针和顺时针），需要高精度。</p><p>??? note “ 习题 <a href="https://projecteuler.net/problem=393">「ProjectEuler 393」Migrating ants</a>“<br>    题目大意：对于每一个有 $m$ 条回路的方案，对答案的贡献是 $2^m$，求所有方案的贡献和。</p><h3 id="一条路径"><a href="#一条路径" class="headerlink" title="一条路径"></a>一条路径</h3><h4 id="例题「ZOJ-3213」Beautiful-Meadow"><a href="#例题「ZOJ-3213」Beautiful-Meadow" class="headerlink" title="例题「ZOJ 3213」Beautiful Meadow"></a>例题「ZOJ 3213」Beautiful Meadow</h4><p>???+note “ 例题 <a href="https://vjudge.net/problem/ZOJ-3213">「ZOJ 3213」Beautiful Meadow</a>“<br>    题目大意：一个 $N\times M$ 的方阵（$N,M\le 8$），每个格点有一个权值，求一段路径，最大化路径覆盖的格点的权值和。</p><p>本题是标准的一条路径问题，在一条路径问题中，编码的状态中还会存在不能配对的独立插头。需要在状态转移函数中，额外讨论独立插头的生成、合并与消失的情况。独立插头的生成和消失对应着路径的一端，因而这类事件不会发生超过两次（一次生成一次消失，或者两次生成一次合并），否则最终结果一定会出现多个连通块。</p><p>我们需要在状态中额外记录这类事件发生的总次数，可以将这个信息编码进状态里（注意，类似这样的额外信息在调整轮廓线的时候，不需要跟着滚动），当然也可以在 <code>hashTable</code> 数组的外面加维。下面的范例程序中我们选择后者。</p><h4 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h4><p>???+note “代码实现”<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">REP</span>(i, n) &#123;</span><br><span class="line">  <span class="built_in">REP</span>(j, m) &#123;</span><br><span class="line">    <span class="built_in">checkMax</span>(ans, A[i][j]);  <span class="comment">// 需要单独处理一个格子的情况</span></span><br><span class="line">    <span class="keyword">if</span> (!A[i][j]) <span class="keyword">continue</span>;  <span class="comment">// 如果有障碍，则跳过，注意这时状态数组不需要滚动</span></span><br><span class="line">    <span class="built_in">swap</span>(H0, H1);</span><br><span class="line">    <span class="built_in">REP</span>(c, <span class="number">3</span>)</span><br><span class="line">    H1[c].<span class="built_in">clear</span>();  <span class="comment">// c 表示生成和消失事件发生的总次数，最多不超过 2 次</span></span><br><span class="line">    <span class="built_in">REP</span>(c, <span class="number">3</span>) <span class="built_in">REP</span>(ii, H0[c].sz) &#123;</span><br><span class="line">      <span class="built_in">decode</span>(H0[c].state[ii]);</span><br><span class="line">      d = H0[c].key[ii] + A[i][j];</span><br><span class="line">      <span class="type">int</span> lt = b[j], up = b[j + <span class="number">1</span>];</span><br><span class="line">      <span class="type">bool</span> dn = A[i + <span class="number">1</span>][j], rt = A[i][j + <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> (lt &amp;&amp; up) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lt == up) &#123;  <span class="comment">// 在一条路径问题中，我们不能合并相同的插头。</span></span><br><span class="line">          <span class="comment">// Cannot deploy here...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 有可能参与合并的两者中有独立插头，但是也可以用同样的代码片段处理</span></span><br><span class="line">          <span class="built_in">REP</span>(i, m + <span class="number">1</span>) <span class="keyword">if</span> (b[i] == lt) b[i] = up;</span><br><span class="line">          <span class="built_in">push</span>(c, j, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lt || up) &#123;</span><br><span class="line">        <span class="type">int</span> t = lt | up;</span><br><span class="line">        <span class="keyword">if</span> (dn) &#123;</span><br><span class="line">          <span class="built_in">push</span>(c, j, t, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rt) &#123;</span><br><span class="line">          <span class="built_in">push</span>(c, j, <span class="number">0</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一个插头消失的情况，如果是独立插头则意味着消失，如果是成对出现的插头则相当于生成了一个独立插头，</span></span><br><span class="line">        <span class="comment">// 无论哪一类事件都需要将 c + 1。</span></span><br><span class="line">        <span class="keyword">if</span> (c &lt; <span class="number">2</span>) &#123;</span><br><span class="line">          <span class="built_in">push</span>(c + <span class="number">1</span>, j, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        d -= A[i][j];</span><br><span class="line">        H1[c].<span class="built_in">push</span>(H0[c].state[ii]);</span><br><span class="line">        d += A[i][j];    <span class="comment">// 跳过插头生成，本题中不要求全部覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (dn &amp;&amp; rt) &#123;  <span class="comment">// 生成一对插头</span></span><br><span class="line">          <span class="built_in">push</span>(c, j, m, m);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c &lt; <span class="number">2</span>) &#123;  <span class="comment">// 生成一个独立插头</span></span><br><span class="line">          <span class="keyword">if</span> (dn) &#123;</span><br><span class="line">            <span class="built_in">push</span>(c + <span class="number">1</span>, j, m, <span class="number">0</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (rt) &#123;</span><br><span class="line">            <span class="built_in">push</span>(c + <span class="number">1</span>, j, <span class="number">0</span>, m);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">REP</span>(c, <span class="number">3</span>) H1[c].<span class="built_in">roll</span>();  <span class="comment">// 一行结束，调整轮廓线</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>??? 例题代码<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">-8</span>&lt;-- <span class="string">&quot;docs/dp/code/plug/plug_3.cpp&quot;</span></span><br></pre></td></tr></table></figure></p><h4 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h4><p>??? note “ 习题 <a href="https://www.luogu.com.cn/problem/P1933">「NOI 2010 Day2」旅行路线</a>“<br>    题目大意：$n\times m$ 的棋盘，棋盘的每个格子有一个 01 权值 T[x][y]，要求寻找一个路径覆盖，满足：</p><pre><code>- 第 i 个参观的格点 (x, y)，满足 T[x][y]= L[i]- 路径的一端在棋盘的边界上求可行的方案数 $\bmod 11192869$。</code></pre><h2 id="染色模型"><a href="#染色模型" class="headerlink" title="染色模型"></a>染色模型</h2><p>除了路径模型之外，还有一类常见的模型，需要我们对棋盘进行染色，相邻的相同颜色节点被视为连通。在路径类问题中，状态转移的时候我们枚举当前路径的方向，而在染色类问题中，我们枚举当前节点染何种颜色。在染色模型中，状态中处在相同连通性的节点可能不止两个。但总体来说依然大同小异。我们不妨来看一个经典的例题。</p><h3 id="例题「UVA-10572」Black-amp-White"><a href="#例题「UVA-10572」Black-amp-White" class="headerlink" title="例题「UVA 10572」Black &amp; White"></a>例题「UVA 10572」Black &amp; White</h3><p>???+note “ 例题 <a href="https://vjudge.net/problem/UVA-10572">「UVA 10572」Black &amp; White</a>“<br>    题目大意：在 $N\times M$ 的棋盘内对未染色的格点进行黑白染色，要求所有黑色区域和白色区域连通，且任意一个 $2\times 2$ 的子矩形内的颜色不能完全相同（例如下图中的情况非法），求合法的方案数，并构造一组合法的方案。</p><pre><code>![black_and_white1](./images/black_and_white1.svg)</code></pre><h4 id="状态编码-1"><a href="#状态编码-1" class="headerlink" title="状态编码"></a>状态编码</h4><p>我们先考虑状态编码。不考虑连通性，那么就是 <a href="https://codeforces.com/problemsets/acmsguru/problem/99999/197">SGU 197. Nice Patterns Strike Back</a>，不难用 <a href="./state.md">状压 DP</a> 直接解决。现在我们需要在状态中同时体现颜色和连通性的信息，考察轮廓线上每个位置的状态，二进制的每 <code>Offset</code> 位描述轮廓线上的一个位置，因为只有黑白两种颜色，我们用最低位的奇偶性表示颜色，其余部分示连通性。</p><p>考虑第一行上面的节点，和第一列左侧节点，如果要避免特判的话，可以考虑引入第三种颜色区分它们，这里我们观察到这些边界状态的连通性信息一定为 0，所以不需要对第三种颜色再进行额外编码。</p><p>在路径问题中我们的轮廓线是由 $m$ 个上插头与 $1$ 个左插头组成的。本题中，由于我们还需要判断当前格点为右下角的 $2\times 2$ 子矩形是否合法，所以需要记录左上角格子的颜色，因此轮廓线的长度依然是 $m+1$。</p><p>这样的编码方案中依然保留了很多冗余信息，（连通的区域颜色一定相同，且左上角的格子只需要颜色信息不需要连通性），但是因为已经用了哈希表和最小表示，对时间复杂度的影响不大，为了降低编程压力，就不再细化了。</p><p>在最多情况下（例如第一行黑白相间），每个插头的连通性信息都不一样，因此我们需要 $4$ 位二进制位记录连通性，再加上颜色信息，本题的 <code>Offset</code> 为 $5$ 位。</p><p>???+note “代码实现”<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> Offset = <span class="number">5</span>, Mask = (<span class="number">1</span> &lt;&lt; Offset) - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> c[N + <span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> b[N + <span class="number">2</span>], bb[N + <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">T_state <span class="title">encode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  T_state s = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(bb, <span class="number">-1</span>, <span class="built_in">sizeof</span>(bb));</span><br><span class="line">  <span class="type">int</span> bn = <span class="number">1</span>;</span><br><span class="line">  bb[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = m; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bi bb[b[i]]</span></span><br><span class="line">    <span class="keyword">if</span> (!~bi) bi = bn++;</span><br><span class="line">    s &lt;&lt;= Offset;</span><br><span class="line">    s |= (bi &lt;&lt; <span class="number">1</span>) | c[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decode</span><span class="params">(T_state s)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">REP</span>(i, m + <span class="number">1</span>) &#123;</span><br><span class="line">    b[i] = s &amp; Mask;</span><br><span class="line">    c[i] = b[i] &amp; <span class="number">1</span>;</span><br><span class="line">    b[i] &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    s &gt;&gt;= Offset;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="手写哈希-1"><a href="#手写哈希-1" class="headerlink" title="手写哈希"></a>手写哈希</h4><p>因为需要构造任意一组方案，这里的哈希表我们需要添加一组域 <code>pre[]</code> 来记录每个状态在上一阶段的任意一个前驱。</p><p>???+note “代码实现”<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> Prime = <span class="number">9979</span>, MaxSZ = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T_state</span>, <span class="keyword">class</span> <span class="title class_">T_key</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hashTable</span> &#123;</span><br><span class="line">  <span class="type">int</span> head[Prime];</span><br><span class="line">  <span class="type">int</span> next[MaxSZ], sz;</span><br><span class="line">  T_state state[MaxSZ];</span><br><span class="line">  T_key key[MaxSZ];</span><br><span class="line">  <span class="type">int</span> pre[MaxSZ];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sz = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T_state s, T_key d, T_state u)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = s % Prime;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; ~i; i = next[i]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (state[i] == s) &#123;</span><br><span class="line">        key[i] += d;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    state[sz] = s, key[sz] = d, pre[sz] = u;</span><br><span class="line">    next[sz] = head[x], head[x] = sz++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">roll</span><span class="params">()</span> </span>&#123; <span class="built_in">REP</span>(ii, sz) state[ii] &lt;&lt;= Offset; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">hashTable&lt;T_state, T_key&gt; _H, H[N][N], *H0, *H1;</span><br></pre></td></tr></table></figure></p><h4 id="方案构造"><a href="#方案构造" class="headerlink" title="方案构造"></a>方案构造</h4><p>有了上面的信息，我们就可以容易的构造方案了。首先遍历当前哈希表中的状态，如果连通块数目不超过 $2$，那么统计进方案数。如果方案数不为 $0$，我们倒序用 <code>pre</code> 数组构造出方案，注意每一行的末尾因为我们执行了 <code>Roll()</code> 操作，颜色需要取 <code>c[j+1]</code>。</p><p>???+note “代码实现”<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  T_key z = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> u;</span><br><span class="line">  <span class="built_in">REP</span>(i, H1-&gt;sz) &#123;</span><br><span class="line">    <span class="built_in">decode</span>(H1-&gt;state[i]);</span><br><span class="line">    <span class="keyword">if</span> (*<span class="built_in">max_element</span>(b + <span class="number">1</span>, b + m + <span class="number">1</span>) &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">      z += H1-&gt;key[i];</span><br><span class="line">      u = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">if</span> (z) &#123;</span><br><span class="line">    <span class="built_in">DWN</span>(i, n, <span class="number">0</span>) &#123;</span><br><span class="line">      B[i][m] = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">DWN</span>(j, m, <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">decode</span>(H[i][j].state[u]);</span><br><span class="line">        <span class="type">int</span> cc = j == m - <span class="number">1</span> ? c[j + <span class="number">1</span>] : c[j];</span><br><span class="line">        B[i][j] = cc ? <span class="string">&#x27;o&#x27;</span> : <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        u = H[i][j].pre[u];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">REP</span>(i, n) <span class="built_in">puts</span>(B[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="状态转移-1"><a href="#状态转移-1" class="headerlink" title="状态转移"></a>状态转移</h4><p>我们记：</p><ul><li><code>cc</code> 当前正在染色的格子的颜色</li><li><code>lf</code> 左边格子的颜色</li><li><code>up</code> 上边格子的颜色</li><li><code>lu</code> 左上格子的颜色</li></ul><p>我们用 $-1$ 表示颜色不存在。接下来讨论状态转移，一共有三种情况，合并，继承与生成：</p><p>???+note “状态转移-代码”<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">trans</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> u, <span class="type">int</span> cc)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">decode</span>(H0-&gt;state[u]);</span><br><span class="line">  <span class="type">int</span> lf = j ? c[j - <span class="number">1</span>] : <span class="number">-1</span>, lu = b[j] ? c[j] : <span class="number">-1</span>,</span><br><span class="line">      up = b[j + <span class="number">1</span>] ? c[j + <span class="number">1</span>] : <span class="number">-1</span>;  <span class="comment">// 没有颜色也是颜色的一种！</span></span><br><span class="line">  <span class="keyword">if</span> (lf == cc &amp;&amp; up == cc) &#123;         <span class="comment">// 合并</span></span><br><span class="line">    <span class="keyword">if</span> (lu == cc) <span class="keyword">return</span>;             <span class="comment">// 2x2 子矩形相同的情况</span></span><br><span class="line">    <span class="type">int</span> lf_b = b[j - <span class="number">1</span>], up_b = b[j + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">REP</span>(i, m + <span class="number">1</span>) <span class="keyword">if</span> (b[i] == up_b) &#123; b[i] = lf_b; &#125;</span><br><span class="line">    b[j] = lf_b;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lf == cc || up == cc) &#123;  <span class="comment">// 继承</span></span><br><span class="line">    <span class="keyword">if</span> (lf == cc)</span><br><span class="line">      b[j] = b[j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      b[j] = b[j + <span class="number">1</span>];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;                                             <span class="comment">// 生成</span></span><br><span class="line">    <span class="keyword">if</span> (i == n - <span class="number">1</span> &amp;&amp; j == m - <span class="number">1</span> &amp;&amp; lu == cc) <span class="keyword">return</span>;  <span class="comment">// 特判</span></span><br><span class="line">    b[j] = m + <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  c[j] = cc;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">ok</span>(i, j, cc)) <span class="keyword">return</span>;  <span class="comment">// 判断是否会因生成封闭的连通块导致不合法</span></span><br><span class="line">  H1-&gt;<span class="built_in">push</span>(<span class="built_in">encode</span>(), H0-&gt;key[u], u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于最后一种情况需要注意的是，如果已经生成了一个封闭的连通区域，那么我们不能再使用她的颜色染色，否则这种颜色会出现两个连通块。我们似乎需要额度记录这种事件，可以参考 <a href="#zoj-3213beautiful-meadow">「ZOJ 3213」Beautiful Meadow</a> 中的做法，再开一维记录这个事件。不过利用本题的特殊性，我们也可以特判掉。</p><p>???+note “特判-代码”<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ok</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> cc)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cc == c[j + <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="type">int</span> up = b[j + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> (!up) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="type">int</span> c1 = <span class="number">0</span>, c2 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">REP</span>(i, m + <span class="number">1</span>) <span class="keyword">if</span> (i != j + <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b[i] == b[j + <span class="number">1</span>]) &#123;  <span class="comment">// 连通性相同，颜色一定相同</span></span><br><span class="line">      <span class="built_in">assert</span>(c[i] == c[j + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c[i] == c[j + <span class="number">1</span>] &amp;&amp; b[i] == b[j + <span class="number">1</span>]) ++c1;</span><br><span class="line">    <span class="keyword">if</span> (c[i] == c[j + <span class="number">1</span>]) ++c2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!c1) &#123;               <span class="comment">// 如果会生成新的封闭连通块</span></span><br><span class="line">    <span class="keyword">if</span> (c2) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 如果轮廓线上还有相同的颜色</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; n - <span class="number">1</span> || j &lt; m - <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>进一步讨论连通块消失的情况。每当我们对一个格子进行染色后，如果没有其他格子与其上侧的格子连通，那么会形成一个封闭的连通块。这个事件仅在最后一行的最后两列时可以发生，否则后续为了不出现 $2\times 2$ 的同色连通块，这个颜色一定会再次出现，除了下面的情况：</p><pre><code>2 2o##o</code></pre><p>我们特判掉这种情况，这样在本题中，就可以偷懒不用记录之前是否已经生成了封闭的连通块了。</p><p>??? 例题代码<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">-8</span>&lt;-- <span class="string">&quot;docs/dp/code/plug/plug_4.cpp&quot;</span></span><br></pre></td></tr></table></figure></p><p>??? note “ 习题 <a href="https://competitiveprogramming.info/topcoder/srm/round/9992/div/1">「Topcoder SRM 312. Div1 Hard」CheapestIsland</a>“<br>    题目大意：给一个棋盘图，每个格子有权值，求权值之和最小的连通块。</p><p>??? note “ 习题 <a href="https://www.luogu.com.cn/problem/P3886">「JLOI 2009」神秘的生物</a>“<br>    题目大意：给一个棋盘图，每个格子有权值，求权值之和最大的连通块。</p><h2 id="图论模型"><a href="#图论模型" class="headerlink" title="图论模型"></a>图论模型</h2><p>???+note “ 例题 <a href="https://www.luogu.com.cn/problem/P2109">「NOI 2007 Day2」生成树计数</a>“<br>    题目大意：某类特殊图的生成树计数，每个节点恰好与其前 $k$ 个节点之间有边相连。</p><p>???+note “ 例题 <a href="https://vjudge.net/problem/HDU-5513">「2015 ACM-ICPC Asia Shenyang Regional Contest - Problem E」Efficient Tree</a>“<br>    题目大意：给出一个 $N\times M$ 的网格图，以及相邻四连通格子之间的边权。<br>    对于一颗生成树，每个节点的得分为 1+[有一条连向上的边]+[有一条连向左的边]。<br>    生成树的得分为所有节点的得分之积。</p><pre><code>你需要求出：最小生成树的边权和，以及所有最小生成树的得分之和。（$n\le 800,m\le 7$）</code></pre><h2 id="实战篇"><a href="#实战篇" class="headerlink" title="实战篇"></a>实战篇</h2><h3 id="例题「HDU-4113」Construct-the-Great-Wall"><a href="#例题「HDU-4113」Construct-the-Great-Wall" class="headerlink" title="例题「HDU 4113」Construct the Great Wall"></a>例题「HDU 4113」Construct the Great Wall</h3><p>???+note “ 例题 <a href="https://vjudge.net/problem/HDU-4113">「HDU 4113」Construct the Great Wall</a>“<br>    题目大意：在 $N\times M$ 的棋盘内构造一组回路，分割所有的 <code>x</code> 和 <code>o</code>。</p><p>有一类插头 DP 问题要求我们在棋盘上构造一组墙，以分割棋盘上的某些元素。不妨称之为修墙问题，这类问题既可视作染色模型，也可视作路径模型。</p><p><img src="/./images/greatwall.svg" alt="greatwall"></p><p>在本题中，如果视作染色模型的话，不仅需要额外讨论染色区域的周长，还要判断在角上触碰而导致不合法的情况（图 2）。另外与 <a href="https://vjudge.net/problem/UVA-10572">「UVA 10572」Black &amp; White</a> 不同的是，本题中要求围墙为简单多边形，因而对于下面的回字形的情况，在本题中是不合法的。</p><pre><code>3 3ooooxoooo</code></pre><p>因而我们使用路径模型，转化为 <a href="#%E4%B8%80%E6%9D%A1%E5%9B%9E%E8%B7%AF">一条回路</a> 来处理。</p><p>我们沿着棋盘的交叉点进行 DP（因而长宽需要增加 $1$），每次转移时，需要保证所有的 <code>x</code> 在回路之外，<code>o</code> 在回路之内。因此我们还需要维护当前位置是否在回路内部。对于这个信息我们可以加维，也可以直接统计轮廓线上到这个位置之前出现下插头次数的奇偶性（射线法）。</p><p>??? 例题代码<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REP(i, n) for (int i = 0; i &lt; n; ++i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">checkMin</span><span class="params">(T &amp;a, <span class="type">const</span> T b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> b &lt; a ? a = b, <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>, M = N;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> offset = <span class="number">3</span>, mask = (<span class="number">1</span> &lt;&lt; offset) - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> d;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> b[M + <span class="number">1</span>], bb[M + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">encode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(bb, <span class="number">-1</span>, <span class="built_in">sizeof</span>(bb));</span><br><span class="line">  <span class="type">int</span> bn = <span class="number">1</span>;</span><br><span class="line">  bb[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = m; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bi bb[b[i]]</span></span><br><span class="line">    <span class="keyword">if</span> (!~bi) bi = bn++;</span><br><span class="line">    s &lt;&lt;= offset;</span><br><span class="line">    s |= bi;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decode</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">REP</span>(i, m + <span class="number">1</span>) &#123;</span><br><span class="line">    b[i] = s &amp; mask;</span><br><span class="line">    s &gt;&gt;= offset;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MaxSZ = <span class="number">16796</span>, Prime = <span class="number">9973</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hashTable</span> &#123;</span><br><span class="line">  <span class="type">int</span> head[Prime], next[MaxSZ], sz;</span><br><span class="line">  <span class="type">int</span> state[MaxSZ];</span><br><span class="line">  <span class="type">int</span> key[MaxSZ];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sz = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = s % Prime;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; ~i; i = next[i]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (state[i] == s) &#123;</span><br><span class="line">        <span class="built_in">checkMin</span>(key[i], d);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    state[sz] = s, key[sz] = d;</span><br><span class="line">    next[sz] = head[x];</span><br><span class="line">    head[x] = sz++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">roll</span><span class="params">()</span> </span>&#123; <span class="built_in">REP</span>(i, sz) state[i] &lt;&lt;= offset; &#125;</span><br><span class="line">&#125; H[<span class="number">2</span>], *H0, *H1;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> A[N + <span class="number">1</span>][M + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> dn, <span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">  b[j] = dn;</span><br><span class="line">  b[j + <span class="number">1</span>] = rt;</span><br><span class="line">  <span class="keyword">if</span> (A[i][j] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">    <span class="type">bool</span> bad = A[i][j] == <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">    <span class="built_in">REP</span>(jj, j + <span class="number">1</span>) <span class="keyword">if</span> (b[jj]) bad ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (bad) <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  H1-&gt;<span class="built_in">push</span>(<span class="built_in">encode</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="type">int</span> ti, tj;</span><br><span class="line">  <span class="built_in">REP</span>(i, n) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, A[i]);</span><br><span class="line">    <span class="built_in">REP</span>(j, m) <span class="keyword">if</span> (A[i][j] == <span class="string">&#x27;o&#x27;</span>) ti = i, tj = j;</span><br><span class="line">    A[i][m] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">REP</span>(j, m + <span class="number">1</span>) A[n][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">  ++n, ++m, ++ti, ++tj;</span><br><span class="line">  H0 = H, H1 = H + <span class="number">1</span>;</span><br><span class="line">  H1-&gt;<span class="built_in">clear</span>();</span><br><span class="line">  d = <span class="number">0</span>;</span><br><span class="line">  H1-&gt;<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> z = INF;</span><br><span class="line">  <span class="built_in">REP</span>(i, n) &#123;</span><br><span class="line">    <span class="built_in">REP</span>(j, m) &#123;</span><br><span class="line">      <span class="built_in">swap</span>(H0, H1);</span><br><span class="line">      H1-&gt;<span class="built_in">clear</span>();</span><br><span class="line">      <span class="built_in">REP</span>(ii, H0-&gt;sz) &#123;</span><br><span class="line">        <span class="built_in">decode</span>(H0-&gt;state[ii]);</span><br><span class="line">        d = H0-&gt;key[ii] + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> lt = b[j], up = b[j + <span class="number">1</span>];</span><br><span class="line">        <span class="type">bool</span> dn = i != n - <span class="number">1</span>, rt = j != m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (lt &amp;&amp; up) &#123;</span><br><span class="line">          <span class="keyword">if</span> (lt == up) &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">REP</span>(i, m + <span class="number">1</span>) <span class="keyword">if</span> (b[i])++ cnt;</span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">2</span> &amp;&amp; i == ti &amp;&amp; j == tj) &#123;</span><br><span class="line">              <span class="built_in">checkMin</span>(z, d);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">REP</span>(i, m + <span class="number">1</span>) <span class="keyword">if</span> (b[i] == lt) b[i] = up;</span><br><span class="line">            <span class="built_in">push</span>(i, j, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lt || up) &#123;</span><br><span class="line">          <span class="type">int</span> t = lt | up;</span><br><span class="line">          <span class="keyword">if</span> (dn) &#123;</span><br><span class="line">            <span class="built_in">push</span>(i, j, t, <span class="number">0</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (rt) &#123;</span><br><span class="line">            <span class="built_in">push</span>(i, j, <span class="number">0</span>, t);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          --d;</span><br><span class="line">          <span class="built_in">push</span>(i, j, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">          ++d;</span><br><span class="line">          <span class="keyword">if</span> (dn &amp;&amp; rt) &#123;</span><br><span class="line">            <span class="built_in">push</span>(i, j, m, m);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    H1-&gt;<span class="built_in">roll</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (z == INF) z = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">int</span> T;</span><br><span class="line">  cin &gt;&gt; T;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> Case = <span class="number">1</span>; Case &lt;= T; ++Case) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %d\n&quot;</span>, Case, <span class="built_in">solve</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>??? note “ 习题 <a href="https://vjudge.net/problem/HDU-4796">「HDU 4796」Winter’s Coming</a>“<br>    题目大意：在 $N\times M$ 的棋盘内对未染色的格点进行黑白灰染色，要求所有黑色区域和白色区域连通，且黑色区域与白色区域分别与棋盘的上下边界连通，且其中黑色区域与白色区域不能相邻。每个格子有对应的代价，求一组染色方案，最小化灰色区域的代价。</p><pre><code>![4796](./images/4796.jpg)</code></pre><p>??? note “ 习题 <a href="https://vjudge.net/problem/ZOJ-2125">「ZOJ 2125」Rocket Mania</a>“<br>    题目大意：9*6 的地图上每个格子里是一种管道（-,T,L,+ 型或没有），可以把管道旋转 0°,90°,180°,270°, 问地图最多能有几行的右边界与第 X 行的左边界通过管道相连。</p><p>??? note “ 习题 <a href="https://vjudge.net/problem/ZOJ-2126">「ZOJ 2126」Rocket Mania Plus</a>“<br>    题目大意：9*6 的地图上每个格子里是一种管道（-,T,L,+ 型或没有），可以把管道旋转 0°,90°,180°,270°, 问地图最多能有几行的右边界与左边界通过管道相连。</p><p>??? note “ 习题 <a href="https://vjudge.net/problem/UVALive-4789">「World Finals 2009&#x2F;2010 Harbin」Channel</a>“<br>    题目大意：一张方格地图上用’.’表示空地、’#’表示石头，找到最长的一条路径满足：<br>    1、起点在左上角，终点在右下角。<br>    2、不能经过石头<br>    3、路径自身不能在八连通的意义下成环。（即包括拐角处也不能接触）</p><p>??? note “ 习题 <a href="https://vjudge.net/problem/HDU-3958">「HDU 3958」Tower Defence</a>“<br>    题目大意：可以转化为求解一条从 $\mathit{S}$ 到 $\mathit{T}$ 的不能接触的最长路径，拐角处可以接触。</p><p>??? note “ 习题 <a href="https://vjudge.net/problem/UVA-10531">「UVA 10531」Maze Statistics</a>“<br>    题目大意：有一个 $N\times M$ 的图，每个格子有独立概率 $\mathit{p}$ 变成障碍物。你要从迷宫左上角走到迷宫右下角。求每个格子成为一个 <strong>有解迷宫（即起点终点四联通）</strong> 中的障碍物的概率。（$N \le 5$，$M \le 6$）</p><p>??? note “ 习题 <a href="https://vjudge.net/problem/Aizu-2452">「AIZU 2452」Pipeline Plans</a>“<br>    题目大意：现有一共 12 种图案的瓷砖，每种瓷砖数量给定。要求铺到一块可视为 $R\times C$ 网格图的矩形地板上，一个格子铺一块瓷砖，且左上角格子的中心与右下角格子的中心通过瓷砖图案上的线联通。$(2 \le R \times C \le 15)$</p><pre><code>![plug2](./images/plug2.png)</code></pre><p>??? note “ 习题 <a href="https://www.luogu.com.cn/problem/P3314">「SDOI 2014」电路板</a>“<br>    题目大意：一块 $N\times M$ 的电路板，上面有些位置是电线不能走的障碍，给定 $K$ 个格子对，要求每对格子都有电线相连，且电线之间互不相交。具体来说：为了保证电路线不相交，可以一条电路线从上边界进入当前格子，从左边界离开这个格子，另外一条电路线可以从下边界进入格子，从右边界出去。（需要注意的是：电路线本身是没有方向感念的，即格子对描述的边关系是无向边。）求满足要求的最短电线长度和方案数。输出对 25619849 取余数后的结果。</p><p>??? note “ 习题 <a href="https://vjudge.net/problem/SPOJ-CAKE3">「SPOJ CAKE3」Delicious Cake</a>“<br>    题目大意：一块可视为 $N\times M$ 网格的蛋糕，现沿着格线将蛋糕切成数块，问有多少种不同的切割方法。切法相同当且仅当切成的每块蛋糕都形状相同且在同一位置上。（$min(N,M) \le 5, max(N,M) \le 130$）</p><h2 id="本章注记"><a href="#本章注记" class="headerlink" title="本章注记"></a>本章注记</h2><p>插头 DP 问题通常编码难度较大，讨论复杂，因而属于 OI&#x2F;ACM 中相对较为 <a href="https://github.com/OI-wiki/libs/blob/master/topic/7-%E7%8E%8B%E5%A4%A9%E6%87%BF-%E8%AE%BA%E5%81%8F%E9%A2%98%E7%9A%84%E5%8D%B1%E5%AE%B3.ppt">偏门的领域</a>。这方面最为经典的资料，当属 2008 年 <a href="https://www.cs.princeton.edu/~danqic/">陈丹琦</a> 的集训队论文——<a href="https://github.com/AngelKitty/review_the_national_post-graduate_entrance_examination/tree/master/books_and_notes/professional_courses/data_structures_and_algorithms/sources/%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%E8%AE%BA%E6%96%87/%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F2008%E8%AE%BA%E6%96%87%E9%9B%86/%E9%99%88%E4%B8%B9%E7%90%A6%E3%80%8A%E5%9F%BA%E4%BA%8E%E8%BF%9E%E9%80%9A%E6%80%A7%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E3%80%8B">基于连通性状态压缩的动态规划问题</a>。其次，HDU 的 notonlysuccess 2011 年曾经在博客中连续写过两篇由浅入深的专题，也是不可多得的好资料，不过现在需要在 Web Archive 里考古。</p><ul><li><a href="https://web.archive.org/web/20110815044829/http://www.notonlysuccess.com/?p=625">notonlysuccess，【专辑】插头 DP</a></li><li><a href="https://web.archive.org/web/20111007185146/http://www.notonlysuccess.com/?p=931">notonlysuccess，【完全版】插头 DP</a></li></ul><h3 id="多米诺骨牌覆盖"><a href="#多米诺骨牌覆盖" class="headerlink" title="多米诺骨牌覆盖"></a>多米诺骨牌覆盖</h3><p><a href="https://vjudge.net/problem/HDU-1400">「HDU 1400」Mondriaan’s Dream</a> 也出现在 <a href="https://oi-wiki.org/intro/resources/#_5">《算法竞赛入门经典训练指南》</a> 中，并作为《轮廓线上的动态规划》一节的例题。<a href="https://en.wikipedia.org/wiki/Domino_tiling">多米诺骨牌覆盖（Domino tiling）</a> 是一组非常经典的数学问题，稍微修改其数据范围就可以得到不同难度，需要应用不同的算法解决的子问题。</p><p>当限定 $m&#x3D;2$ 时，多米诺骨牌覆盖等价于斐波那契数列。<a href="https://www.csie.ntu.edu.tw/~r97002/temp/Concrete%20Mathematics%202e.pdf">《具体数学》</a> 中使用了该问题以引出斐波那契数列，并使用了多种方法得到其解析解。</p><p>当 $m\le 10,n\le 10^9$ 时，可以将转移方程预处理成矩阵形式，并使用 <a href="http://www.matrix67.com/blog/archives/276">矩阵乘法进行加速</a>。</p><p><img src="/./images/domino_v2_transform_matrix.svg" alt="domino_v2_transform_matrix"></p><p>当 $n,m\le 100$，可以用 <a href="https://en.wikipedia.org/wiki/FKT_algorithm">FKT Algorithm</a> 计算其所对应平面图的完美匹配数。</p><ul><li><a href="http://www.51nod.com/Challenge/Problem.html#problemId=1031">「51nod 1031」骨牌覆盖</a></li><li><a href="http://www.51nod.com/Challenge/Problem.html#problemId=1033">「51nod 1033」骨牌覆盖 V2</a>|<a href="https://vijos.org/p/1194">「Vijos 1194」Domino</a></li><li><a href="http://www.51nod.com/Challenge/Problem.html#problemId=1034">「51nod 1034」骨牌覆盖 V3</a>|<a href="https://acm.timus.ru/problem.aspx?space=1&num=1594">「Ural 1594」Aztec Treasure</a></li><li><a href="https://mathworld.wolfram.com/ChebyshevPolynomialoftheSecondKind.html">Wolfram MathWorld, Chebyshev Polynomial of the Second Kind</a></li></ul><h3 id="一条路径-1"><a href="#一条路径-1" class="headerlink" title="一条路径"></a>一条路径</h3><p>「一条路径」是 <a href="(https://en.wikipedia.org/wiki/Hamiltonian_path)">哈密度路径（Hamiltonian Path）</a> 问题在 <a href="https://mathworld.wolfram.com/GridGraph.html">格点图（Grid Graph）</a> 中的一种特殊情况。哈密顿路径的判定性问题是 <a href="https://en.wikipedia.org/wiki/NP-completeness">NP-complete</a> 家族中的重要成员。Niconico 上有一个『フカシギの数え方』おねえさんといっしょ！みんなで数えてみよう（和大姐姐一起学习计算系列）的科普向视频，就使用这个问题作为例子，来说明 NPC 问题的计算时间如何随着问题的规模的线性增长而指数增长。</p><p><img src="/./images/sm18847458.png" alt="sm18847458"></p><ul><li><a href="https://www.bilibili.com/video/BV1Cx411D74e">【动画】从方格这头走向那头有多少种走法呢～【结尾迷之感动】</a>|<a href="https://www.youtube.com/watch?v=Q4gTV4r0zRs">Youtube</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/08/23/number/"/>
      <url>/2022/08/23/number/</url>
      
        <content type="html"><![CDATA[<p>本页面将简要介绍数位 DP。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>数位：把一个数字按照个、十、百、千等等一位一位地拆开，关注它每一位上的数字。如果拆的是十进制数，那么每一位数字都是 0~9，其他进制可类比十进制。</p><p>数位 DP：用来解决一类特定问题，这种问题比较好辨认，一般具有这几个特征：</p><ol><li><p>要求统计满足一定条件的数的数量（即，最终目的为计数）；</p></li><li><p>这些条件经过转化后可以使用「数位」的思想去理解和判断；</p></li><li><p>输入会提供一个数字区间（有时也只提供上界）来作为统计的限制；</p></li><li><p>上界很大（比如 $10^{18}$），暴力枚举验证会超时。</p></li></ol><p>数位 DP 的基本原理：</p><p>考虑人类计数的方式，最朴素的计数就是从小到大开始依次加一。但我们发现对于位数比较多的数，这样的过程中有许多重复的部分。例如，从 7000 数到 7999、从 8000 数到 8999、和从 9000 数到 9999 的过程非常相似，它们都是后三位从 000 变到 999，不一样的地方只有千位这一位，所以我们可以把这些过程归并起来，将这些过程中产生的计数答案也都存在一个通用的数组里。此数组根据题目具体要求设置状态，用递推或 DP 的方式进行状态转移。</p><p>数位 DP 中通常会利用常规计数问题技巧，比如把一个区间内的答案拆成两部分相减（即 $\mathit{ans}<em>{[l, r]} &#x3D; \mathit{ans}</em>{[0, r]}-\mathit{ans}_{[0, l - 1]}$</p><p>那么有了通用答案数组，接下来就是统计答案。统计答案可以选择记忆化搜索，也可以选择循环迭代递推。为了不重不漏地统计所有不超过上限的答案，要从高到低枚举每一位，再考虑每一位都可以填哪些数字，最后利用通用答案数组统计答案。</p><p>接下来我们具体看几道题目。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>???+note “ 例 1 <a href="https://www.luogu.com.cn/problem/P2602">Luogu P2602 数字计数</a>“<br>    题目大意：给定两个正整数 $a,b$，求在 $[a,b]$ 中的所有整数中，每个数码（digit）各出现了多少次。</p><p>方法一：</p><p>发现对于满 $\mathit{i}$ 位的数，所有数字出现的次数都是相同的，故设数组 $\mathit{dp}_i$ 为满 $i$ 位的数中每个数字出现的次数，此时暂时不处理前导零。则有 $\mathit{dp}<em>i&#x3D;10 \times \mathit{dp}</em>{i−1}+10^{i−1}$，这两部分前一个是来自前 $i-1$ 位数字的贡献，后一个是来自第 $i$ 位的数字的贡献。</p><p>有了 $\mathit{dp}$ 数组，我们来考虑如何统计答案。将上界按位分开，从高到低枚举，不贴着上界时，后面可以随便取值。贴着上界时，后面就只能取 $0$ 到上界，分两部分分别计算贡献。最后考虑下前导零，第 $i$ 位为前导 $0$ 时，此时 $1$ 到 $\mathit{i-1}$ 位也都是 $0$，也就是多算了将 $i-1$ 位填满的答案，需要额外减去。</p><p>???+ note “参考代码”<br>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll l, r, dp[N], sum[N], mi[N];</span><br><span class="line">ll ans1[N], ans2[N];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(ll n, ll *ans)</span> </span>&#123;</span><br><span class="line">  ll tmp = n;</span><br><span class="line">  <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (n) a[++len] = n % <span class="number">10</span>, n /= <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = len; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) ans[j] += dp[i - <span class="number">1</span>] * a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; a[i]; j++) ans[j] += mi[i - <span class="number">1</span>];</span><br><span class="line">    tmp -= mi[i - <span class="number">1</span>] * a[i], ans[a[i]] += tmp + <span class="number">1</span>;</span><br><span class="line">    ans[<span class="number">0</span>] -= mi[i - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">  mi[<span class="number">0</span>] = <span class="number">1ll</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">13</span>; ++i) &#123;</span><br><span class="line">    dp[i] = dp[i - <span class="number">1</span>] * <span class="number">10</span> + mi[i - <span class="number">1</span>];</span><br><span class="line">    mi[i] = <span class="number">10ll</span> * mi[i - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">solve</span>(r, ans1), <span class="built_in">solve</span>(l - <span class="number">1</span>, ans2);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, ans1[i] - ans2[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方法二：</p><p>此题也可以使用记忆化搜索。$\mathit{dp}_i$ 表示不贴上限、无前导零时，位数为 $i$ 的答案。</p><p>详见代码注释</p><p>???+note “参考代码”<br>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span>  <span class="comment">//code by Alphnia</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 50005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line">ll a, b;</span><br><span class="line">ll f[<span class="number">15</span>], ksm[<span class="number">15</span>], p[<span class="number">15</span>], now[<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x, <span class="type">bool</span> f0,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="type">bool</span> lim)</span> </span>&#123;  <span class="comment">// u 表示位数，f0 是否有前导零，lim 是否都贴在上限上</span></span><br><span class="line">  <span class="keyword">if</span> (!u) &#123;</span><br><span class="line">    <span class="keyword">if</span> (f0) f0 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!lim &amp;&amp; !f0 &amp;&amp; (~f[u])) <span class="keyword">return</span> f[u];</span><br><span class="line">  ll cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> lst = lim ? p[u] : <span class="number">9</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= lst; i++) &#123;  <span class="comment">// 枚举这位要填的数字</span></span><br><span class="line">    <span class="keyword">if</span> (f0 &amp;&amp; i == <span class="number">0</span>)</span><br><span class="line">      cnt += <span class="built_in">dfs</span>(u - <span class="number">1</span>, x, <span class="number">1</span>, lim &amp;&amp; i == lst);  <span class="comment">// 处理前导零</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i == x &amp;&amp; lim &amp;&amp; i == lst)</span><br><span class="line">      cnt += now[u - <span class="number">1</span>] + <span class="number">1</span> +</span><br><span class="line">             <span class="built_in">dfs</span>(u - <span class="number">1</span>, x, <span class="number">0</span>,</span><br><span class="line">                 lim &amp;&amp; i == lst);  <span class="comment">// 此时枚举的前几位都贴在给定的上限上。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i == x)</span><br><span class="line">      cnt += ksm[u - <span class="number">1</span>] + <span class="built_in">dfs</span>(u - <span class="number">1</span>, x, <span class="number">0</span>, lim &amp;&amp; i == lst);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      cnt += <span class="built_in">dfs</span>(u - <span class="number">1</span>, x, <span class="number">0</span>, lim &amp;&amp; i == lst);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((!lim) &amp;&amp; (!f0)) f[u] = cnt;  <span class="comment">// 只有不贴着上限和没有前导零才能记忆</span></span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gans</span><span class="params">(ll d, <span class="type">int</span> dig)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">  <span class="keyword">while</span> (d) &#123;</span><br><span class="line">    p[++len] = d % <span class="number">10</span>;</span><br><span class="line">    d /= <span class="number">10</span>;</span><br><span class="line">    now[len] = now[len - <span class="number">1</span>] + p[len] * ksm[len - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">dfs</span>(len, dig, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">  ksm[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">12</span>; i++) ksm[i] = ksm[i - <span class="number">1</span>] * <span class="number">10ll</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, <span class="built_in">gans</span>(b, i) - <span class="built_in">gans</span>(a - <span class="number">1</span>, i));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">gans</span>(b, <span class="number">9</span>) - <span class="built_in">gans</span>(a - <span class="number">1</span>, <span class="number">9</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>???+note “ 例 2 <a href="https://vjudge.net/problem/HDU-2089">hdu 2089 不要62</a>“<br>    题面大意：统计一个区间内数位上不能有 4 也不能有连续的 62 的数有多少。</p><p>没有 4 的话在枚举的时候判断一下，不枚举 4 就可以保证状态合法了，所以这个约束没有记忆化的必要，而对于 62 的话，涉及到两位，当前一位是 6 或者不是 6 这两种不同情况我计数是不相同的，所以要用状态来记录不同的方案数。$\mathit{dp}_{\mathit{pos},\mathit{sta}}$ 表示当前第 $\mathit{pos}$ 位，前一位是否是 6 的状态，这里 $\mathit{sta}$ 只需要取 0 和 1 两种状态就可以了，不是 6 的情况可视为同种，不会影响计数。<br>???+note “参考代码”</p><pre><code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span>  <span class="comment">//code by Alphnia</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> x, y, dp[<span class="number">15</span>][<span class="number">3</span>], p[<span class="number">50</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">  dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] * <span class="number">9</span> - dp[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    dp[i][<span class="number">2</span>] = dp[i - <span class="number">1</span>][<span class="number">2</span>] * <span class="number">10</span> + dp[i - <span class="number">1</span>][<span class="number">1</span>] + dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">cal</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> cnt = <span class="number">0</span>, ans = <span class="number">0</span>, tmp = x;</span><br><span class="line">  <span class="keyword">while</span> (x) &#123;</span><br><span class="line">    p[++cnt] = x % <span class="number">10</span>;</span><br><span class="line">    x /= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">  p[cnt + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = cnt; i; i--) &#123;  <span class="comment">// 从高到低枚举数位</span></span><br><span class="line">    ans += p[i] * dp[i - <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (flag)</span><br><span class="line">      ans += p[i] * dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (p[i] &gt; <span class="number">4</span>) ans += dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">if</span> (p[i] &gt; <span class="number">6</span>) ans += dp[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> (p[i] &gt; <span class="number">2</span> &amp;&amp; p[i + <span class="number">1</span>] == <span class="number">6</span>) ans += dp[i][<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> (p[i] == <span class="number">4</span> || (p[i] == <span class="number">2</span> &amp;&amp; p[i + <span class="number">1</span>] == <span class="number">6</span>)) flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tmp - ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">pre</span>();</span><br><span class="line">  <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!x &amp;&amp; !y) <span class="keyword">break</span>;</span><br><span class="line">    x = <span class="built_in">min</span>(x, y), y = <span class="built_in">max</span>(x, y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">cal</span>(y + <span class="number">1</span>) - <span class="built_in">cal</span>(x));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>???+note “ 例 3 <a href="https://loj.ac/problem/10165">SCOI2009 windy 数 </a>“<br>    题目大意：给定一个区间 $[l,r]$，求其中满足条件 <strong>不含前导 $0$ 且相邻两个数字相差至少为 $2$</strong> 的数字个数。</p><p>首先我们将问题转化成更加简单的形式。设 $\mathit{ans}_i$ 表示在区间 $[1,i]$ 中满足条件的数的数量，那么所求的答案就是 $\mathit{ans}<em>r-\mathit{ans}</em>{l-1}$。</p><p>对于一个小于 $n$ 的数，它从高到低肯定出现某一位，使得这一位上的数值小于 $n$ 这一位上对应的数值。而之前的所有位都和 $n$ 上的位相等。</p><p>有了这个性质，我们可以定义 $f(i,st,op)$ 表示当前将要考虑的是从高到低的第 $i$ 位，当前该前缀的状态为 $st$ 且前缀和当前求解的数字的大小关系是 $op$（$op&#x3D;1$ 表示等于，$op&#x3D;0$ 表示小于）时的数字个数。在本题中，这个前缀的状态就是上一位的值，因为当前将要确定的位不能取哪些数只和上一位有关。在其他题目中，这个值可以是：前缀的数字和，前缀所有数字的 $\gcd$，该前缀取模某个数的余数，也有两种或多种合用的情况。</p><p>写出 <strong>状态转移方程</strong>：$f(i,st,op)&#x3D;\sum_{k&#x3D;1}^{\mathit{maxx}} f(i+1,k,op&#x3D;1~ \operatorname{and}~ k&#x3D;\mathit{maxx} )\quad (|\mathit{st}-k|\ge 2)$</p><p>这里的 $k$ 就是当前枚举的下一位的值，而 $\mathit{maxx}$ 就是当前能取到的最高位。因为如果 $\mathit{op}&#x3D;1$，那么你在这一位上取的值一定不能大于求解的数字上该位的值，否则则没有限制。</p><p>我们发现，尽管前缀所选择的状态不同，而 $f$ 的三个参数相同，答案就是一样的。为了防止这个答案被计算多次，可以使用 <a href="./memo.md">记忆化搜索</a> 的方式实现。</p><p>???+note “参考代码”<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> st, <span class="type">int</span> op)</span>  <span class="comment">// op=1 =;op=0 &lt;</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!x) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (!op &amp;&amp; ~f[x][st]) <span class="keyword">return</span> f[x][st];</span><br><span class="line">  <span class="type">int</span> maxx = op ? dim[x] : <span class="number">9</span>, ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= maxx; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(st - i) &lt; <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (st == <span class="number">11</span> &amp;&amp; i == <span class="number">0</span>)</span><br><span class="line">      ret += <span class="built_in">dfs</span>(x - <span class="number">1</span>, <span class="number">11</span>, op &amp; (i == maxx));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      ret += <span class="built_in">dfs</span>(x - <span class="number">1</span>, i, op &amp; (i == maxx));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!op) f[x][st] = ret;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">  dim.<span class="built_in">clear</span>();</span><br><span class="line">  dim.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">  <span class="type">int</span> t = x;</span><br><span class="line">  <span class="keyword">while</span> (x) &#123;</span><br><span class="line">    dim.<span class="built_in">push_back</span>(x % <span class="number">10</span>);</span><br><span class="line">    x /= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">dfs</span>(dim.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="number">11</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>???+note “例 4.<a href="https://www.spoj.com/problems/MYQ10/en/">SPOJMYQ10</a>“<br>    题面大意：假如手写下 $[n,m]$ 之间所有整数，会有多少数看起来和在镜子里看起来一模一样？（$n,m&lt;10^{44}, T&lt;10^5$)</p><p>注：由于这里考虑到的镜像，只有 $0,1,8$ 的镜像是自己本身。所以，这里的“一模一样”并不是传统意义上的回文串，而是只含有 $0,1,8$ 的回文串。</p><p>首先，在数位 DP 过程中，显然只有 $0,1,8$ 能被选中。</p><p>其次，由于数值超过 long long 范围，所以 $[n,m]&#x3D;[1,m]-[1,n-1]$ 不再适用（高精度比较繁琐），而是需要对 $n$ 是否合法进行判断，得出：$[n,m]&#x3D;[1,m]-[1,n]+\mathrm{check}(n)$。</p><p>镜像解决了，如何判断回文？</p><p>我们需要用一个小数组记录一下之前的值。在未超过一半的长度时，只要不超上限就行；在超过一半的长度时，还需要判断是否和与之“镜面对称”的位相等。</p><p>需要额外注意的是，这道题的记忆化部分，不能用 <code>memset</code>，否则会导致超时。</p><p>???+note “参考代码”<br>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">char</span> cc[])</span> </span>&#123;  <span class="comment">// n 的特判</span></span><br><span class="line">  <span class="type">int</span> strc = <span class="built_in">strlen</span>(cc);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; strc; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(cc[i] == cc[strc - i - <span class="number">1</span>] &amp;&amp;</span><br><span class="line">          (cc[i] == <span class="string">&#x27;1&#x27;</span> || cc[i] == <span class="string">&#x27;8&#x27;</span> || cc[i] == <span class="string">&#x27;0&#x27;</span>)))</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0ll</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1ll</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// now: 当前位, eff: 有效位, fulc: 是否全顶格, ful0: 是否全0</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now, <span class="type">int</span> eff, <span class="type">bool</span> ful0, <span class="type">bool</span> fulc)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (now == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1ll</span>;</span><br><span class="line">  <span class="keyword">if</span> (!fulc &amp;&amp; f[now][eff][ful0] != <span class="number">-1</span>)  <span class="comment">// 记忆化</span></span><br><span class="line">    <span class="keyword">return</span> f[now][eff][ful0];</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>, maxk = fulc ? dig[now] : <span class="number">9</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= maxk; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; i != <span class="number">1</span> &amp;&amp; i != <span class="number">8</span>) <span class="keyword">continue</span>;</span><br><span class="line">    b[now] = i;</span><br><span class="line">    <span class="keyword">if</span> (ful0 &amp;&amp; i == <span class="number">0</span>)  <span class="comment">// 全前导 0</span></span><br><span class="line">      res += <span class="built_in">dfs</span>(now - <span class="number">1</span>, eff - <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (now &gt; eff / <span class="number">2</span>)                                  <span class="comment">// 未过半程</span></span><br><span class="line">      res += <span class="built_in">dfs</span>(now - <span class="number">1</span>, eff, <span class="number">0</span>, fulc &amp;&amp; (dig[now] == i));  <span class="comment">// 已过半程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (b[now] == b[eff - now + <span class="number">1</span>])</span><br><span class="line">      res += <span class="built_in">dfs</span>(now - <span class="number">1</span>, eff, <span class="number">0</span>, fulc &amp;&amp; (dig[now] == i));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!fulc) f[now][eff][ful0] = res;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> cc1[<span class="number">100</span>], cc2[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> strc, ansm, ansn;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">char</span> cc[])</span> </span>&#123;  <span class="comment">// 处理封装</span></span><br><span class="line">  strc = <span class="built_in">strlen</span>(cc);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; strc; ++i) dig[strc - i] = cc[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">dfs</span>(strc, strc, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, cc1, cc2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">get</span>(cc2) - <span class="built_in">get</span>(cc1) + <span class="built_in">check</span>(cc1));</span><br></pre></td></tr></table></figure></p><p>???+note “例 5. <a href="https://www.luogu.com.cn/problem/P3311">P3311 数数</a>“<br>    题面：我们称一个正整数 $x$ 是幸运数，当且仅当它的十进制表示中不包含数字串集合 $S$ 中任意一个元素作为其子串。例如当 $S &#x3D; {22, 333, 0233}$ 时，$233233$ 是幸运数，$23332333$、$2023320233$、$32233223$ 不是幸运数。给定 $n$ 和 $S$，计算不大于 $n$ 的幸运数个数。答案对 $10^9 + 7$ 取模。</p><pre><code>$1 \leq n&lt;10^&#123;1201&#125;，1 \leq m \leq 100，1 \leq \sum_&#123;i = 1&#125;^m |s_i| \leq 1500，\min_&#123;i = 1&#125;^m |s_i| \geq 1$，其中 $|s_i|$ 表示字符串 $s_i$ 的长度。$n$ 没有前导 $0$，但是 $s_i$ 可能有前导 $0$。</code></pre><p>阅读题面发现，如果将数字看成字符串，那么这就是需要完成一个多模匹配，自然而然就想到 AC 自动机。普通数位 DP 中，先从高到低枚举数位，再枚举每一位都填什么，在这道题中，我们也就自然地转化为枚举已经填好的位数，再枚举此时停在 AC 自动机上的哪个节点，然后从当前节点转移到它在 AC 自动机上的子节点。</p><p>设 $f(i,j,0&#x2F;1)$ 表示当前从高到低已经填了 $i$ 位（即在 AC 自动机上走过了 $i$ 条边），此时停在标号为 $j$ 的节点上，当前是否正好贴着上界。</p><p>至于题目中的“不包含”条件，只需在 AC 自动机上给每个模式串的结尾节点都打上标记，DP 过程中一旦遇上这些结尾节点就跳过即可。</p><p>转移很好想，详见代码主函数部分。</p><p>???+note “参考代码”<br>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span>  <span class="comment">//code by Alphnia</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1505</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> s[N], c[N];</span><br><span class="line"><span class="type">int</span> ch[N][<span class="number">10</span>], fail[N], ed[N], tot, len;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> L = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!ch[now][s[i] - <span class="string">&#x27;0&#x27;</span>]) ch[now][s[i] - <span class="string">&#x27;0&#x27;</span>] = ++tot;</span><br><span class="line">    now = ch[now][s[i] - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  ed[now] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    <span class="keyword">if</span> (ch[<span class="number">0</span>][i]) q.<span class="built_in">push</span>(ch[<span class="number">0</span>][i]);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ch[u][i]) &#123;</span><br><span class="line">        fail[ch[u][i]] = ch[fail[u]][i], q.<span class="built_in">push</span>(ch[u][i]),</span><br><span class="line">        ed[ch[u][i]] |= ed[fail[ch[u][i]]];</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">        ch[u][i] = ch[fail[u]][i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ch[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll f[N][N][<span class="number">2</span>], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(ll &amp;x, ll y)</span> </span>&#123; x = (x + y) % mod; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, c);</span><br><span class="line">  n = <span class="built_in">strlen</span>(c);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s), <span class="built_in">insert</span>();</span><br><span class="line">  <span class="built_in">build</span>();</span><br><span class="line">  f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= tot; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ed[j]) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; ++k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ed[ch[j][k]]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">add</span>(f[i + <span class="number">1</span>][ch[j][k]][<span class="number">0</span>], f[i][j][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (k &lt; c[i] - <span class="string">&#x27;0&#x27;</span>) <span class="built_in">add</span>(f[i + <span class="number">1</span>][ch[j][k]][<span class="number">0</span>], f[i][j][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (k == c[i] - <span class="string">&#x27;0&#x27;</span>) <span class="built_in">add</span>(f[i + <span class="number">1</span>][ch[j][k]][<span class="number">1</span>], f[i][j][<span class="number">1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= tot; ++j) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ed[j]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">add</span>(ans, f[n][j][<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">add</span>(ans, f[n][j][<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此题可以很好地帮助理解数位 DP 的原理。</p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p><a href="https://www.luogu.com.cn/problem/P4127">Ahoi2009 self 同类分布</a></p><p><a href="https://www.luogu.com.cn/problem/P3413">洛谷  P3413 SAC#1 - 萌数</a></p><p><a href="https://vjudge.net/problem/HDU-6148">HDU 6148 Valley Number</a></p><p><a href="http://codeforces.com/problemset/problem/55/D">CF55D Beautiful numbers</a></p><p><a href="http://codeforces.com/problemset/problem/628/D">CF628D Magic Numbers</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/08/23/misc/"/>
      <url>/2022/08/23/misc/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/08/23/memo/"/>
      <url>/2022/08/23/memo/</url>
      
        <content type="html"><![CDATA[<p>记忆化搜索是一种通过记录已经遍历过的状态的信息，从而避免对同一状态重复遍历的搜索实现方式。</p><p>因为记忆化搜索确保了每个状态只访问一次，它也是一种常见的动态规划实现方式。</p><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>???+note “<a href="https://www.luogu.com.cn/problem/P1048">[NOIP2005] 采药</a>“<br>    山洞里有 $M$ 株不同的草药，采每一株都需要一些时间 $t_i$，每一株也有它自身的价值 $v_i$。给你一段时间 $T$，在这段时间里，你可以采到一些草药。让采到的草药的总价值最大。</p><pre><code>$1 \leq T \leq 10^3$，$1 \leq t_i,v_i,M \leq 100$</code></pre><h3 id="朴素的-DFS-做法"><a href="#朴素的-DFS-做法" class="headerlink" title="朴素的 DFS 做法"></a>朴素的 <a href="../search/dfs.md">DFS</a> 做法</h3><p>很容易实现这样一个朴素的搜索做法：在搜索时记录下当前准备选第几个物品、剩余的时间是多少、已经获得的价值是多少这三个参数，然后枚举当前物品是否被选，转移到相应的状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="type">int</span> n, t;</span><br><span class="line"><span class="type">int</span> tcost[<span class="number">103</span>], mget[<span class="number">103</span>];</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> tleft, <span class="type">int</span> tans)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tleft &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (pos == n + <span class="number">1</span>) &#123;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, tans);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs</span>(pos + <span class="number">1</span>, tleft, tans);</span><br><span class="line">  <span class="built_in">dfs</span>(pos + <span class="number">1</span>, tleft - tcost[pos], tans + mget[pos]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; t &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; tcost[i] &gt;&gt; mget[i];</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>, t, <span class="number">0</span>);</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python Version</span></span><br><span class="line">tcost = [<span class="number">0</span>] * <span class="number">103</span></span><br><span class="line">mget = [<span class="number">0</span>] * <span class="number">103</span></span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">pos, tleft, tans</span>):</span><br><span class="line">    <span class="keyword">global</span> ans</span><br><span class="line">    <span class="keyword">if</span> tleft &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> pos == n + <span class="number">1</span>:</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, tans)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    dfs(pos + <span class="number">1</span>, tleft, tans)</span><br><span class="line">    dfs(pos + <span class="number">1</span>, tleft - tcost[pos], tans + mget[pos])</span><br><span class="line">t, n = <span class="built_in">map</span>(<span class="keyword">lambda</span> x:<span class="built_in">int</span>(x), <span class="built_in">input</span>().split())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    tcost[i], mget[i] = <span class="built_in">map</span>(<span class="keyword">lambda</span> x:<span class="built_in">int</span>(x), <span class="built_in">input</span>().split())</span><br><span class="line">dfs(<span class="number">1</span>, t, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure><p>这种做法的时间复杂度是指数级别的，并不能通过本题。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>上面的做法为什么效率低下呢？因为同一个状态会被访问多次。</p><p>如果我们每查询完一个状态后将该状态的信息存储下来，再次需要访问这个状态就可以直接使用之前计算得到的信息，从而避免重复计算。这充分利用了动态规划中很多问题具有大量重叠子问题的特点，属于用空间换时间的「记忆化」思想。</p><p>具体到本题上，我们在朴素的 DFS 的基础上，增加一个数组 <code>mem</code> 来记录每个 <code>dfs(pos,tleft)</code> 的返回值。刚开始把 <code>mem</code> 中每个值都设成 <code>-1</code>（代表没求解过）。每次需要访问一个状态时，如果相应状态的值在 <code>mem</code> 中为 <code>-1</code>，则递归访问该状态。否则我们直接使用 <code>mem</code> 中已经存储过的值即可。</p><p>通过这样的处理，我们确保了每个状态只会被访问一次，因此该算法的的时间复杂度为 $O(TM)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="type">int</span> n, t;</span><br><span class="line"><span class="type">int</span> tcost[<span class="number">103</span>], mget[<span class="number">103</span>];</span><br><span class="line"><span class="type">int</span> mem[<span class="number">103</span>][<span class="number">1003</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> tleft)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (mem[pos][tleft] != <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> mem[pos][tleft];  <span class="comment">// 已经访问过的状态，直接返回之前记录的值</span></span><br><span class="line">  <span class="keyword">if</span> (pos == n + <span class="number">1</span>) <span class="keyword">return</span> mem[pos][tleft] = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> dfs1, dfs2 = -INF;</span><br><span class="line">  dfs1 = <span class="built_in">dfs</span>(pos + <span class="number">1</span>, tleft);</span><br><span class="line">  <span class="keyword">if</span> (tleft &gt;= tcost[pos])</span><br><span class="line">    dfs2 = <span class="built_in">dfs</span>(pos + <span class="number">1</span>, tleft - tcost[pos]) + mget[pos];  <span class="comment">// 状态转移</span></span><br><span class="line">  <span class="keyword">return</span> mem[pos][tleft] = <span class="built_in">max</span>(dfs1, dfs2);  <span class="comment">// 最后将当前状态的值存下来</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(mem, <span class="number">-1</span>, <span class="built_in">sizeof</span>(mem));</span><br><span class="line">  cin &gt;&gt; t &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; tcost[i] &gt;&gt; mget[i];</span><br><span class="line">  cout &lt;&lt; <span class="built_in">dfs</span>(<span class="number">1</span>, t) &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python Version</span></span><br><span class="line">tcost = [<span class="number">0</span>] * <span class="number">103</span></span><br><span class="line">mget = [<span class="number">0</span>] * <span class="number">103</span></span><br><span class="line">mem = [[-<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1003</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">103</span>)]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">pos, tleft</span>):</span><br><span class="line">    <span class="keyword">if</span> mem[pos][tleft] != -<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> mem[pos][tleft]</span><br><span class="line">    <span class="keyword">if</span> pos == n + <span class="number">1</span>:</span><br><span class="line">        mem[pos][tleft] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> mem[pos][tleft]</span><br><span class="line">    dfs1 = dfs2 = -INF</span><br><span class="line">    dfs1 = dfs(pos + <span class="number">1</span>, tleft)</span><br><span class="line">    <span class="keyword">if</span> tleft &gt;= tcost[pos]:</span><br><span class="line">        dfs2 = dfs(pos + <span class="number">1</span>, tleft - tcost[pos]) + mget[pos]</span><br><span class="line">    mem[pos][tleft] = <span class="built_in">max</span>(dfs1, dfs2)</span><br><span class="line">    <span class="keyword">return</span> mem[pos][tleft]</span><br><span class="line">t, n = <span class="built_in">map</span>(<span class="keyword">lambda</span> x:<span class="built_in">int</span>(x), <span class="built_in">input</span>().split())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    tcost[i], mget[i] = <span class="built_in">map</span>(<span class="keyword">lambda</span> x:<span class="built_in">int</span>(x), <span class="built_in">input</span>().split())</span><br><span class="line"><span class="built_in">print</span>(dfs(<span class="number">1</span>, t))</span><br></pre></td></tr></table></figure><h2 id="与递推的联系与区别"><a href="#与递推的联系与区别" class="headerlink" title="与递推的联系与区别"></a>与递推的联系与区别</h2><p>在求解动态规划的问题时，记忆化搜索与递推的代码，在形式上是高度类似的。这是由于它们使用了相同的状态表示方式和类似的状态转移。也正因为如此，一般来说两种实现的时间复杂度是一样的。</p><p>下面给出的是递推实现的代码（为了方便对比，没有添加滚动数组优化），通过对比可以发现二者在形式上的类似性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n, t, w[<span class="number">105</span>], v[<span class="number">105</span>], f[<span class="number">105</span>][<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; t;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= t; j++) &#123;</span><br><span class="line">      f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">      <span class="keyword">if</span> (j &gt;= w[i])</span><br><span class="line">        f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - w[i]] + v[i]);  <span class="comment">// 状态转移方程</span></span><br><span class="line">    &#125;</span><br><span class="line">  cout &lt;&lt; f[n][t];</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在求解动态规划的问题时，记忆化搜索和递推，都确保了同一状态至多只被求解一次。而它们实现这一点的方式则略有不同：递推通过设置明确的访问顺序来避免重复访问，记忆化搜索虽然没有明确规定访问顺序，但通过给已经访问过的状态打标记的方式，也达到了同样的目的。</p><p>与递推相比，记忆化搜索因为不用明确规定访问顺序，在实现难度上有时低于递推，且能比较方便地处理边界情况，这是记忆化搜索的一大优势。但与此同时，记忆化搜索难以使用滚动数组等优化，且由于存在递归，运行效率会低于递推。因此应该视题目选择更适合的实现方式。</p><h2 id="如何写记忆化搜索"><a href="#如何写记忆化搜索" class="headerlink" title="如何写记忆化搜索"></a>如何写记忆化搜索</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><ol><li>把这道题的 dp 状态和方程写出来</li><li>根据它们写出 dfs 函数</li><li>添加记忆化数组</li></ol><p>举例：</p><p>$dp_{i} &#x3D; max{dp_{j}+1}\quad (1 \leq j &lt; i \land a_{j}&lt;a_{i})$（最长上升子序列）</p><p>转为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (mem[i] != <span class="number">-1</span>) <span class="keyword">return</span> mem[i];</span><br><span class="line">  <span class="type">int</span> ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">    <span class="keyword">if</span> (a[j] &lt; a[i]) ret = <span class="built_in">max</span>(ret, <span class="built_in">dfs</span>(j) + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> mem[i] = ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(mem, <span class="number">-1</span>, <span class="built_in">sizeof</span>(mem));</span><br><span class="line">  <span class="comment">// 读入部分略去</span></span><br><span class="line">  cout &lt;&lt; <span class="built_in">dfs</span>(n) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python Version</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i</span>):</span><br><span class="line">    <span class="keyword">if</span> mem[i] != -<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> mem[i]</span><br><span class="line">    ret = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i):</span><br><span class="line">        <span class="keyword">if</span> a[j] &lt; a[i]:</span><br><span class="line">            ret = <span class="built_in">max</span>(ret, dfs(j) + <span class="number">1</span>)</span><br><span class="line">    mem[i] = ret</span><br><span class="line">    <span class="keyword">return</span> mem[i]</span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><ol><li>写出这道题的暴搜程序（最好是 <a href="../search/dfs.md">dfs</a>)</li><li>将这个 dfs 改成“无需外部变量”的 dfs</li><li>添加记忆化数组</li></ol><p>举例：本文中“采药”的例子</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/08/23/knapsack/"/>
      <url>/2022/08/23/knapsack/</url>
      
        <content type="html"><![CDATA[<p>author: hydingsy, Link-cute, Ir1d, greyqz, LuoshuiTianyi, Odeinjul, xyf007</p><p>前置知识：<a href="./index.md">动态规划部分简介</a>。</p><p>在具体讲何为「背包 dp」前，先来看如下的例题：</p><p>???+note “<a href="https://www.luogu.com.cn/problem/P2871">「USACO07 DEC」Charm Bracelet</a>“<br>    题意概要：有 $n$ 个物品和一个容量为 $W$ 的背包，每个物品有重量 $w_{i}$ 和价值 $v_{i}$ 两种属性，要求选若干物品放入背包使背包中物品的总价值最大且背包中物品的总重量不超过背包的容量。</p><p>在上述例题中，由于每个物体只有两种可能的状态（取与不取），对应二进制中的 $0$ 和 $1$，这类问题便被称为「0-1 背包问题」。</p><h2 id="0-1-背包"><a href="#0-1-背包" class="headerlink" title="0-1 背包"></a>0-1 背包</h2><p>例题中已知条件有第 $i$ 个物品的重量 $w_{i}$，价值 $v_{i}$，以及背包的总容量 $W$。</p><p>设 DP 状态 $f_{i,j}$ 为在只能放前 $i$ 个物品的情况下，容量为 $j$ 的背包所能达到的最大总价值。</p><p>考虑转移。假设当前已经处理好了前 $i-1$ 个物品的所有状态，那么对于第 $i$ 个物品，当其不放入背包时，背包的剩余容量不变，背包中物品的总价值也不变，故这种情况的最大价值为 $f_{i-1,j}$；当其放入背包时，背包的剩余容量会减小 $w_{i}$，背包中物品的总价值会增大 $v_{i}$，故这种情况的最大价值为 $f_{i-1,j-w_{i}}+v_{i}$。</p><p>由此可以得出状态转移方程：</p><p>$$<br>f_{i,j}&#x3D;\max(f_{i-1,j},f_{i-1,j-w_{i}}+v_{i})<br>$$</p><p>这里如果直接采用二维数组对状态进行记录，会出现 MLE。可以考虑改用滚动数组的形式来优化。</p><p>由于对 $f_i$ 有影响的只有 $f_{i-1}$，可以去掉第一维，直接用 $f_{i}$ 来表示处理到当前物品时背包容量为 $i$ 的最大价值，得出以下方程：</p><p>$$<br>f_j&#x3D;\max \left(f_j,f_{j-w_i}+v_i\right)<br>$$</p><p><strong>务必牢记并理解这个转移方程，因为大部分背包问题的转移方程都是在此基础上推导出来的。</strong></p><p>还有一点需要注意的是，很容易写出这样的错误核心代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt;= W - w[i]; l++)</span><br><span class="line">    f[l + w[i]] = <span class="built_in">max</span>(f[l] + v[i], f[l + w[i]]);</span><br><span class="line"><span class="comment">// 由 f[i][l + w[i]] = max(max(f[i - 1][l + w[i]],f[i - 1][l] + w[i]),f[i][l +</span></span><br><span class="line"><span class="comment">// w[i]]); 简化而来</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python Version</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    l = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> l &lt;= W - w[i]:</span><br><span class="line">        f[l + w[i]] = <span class="built_in">max</span>(f[l] + v[i], f[l + w[i]])</span><br><span class="line">        l += <span class="number">1</span></span><br><span class="line"><span class="comment"># 由 f[i][l + w[i]] = max(max(f[i - 1][l + w[i]],f[i - 1][l] + w[i]),f[i][l +</span></span><br><span class="line"><span class="comment"># w[i]]) 简化而来</span></span><br></pre></td></tr></table></figure><p>这段代码哪里错了呢？枚举顺序错了。</p><p>仔细观察代码可以发现：对于当前处理的物品 $i$ 和当前状态 $f_{i,j}$，在 $j\geqslant w_{i}$ 时，$f_{i,j}$ 是会被 $f_{i,j-w_{i}}$ 所影响的。这就相当于物品 $i$ 可以多次被放入背包，与题意不符。（事实上，这正是完全背包问题的解法）</p><p>为了避免这种情况发生，我们可以改变枚举的顺序，从 $W$ 枚举到 $w_{i}$，这样就不会出现上述的错误，因为 $f_{i,j}$ 总是在 $f_{i,j-w_{i}}$ 前被更新。</p><p>因此实际核心代码为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> l = W; l &gt;= w[i]; l--) f[l] = <span class="built_in">max</span>(f[l], f[l - w[i]] + v[i]);</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python Version</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    l = W</span><br><span class="line">    <span class="keyword">while</span> l &gt;= w[i]:</span><br><span class="line">        f[l] = <span class="built_in">max</span>(f[l], f[l - w[i]] + v[i])</span><br><span class="line">        l -= <span class="number">1</span></span><br></pre></td></tr></table></figure><p>??? 例题代码<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">-8</span>&lt;-- <span class="string">&quot;docs/dp/code/knapsack/knapsack_1.cpp&quot;</span></span><br></pre></td></tr></table></figure></p><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p>完全背包模型与 0-1 背包类似，与 0-1 背包的区别仅在于一个物品可以选取无限次，而非仅能选取一次。</p><p>我们可以借鉴 0-1 背包的思路，进行状态定义：设 $f_{i,j}$ 为只能选前 $i$ 个物品时，容量为 $j$ 的背包可以达到的最大价值。</p><p>需要注意的是，虽然定义与 0-1 背包类似，但是其状态转移方程与 0-1 背包并不相同。</p><p>可以考虑一个朴素的做法：对于第 $i$ 件物品，枚举其选了多少个来转移。这样做的时间复杂度是 $O(n^3)$ 的。</p><p>状态转移方程如下：</p><p>$$<br>f_{i,j}&#x3D;\max_{k&#x3D;0}^{+\infty}(f_{i-1,j-k\times w_i}+v_i\times k)<br>$$</p><p>考虑做一个简单的优化。可以发现，对于 $f_{i,j}$，只要通过 $f_{i,j-w_i}$ 转移就可以了。因此状态转移方程为：</p><p>$$<br>f_{i,j}&#x3D;\max(f_{i-1,j},f_{i,j-w_i}+v_i)<br>$$</p><p>理由是当我们这样转移时，$f_{i,j-w_i}$ 已经由 $f_{i,j-2\times w_i}$ 更新过，那么 $f_{i,j-w_i}$ 就是充分考虑了第 $i$ 件物品所选次数后得到的最优结果。换言之，我们通过局部最优子结构的性质重复使用了之前的枚举过程，优化了枚举的复杂度。</p><p>与 0-1 背包相同，我们可以将第一维去掉来优化空间复杂度。如果理解了 0-1 背包的优化方式，就不难明白压缩后的循环是正向的（也就是上文中提到的错误优化）。</p><p>??? note “<a href="https://www.luogu.com.cn/problem/P1616">「Luogu P1616」疯狂的采药</a>“<br>    题意概要：有 $n$ 种物品和一个容量为 $W$ 的背包，每种物品有重量 $w_{i}$ 和价值 $v_{i}$ 两种属性，要求选若干个物品放入背包使背包中物品的总价值最大且背包中物品的总重量不超过背包的容量。</p><p>??? 例题代码<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">-8</span>&lt;-- <span class="string">&quot;docs/dp/code/knapsack/knapsack_2.cpp&quot;</span></span><br></pre></td></tr></table></figure></p><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p>多重背包也是 0-1 背包的一个变式。与 0-1 背包的区别在于每种物品有 $k_i$ 个，而非一个。</p><p>一个很朴素的想法就是：把「每种物品选 $k_i$ 次」等价转换为「有 $k_i$ 个相同的物品，每个物品选一次」。这样就转换成了一个 0-1 背包模型，套用上文所述的方法就可已解决。状态转移方程如下：</p><p>$$<br>f_{i,j}&#x3D;\max_{k&#x3D;0}^{k_i}(f_{i-1,j-k\times w_i}+v_i\times k)<br>$$</p><p>时间复杂度 $O(W\sum_{i&#x3D;1}^nk_i)$。</p><h3 id="二进制分组优化"><a href="#二进制分组优化" class="headerlink" title="二进制分组优化"></a>二进制分组优化</h3><p>考虑优化。我们仍考虑把多重背包转化成 0-1 背包模型来求解。</p><p>显然，复杂度中的 $O(nW)$ 部分无法再优化了，我们只能从 $O(\sum k_i)$ 处入手。为了表述方便，我们用 $A_{i,j}$ 代表第 $i$ 种物品拆分出的第 $j$ 个物品。</p><p>在朴素的做法中，$\forall j\le k_i$，$A_{i,j}$ 均表示相同物品。那么我们效率低的原因主要在于我们进行了大量重复性的工作。举例来说，我们考虑了「同时选 $A_{i,1},A_{i,2}$」与「同时选 $A_{i,2},A_{i,3}$」这两个完全等效的情况。这样的重复性工作我们进行了许多次。那么优化拆分方式就成为了解决问题的突破口。</p><p>我们可以通过「二进制分组」的方式使拆分方式更加优美。</p><p>具体地说就是令 $A_{i,j}\left(j\in\left[0,\lfloor \log_2(k_i+1)\rfloor-1\right]\right)$ 分别表示由 $2^{j}$ 个单个物品「捆绑」而成的大物品。特殊地，若 $k_i+1$ 不是 $2$ 的整数次幂，则需要在最后添加一个由 $k_i-2^{\lfloor \log_2(k_i+1)\rfloor-1}$ 个单个物品「捆绑」而成的大物品用于补足。</p><p>举几个例子：</p><ul><li>$6&#x3D;1+2+3$</li><li>$8&#x3D;1+2+4+1$</li><li>$18&#x3D;1+2+4+8+3$</li><li>$31&#x3D;1+2+4+8+16$</li></ul><p>显然，通过上述拆分方式，可以表示任意 $\le k_i$ 个物品的等效选择方式。将每种物品按照上述方式拆分后，使用 0-1 背包的方法解决即可。</p><p>时间复杂度 $O(W\sum_{i&#x3D;1}^n\log_2k_i)$</p><p>??? 二进制分组代码<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line">index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">  <span class="type">int</span> c = <span class="number">1</span>, p, h, k;</span><br><span class="line">  cin &gt;&gt; p &gt;&gt; h &gt;&gt; k;</span><br><span class="line">  <span class="keyword">while</span> (k - c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    k -= c;</span><br><span class="line">    list[++index].w = c * p;</span><br><span class="line">    list[index].v = c * h;</span><br><span class="line">    c *= <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  list[++index].w = p * k;</span><br><span class="line">  list[index].v = h * k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python Version</span></span><br><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">    c = <span class="number">1</span></span><br><span class="line">    p, h, k = <span class="built_in">map</span>(<span class="keyword">lambda</span> x:<span class="built_in">int</span>(x), <span class="built_in">input</span>().split())</span><br><span class="line">    <span class="keyword">while</span> k - c &gt; <span class="number">0</span>:</span><br><span class="line">        k -= c</span><br><span class="line">        <span class="built_in">list</span>[index].w = c * p</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">        <span class="built_in">list</span>[index].v = c * h</span><br><span class="line">        c *= <span class="number">2</span></span><br><span class="line">    <span class="built_in">list</span>[index].w = p * k</span><br><span class="line">    index += <span class="number">1</span></span><br><span class="line">    <span class="built_in">list</span>[index].v = h * k</span><br></pre></td></tr></table></figure></code></pre><h3 id="单调队列优化"><a href="#单调队列优化" class="headerlink" title="单调队列优化"></a>单调队列优化</h3><p>见 <a href="./opt/monotonous-queue-stack.md">单调队列&#x2F;单调栈优化</a>。</p><p>习题：<a href="https://www.luogu.com.cn/problem/P1776">「Luogu P1776」宝物筛选_NOI 导刊 2010 提高（02）</a></p><h2 id="混合背包"><a href="#混合背包" class="headerlink" title="混合背包"></a>混合背包</h2><p>混合背包就是将前面三种的背包问题混合起来，有的只能取一次，有的能取无限次，有的只能取 $k$ 次。</p><p>这种题目看起来很吓人，可是只要领悟了前面几种背包的中心思想，并将其合并在一起就可以了。下面给出伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (循环物品种类) &#123;</span><br><span class="line">  if (是 0 - 1 背包)</span><br><span class="line">    套用 0 - 1 背包代码;</span><br><span class="line">  else if (是完全背包)</span><br><span class="line">    套用完全背包代码;</span><br><span class="line">  else if (是多重背包)</span><br><span class="line">    套用多重背包代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>??? note “<a href="https://www.luogu.com.cn/problem/P1833">「Luogu P1833」樱花</a>“<br>    题意概要：有 $n$ 种樱花树和长度为 $T$ 的时间，有的樱花树只能看一遍，有的樱花树最多看 $A_{i}$ 遍，有的樱花树可以看无数遍。每棵樱花树都有一个美学值 $C_{i}$，求在 $T$ 的时间内看哪些樱花树能使美学值最高。</p><h2 id="二维费用背包"><a href="#二维费用背包" class="headerlink" title="二维费用背包"></a>二维费用背包</h2><p>???+note “<a href="https://www.luogu.com.cn/problem/P1855">「Luogu P1855」榨取 kkksc03</a>“<br>    有 $n$ 个任务需要完成，完成第 $i$ 个任务需要花费 $t_i$ 分钟，产生 $c_i$ 元的开支。</p><pre><code>现在有 $T$ 分钟时间，$W$ 元钱来处理这些任务，求最多能完成多少任务。</code></pre><p>这道题是很明显的 0-1 背包问题，可是不同的是选一个物品会消耗两种价值（经费、时间），只需在状态中增加一维存放第二种价值即可。</p><p>这时候就要注意，再开一维存放物品编号就不合适了，因为容易 MLE。</p><p>例题核心代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = m; i &gt;= mi; i--)    <span class="comment">// 对经费进行一层枚举</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = t; j &gt;= ti; j--)  <span class="comment">// 对时间进行一层枚举</span></span><br><span class="line">      dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - mi][j - ti] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python Version</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    i = m</span><br><span class="line">    <span class="keyword">while</span> i &gt;= mi: <span class="comment"># 对经费进行一层枚举</span></span><br><span class="line">        j = t</span><br><span class="line">        <span class="keyword">while</span> j &gt;= ti: <span class="comment"># 对时间进行一层枚举</span></span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - mi][j - ti] + <span class="number">1</span>)</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        i -= <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h2><p>???+note “<a href="https://www.luogu.com.cn/problem/P1757">「Luogu P1757」通天之分组背包</a>“<br>    有 $n$ 件物品和一个大小为 $m$ 的背包，第 $i$ 个物品的价值为 $w_i$，体积为 $v_i$。同时，每个物品属于一个组，同组内最多只能选择一个物品。求背包能装载物品的最大总价值。</p><p>这种题怎么想呢？其实是从「在所有物品中选择一件」变成了「从当前组中选择一件」，于是就对每一组进行一次 0-1 背包就可以了。</p><p>再说一说如何进行存储。我们可以将 $t_{k,i}$ 表示第 $k$ 组的第 $i$ 件物品的编号是多少，再用 $\mathit{cnt}_k$ 表示第 $k$ 组物品有多少个。</p><p>例题核心代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= ts; k++)          <span class="comment">// 循环每一组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = m; i &gt;= <span class="number">0</span>; i--)         <span class="comment">// 循环背包容量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt[k]; j++)  <span class="comment">// 循环该组的每一个物品</span></span><br><span class="line">      <span class="keyword">if</span> (i &gt;= w[t[k][j]])</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i],</span><br><span class="line">                    dp[i - w[t[k][j]]] + c[t[k][j]]);  <span class="comment">// 像0-1背包一样状态转移</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python Version</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, ts + <span class="number">1</span>): <span class="comment"># 循环每一组</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m, -<span class="number">1</span>, -<span class="number">1</span>): <span class="comment"># 循环背包容量</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, cnt[k] + <span class="number">1</span>): <span class="comment"># 循环该组的每一个物品</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= w[t[k][j]]:</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], \</span><br><span class="line">                    dp[i - w[t[k][j]]] + c[t[k][j]]) <span class="comment"># 像0-1背包一样状态转移</span></span><br></pre></td></tr></table></figure><p>这里要注意：<strong>一定不能搞错循环顺序</strong>，这样才能保证正确性。</p><h2 id="有依赖的背包"><a href="#有依赖的背包" class="headerlink" title="有依赖的背包"></a>有依赖的背包</h2><p>???+note “<a href="https://www.luogu.com.cn/problem/P1064">「Luogu P1064」金明的预算方案</a>“<br>    金明有 $n$ 元钱，想要买 $m$ 个物品，第 $i$ 件物品的价格为 $v_i$，重要度为 $p_i$。有些物品是从属于某个主件物品的附件，要买这个物品，必须购买它的主件。</p><pre><code>目标是让所有购买的物品的 $v_i \times p_i$ 之和最大。</code></pre><p>考虑分类讨论。对于一个主件和它的若干附件，有以下几种可能：只买主件，买主件 + 某些附件。因为这几种可能性只能选一种，所以可以将这看成分组背包。</p><p>如果是多叉树的集合，则要先算子节点的集合，最后算父节点的集合。</p><h2 id="泛化物品的背包"><a href="#泛化物品的背包" class="headerlink" title="泛化物品的背包"></a>泛化物品的背包</h2><p>这种背包，没有固定的费用和价值，它的价值是随着分配给它的费用而定。在背包容量为 $V$ 的背包问题中，当分配给它的费用为 $v_i$ 时，能得到的价值就是 $h\left(v_i\right)$。这时，将固定的价值换成函数的引用即可。</p><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="小优化"><a href="#小优化" class="headerlink" title="小优化"></a>小优化</h3><p>根据贪心原理，当费用相同时，只需保留价值最高的；当价值一定时，只需保留费用最低的；当有两件物品 $i,j$ 且 $i$ 的价值大于 $j$ 的价值并且 $i$ 的费用小于 $j$ 的费用是，只需保留 $j$。</p><h3 id="背包问题变种"><a href="#背包问题变种" class="headerlink" title="背包问题变种"></a>背包问题变种</h3><h4 id="输出方案"><a href="#输出方案" class="headerlink" title="输出方案"></a>输出方案</h4><p>输出方案其实就是记录下来背包中的某一个状态是怎么推出来的。我们可以用 $g_{i,v}$ 表示第 $i$ 件物品占用空间为 $v$ 的时候是否选择了此物品。然后在转移时记录是选用了哪一种策略（选或不选）。输出时的伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> v = V;  <span class="comment">// 记录当前的存储空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为最后一件物品存储的是最终状态，所以从最后一件物品进行循环</span></span><br><span class="line"><span class="keyword">for</span> (从最后一件循环至第一件) &#123;</span><br><span class="line">  <span class="keyword">if</span> (g[i][v]) &#123;</span><br><span class="line">    选了第 i 项物品;</span><br><span class="line">    v -= 第 i 项物品的重量;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    未选第 i 项物品;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="求方案数"><a href="#求方案数" class="headerlink" title="求方案数"></a>求方案数</h4><p>对于给定的一个背包容量、物品费用、其他关系等的问题，求装到一定容量的方案总数。</p><p>这种问题就是把求最大值换成求和即可。</p><p>例如 0-1 背包问题的转移方程就变成了：</p><p>$$<br>\mathit{dp}_i&#x3D;\sum(\mathit{dp}<em>i,\mathit{dp}</em>{i-c_i})<br>$$</p><p>初始条件：$\mathit{dp}_0&#x3D;1$</p><p>因为当容量为 $0$ 时也有一个方案，即什么都不装。</p><h4 id="求最优方案总数"><a href="#求最优方案总数" class="headerlink" title="求最优方案总数"></a>求最优方案总数</h4><p>要求最优方案总数，我们要对 0-1 背包里的 $\mathit{dp}$ 数组的定义稍作修改，DP 状态 $f_{i,j}$ 为在只能放前 $i$ 个物品的情况下，容量为 $j$ 的背包“正好装满”所能达到的最大总价值。</p><p>这样修改之后，每一种 DP 状态都可以用一个 $g_{i,j}$ 来表示方案数。</p><p>$f_{i,j}$ 表示只考虑前 $i$ 个物品时背包体积“正好”是 $j$ 时的最大价值。</p><p>$g_{i,j}$ 表示只考虑前 $i$ 个物品时背包体积“正好”是 $j$ 时的方案数。</p><p>转移方程：</p><p>如果 $f_{i,j} &#x3D; f_{i-1,j}$ 且 $f_{i,j} \neq f_{i-1,j-v}+w$ 说明我们此时不选择把物品放入背包更优，方案数由 $g_{i-1,j}$ 转移过来，</p><p>如果 $f_{i,j} \neq f_{i-1,j}$ 且 $f_{i,j} &#x3D; f_{i-1,j-v}+w$ 说明我们此时选择把物品放入背包更优，方案数由 $g_{i-1,j-v}$ 转移过来，</p><p>如果 $f_{i,j} &#x3D; f_{i-1,j}$ 且 $f_{i,j} &#x3D; f_{i-1,j-v}+w$ 说明放入或不放入都能取得最优解，方案数由 $g_{i-1,j}$ 和 $g_{i-1,j-v}$ 转移过来。</p><p>初始条件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(f, <span class="number">0x3f3f</span>, <span class="built_in">sizeof</span>(f));  <span class="comment">// 避免没有装满而进行了转移</span></span><br><span class="line">f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">g[<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">// 什么都不装是一种方案</span></span><br></pre></td></tr></table></figure><p>因为背包体积最大值有可能装不满，所以最优解不一定是 $f_{m}$。</p><p>最后我们通过找到最优解的价值，把 $g_{j}$ 数组里取到最优解的所有方案数相加即可。</p><p>核心代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = V; j &gt;= v[i]; j--) &#123;</span><br><span class="line">    <span class="type">int</span> tmp = std::<span class="built_in">max</span>(dp[j], dp[j - v[i]] + w[i]);</span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (tmp == dp[j]) c += cnt[j];                       <span class="comment">// 如果从dp[j]转移</span></span><br><span class="line">    <span class="keyword">if</span> (tmp == dp[j - v[i]] + w[i]) c += cnt[j - v[i]];  <span class="comment">// 如果从dp[j-v[i]]转移</span></span><br><span class="line">    dp[j] = tmp;</span><br><span class="line">    cnt[j] = c;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> max = <span class="number">0</span>;  <span class="comment">// 寻找最优解</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= V; i++) &#123;</span><br><span class="line">  max = std::<span class="built_in">max</span>(max, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= V; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (dp[i] == max) &#123;</span><br><span class="line">    res += cnt[i];  <span class="comment">// 求和最优解方案数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="背包的第-k-优解"><a href="#背包的第-k-优解" class="headerlink" title="背包的第 k 优解"></a>背包的第 k 优解</h4><p>普通的 0-1 背包是要求最优解，在普通的背包 DP 方法上稍作改动，增加一维用于记录当前状态下的前 k 优解，即可得到求 0-1 背包第 $k$ 优解的算法。<br>具体来讲：$\mathit{dp_{i,j,k}}$ 记录了前 $i$ 个物品中，选择的物品总体积为 $j$ 时，能够得到的第 $k$ 大的价值和。这个状态可以理解为将普通 0-1 背包只用记录一个数据的 $\mathit{dp_{i,j}}$ 扩展为记录一个有序的优解序列。转移时，普通背包最优解的求法是 $\mathit{dp_{i,j}}&#x3D;\max(\mathit{dp_{i-1,j}},\mathit{dp_{i-1,j-v_{i}}}+w_{i})$，现在我们则是要合并 $\mathit{dp_{i-1,j}}$，$\mathit{dp_{i-1,j-v_{i}}}+w_{i}$ 这两个大小为 $k$ 的递减序列，并保留合并后前 $k$ 大的价值记在 $\mathit{dp_{i,j}}$ 里，这一步利用双指针法，复杂度是 $O(k)$ 的，整体时间复杂度为 $O(nmk)$。空间上，此方法与普通背包一样可以压缩掉第一维，复杂度是 $O(mk)$ 的。</p><p>??? note “<a href="https://vjudge.net/problem/HDU-2639">例题 hdu 2639 Bone Collector II</a>“<br>    求 0-1 背包的严格第 $k$ 优解。$n \leq 100,v \leq 1000,k \leq 30$</p><p>??? note “核心代码”<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line"><span class="type">int</span> i, j, p, x, y, z;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;K);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[i]);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (j = m; j &gt;= c[i]; j--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (p = <span class="number">1</span>; p &lt;= K; p++) &#123;</span><br><span class="line">      a[p] = dp[j - c[i]][p] + w[i];</span><br><span class="line">      b[p] = dp[j][p];</span><br><span class="line">    &#125;</span><br><span class="line">    a[p] = b[p] = <span class="number">-1</span>;</span><br><span class="line">    x = y = z = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (z &lt;= K &amp;&amp; (a[x] != <span class="number">-1</span> || b[y] != <span class="number">-1</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[x] &gt; b[y])</span><br><span class="line">        dp[j][z] = a[x++];</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        dp[j][z] = b[y++];</span><br><span class="line">      <span class="keyword">if</span> (dp[j][z] != dp[j][z - <span class="number">1</span>]) z++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[m][K]);</span><br></pre></td></tr></table></figure></p><h3 id="参考资料与注释"><a href="#参考资料与注释" class="headerlink" title="参考资料与注释"></a>参考资料与注释</h3><ul><li><a href="https://github.com/tianyicui/pack">背包问题九讲 - 崔添翼</a>。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/08/23/interval/"/>
      <url>/2022/08/23/interval/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是区间-DP？"><a href="#什么是区间-DP？" class="headerlink" title="什么是区间 DP？"></a>什么是区间 DP？</h2><p>区间类动态规划是线性动态规划的扩展，它在分阶段地划分问题时，与阶段中元素出现的顺序和由前一阶段的哪些元素合并而来有很大的关系。令状态 $f(i,j)$ 表示将下标位置 $i$ 到 $j$ 的所有元素合并能获得的价值的最大值，那么 $f(i,j)&#x3D;\max{f(i,k)+f(k+1,j)+cost}$，$cost$ 为将这两组元素合并起来的代价。</p><p>区间 DP 的特点：</p><p><strong>合并</strong>：即将两个或多个部分进行整合，当然也可以反过来；</p><p><strong>特征</strong>：能将问题分解为能两两合并的形式；</p><p><strong>求解</strong>：对整个问题设最优值，枚举合并点，将问题分解为左右两个部分，最后合并两个部分的最优值得到原问题的最优值。</p><p>??? note “ 例题 <a href="https://loj.ac/problem/10147">「NOI1995」石子合并</a>“<br>    题目大意：在一个环上有 $n$ 个数 $a_1,a_2,…,a_n$，进行 $n-1$ 次合并操作，每次操作将相邻的两堆合并成一堆，能获得新的一堆中的石子数量的和的得分。你需要最大化你的得分。</p><p>考虑不在环上，而在一条链上的情况。</p><p>令 $f(i,j)$ 表示将区间 $[i,j]$ 内的所有石子合并到一起的最大得分。</p><p>写出 <strong>状态转移方程</strong>：$f(i,j)&#x3D;\max{f(i,k)+f(k+1,j)+\sum_{t&#x3D;i}^{j} a_t }~(i\le k&lt;j)$</p><p>令 $sum_i$ 表示 $a$ 数组的前缀和，状态转移方程变形为 $f(i,j)&#x3D;\max{f(i,k)+f(k+1,j)+sum_j-sum_{i-1} }$。</p><h2 id="怎样进行状态转移"><a href="#怎样进行状态转移" class="headerlink" title="怎样进行状态转移"></a>怎样进行状态转移</h2><p>由于计算 $f(i,j)$ 的值时需要知道所有 $f(i,k)$ 和 $f(k+1,j)$ 的值，而这两个中包含的元素的数量都小于 $f(i,j)$，所以我们以 $len&#x3D;j-i+1$ 作为 DP 的阶段。首先从小到大枚举 $len$，然后枚举 $i$ 的值，根据 $len$ 和 $i$ 用公式计算出 $j$ 的值，然后枚举 $k$，时间复杂度为 $O(n^3)$</p><h2 id="怎样处理环"><a href="#怎样处理环" class="headerlink" title="怎样处理环"></a>怎样处理环</h2><p>题目中石子围成一个环，而不是一条链，怎么办呢？</p><p><strong>方法一</strong>：由于石子围成一个环，我们可以枚举分开的位置，将这个环转化成一个链，由于要枚举 $n$ 次，最终的时间复杂度为 $O(n^4)$。</p><p><strong>方法二</strong>：我们将这条链延长两倍，变成 $2\times n$ 堆，其中第 $i$ 堆与第 $n+i$ 堆相同，用动态规划求解后，取 $f(1,n),f(2,n+1),…,f(i,n+i-1)$ 中的最优值，即为最后的答案。时间复杂度 $O(n^3)$。</p><h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="keyword">for</span> (len = <span class="number">1</span>; len &lt;= n; len++)</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="type">int</span> j = len + i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (k = i; k &lt; j &amp;&amp; k &lt;= <span class="number">2</span> * n - <span class="number">1</span>; k++)</span><br><span class="line">      f[i][j] = <span class="built_in">max</span>(f[i][j], f[i][k] + f[k + <span class="number">1</span>][j] + sum[j] - sum[i - <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python Version</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">2</span> * n):</span><br><span class="line">        j = <span class="built_in">len</span> + i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> k &lt; j <span class="keyword">and</span> k &lt;= <span class="number">2</span> * n - <span class="number">1</span>:</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i][j], f[i][k] + f[k + <span class="number">1</span>][j] + <span class="built_in">sum</span>[j] - <span class="built_in">sum</span>[i - <span class="number">1</span>])</span><br><span class="line">            k += <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="几道练习题"><a href="#几道练习题" class="headerlink" title="几道练习题"></a>几道练习题</h2><p><a href="https://vijos.org/p/1312">NOIP 2006 能量项链</a></p><p><a href="https://vijos.org/p/1378">NOIP 2007 矩阵取数游戏</a></p><p><a href="https://www.luogu.com.cn/problem/P4767">「IOI2000」邮局</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/08/23/index/"/>
      <url>/2022/08/23/index/</url>
      
        <content type="html"><![CDATA[<p>本章将介绍介绍动态规划（Dynamic Programming, DP）及其解决的问题、根据其设计的算法及优化。</p><p>动态规划是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。</p><p>由于动态规划并不是某种具体的算法，而是一种解决特定问题的方法，因此它会出现在各式各样的数据结构中，与之相关的题目种类也更为繁杂。</p><p>在 OI 中，计数等非最优化问题的递推解法也常被不规范地称作 DP，因此本章将它们一并列出。事实上，动态规划与其它类型的递推的确有很多相似之处，学习时可以注意它们之间的异同。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">动态规划 - 维基百科，自由的百科全书</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/08/23/dynamic/"/>
      <url>/2022/08/23/dynamic/</url>
      
        <content type="html"><![CDATA[<p>前置知识：<a href="../math/matrix.md">矩阵</a>，<a href="../graph/hld.md">树链剖分</a>。</p><p>动态 DP 问题是猫锟在 WC2018 讲的黑科技，一般用来解决树上的带有点权（边权）修改操作的 DP 问题。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>以这道模板题为例子讲解一下动态 DP 的过程。</p><p>???+note “ 例题 <a href="https://www.luogu.com.cn/problem/P4719">洛谷 P4719 【模板】动态 DP</a> “<br>    给定一棵 $n$ 个点的树，点带点权。有 $m$ 次操作，每次操作给定 $x,y$ 表示修改点 $x$ 的权值为 $y$。你需要在每次操作之后求出这棵树的最大权独立集的权值大小。</p><h3 id="广义矩阵乘法"><a href="#广义矩阵乘法" class="headerlink" title="广义矩阵乘法"></a>广义矩阵乘法</h3><p>定义广义矩阵乘法 $A\times B&#x3D;C$ 为：</p><p>$$<br>C_{i,j}&#x3D;\max_{k&#x3D;1}^{n}(A_{i,k}+B_{k,j})<br>$$</p><p>相当于将普通的矩阵乘法中的乘变为加，加变为 $\max$ 操作。</p><p>同时广义矩阵乘法满足结合律，所以可以使用矩阵快速幂。</p><h3 id="不带修改操作"><a href="#不带修改操作" class="headerlink" title="不带修改操作"></a>不带修改操作</h3><p>令 $f_{i,0}$ 表示不选择 $i$ 的最大答案，$f_{i,1}$ 表示选择 $i$ 的最大答案。</p><p>则有 DP 方程：</p><p>$$<br>\begin{cases}f_{i,0}&#x3D;\sum_{son}\max(f_{son,0},f_{son,1})\f_{i,1}&#x3D;w_i+\sum_{son}f_{son,0}\end{cases}<br>$$</p><p>答案就是 $\max(f_{root,0},f_{root,1})$.</p><h3 id="带修改操作"><a href="#带修改操作" class="headerlink" title="带修改操作"></a>带修改操作</h3><p>首先将这棵树进行树链剖分，假设有这样一条重链：</p><p><img src="/./images/dynamic.png"></p><p>设 $g_{i,0}$ 表示不选择 $i$ 且只允许选择 $i$ 的轻儿子所在子树的最大答案，$g_{i,1}$ 表示选择 $i$ 的最大答案，$son_i$ 表示 $i$ 的重儿子。</p><p>假设我们已知 $g_{i,0&#x2F;1}$ 那么有 DP 方程：</p><p>$$<br>\begin{cases}f_{i,0}&#x3D;g_{i,0}+\max(f_{son_i,0},f_{son_i,1})\f_{i,1}&#x3D;g_{i,1}+f_{son_i,0}\end{cases}<br>$$</p><p>答案是 $\max(f_{root,0},f_{root,1})$.</p><p>可以构造出矩阵：</p><p>$$<br>\begin{bmatrix}<br>g_{i,0} &amp; g_{i,0}\<br>g_{i,1} &amp; -\infty<br>\end{bmatrix}\times<br>\begin{bmatrix}<br>f_{son_i,0}\f_{son_i,1}<br>\end{bmatrix}&#x3D;<br>\begin{bmatrix}<br>f_{i,0}\f_{i,1}<br>\end{bmatrix}<br>$$</p><p>注意，我们这里使用的是广义乘法规则。</p><p>可以发现，修改操作时只需要修改 $g_{i,1}$ 和每条往上的重链即可。</p><h3 id="具体思路"><a href="#具体思路" class="headerlink" title="具体思路"></a>具体思路</h3><ol><li><p>DFS 预处理求出 $f_{i,0&#x2F;1}$ 和 $g_{i,0&#x2F;1}$.</p></li><li><p>对这棵树进行树链剖分（注意，因为我们对一个点进行询问需要计算从该点到该点所在的重链末尾的区间矩阵乘，所以对于每一个点记录 $End_i$ 表示 $i$ 所在的重链末尾节点编号），每一条重链建立线段树，线段树维护 $g$ 矩阵和 $g$ 矩阵区间乘积。</p></li><li><p>修改时首先修改 $g_{i,1}$ 和线段树中 $i$ 节点的矩阵，计算 $top_i$ 矩阵的变化量，修改到 $fa_{top_i}$ 矩阵。</p></li><li><p>查询时就是 1 到其所在的重链末尾的区间乘，最后取一个 $\max$ 即可。</p></li></ol><p>??? note “代码实现”<br>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">-8</span>&lt;-- <span class="string">&quot;docs/dp/code/dynamic/dynamic_1.cpp&quot;</span></span><br></pre></td></tr></table></figure></p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><ul><li><a href="https://www.spoj.com/problems/GSS3/">SPOJ GSS3 - Can you answer these queries III</a></li><li><a href="https://loj.ac/p/2955">「NOIP2018」保卫王国</a></li><li><a href="https://loj.ac/p/2269">「SDOI2017」切树游戏</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/08/23/dag/"/>
      <url>/2022/08/23/dag/</url>
      
        <content type="html"><![CDATA[<p>DAG 即 <a href="../graph/dag.md">有向无环图</a>，一些实际问题中的二元关系都可使用 DAG 来建模，从而将这些问题转化为 DAG 上的最长（短）路问题。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>以这道题为例子，来分析一下 DAG 建模的过程。</p><p>???+note “ 例题 <a href="https://cn.vjudge.net/problem/UVA-437">UVa 437 巴比伦塔 The Tower of Babylon</a>“<br>    有 $n (n\leqslant 30)$ 种砖块，已知三条边长，每种都有无穷多个。要求选一些立方体摞成一根尽量高的柱子（每个砖块可以自行选择一条边作为高），使得每个砖块的底面长宽分别严格小于它下方砖块的底面长宽，求塔的最大高度。</p><h3 id="建立-DAG"><a href="#建立-DAG" class="headerlink" title="建立 DAG"></a>建立 DAG</h3><p>由于每个砖块的底面长宽分别严格小于它下方砖块的底面长宽，因此不难将这样一种关系作为建图的依据，而本题也就转化为最长路问题。</p><p>也就是说如果砖块 $j$ 能放在砖块 $i$ 上，那么 $i$ 和 $j$ 之间存在一条边 $(i, j)$，且边权就是砖块 $j$ 所选取的高。</p><p>本题的另一个问题在于每个砖块的高有三种选法，怎样建图更合适呢？</p><p>不妨将每个砖块拆解为三种堆叠方式，即将一个砖块分解为三个砖块，每一个拆解得到的砖块都选取不同的高。</p><p>初始的起点是大地，大地的底面是无穷大的，则大地可达任意砖块，当然我们写程序时不必特意写上无穷大。</p><p>假设有两个砖块，三条边分别为 $31, 41, 59$ 和 $33, 83, 27$，那么整张 DAG 应该如下图所示。</p><p><img src="/./images/dag-babylon.png"></p><p>图中蓝色实线框所表示的是一个砖块拆解得到的一组砖块，之所以用 ${}$ 表示底面边长，是因为砖块一旦选取了高，底面边长就是无序的。</p><p>图中黄色虚线框表示的是重复计算部分，可以采用 <a href="./memo.md">记忆化搜索</a> 的方法来避免重复计算。</p><h3 id="转移"><a href="#转移" class="headerlink" title="转移"></a>转移</h3><p>题目要求的是塔的最大高度，已经转化为最长路问题，其起点上文已指出是大地，那么终点呢？显然终点已经自然确定，那就是某砖块上不能再搭别的砖块的时候。</p><p>下面我们开始考虑转移方程。</p><p>设 $d(i,r)$ 表示第 $i$ 块砖块在最上面，且采取第 $r$ 种堆叠方式时的最大高度。那么有如下转移方程：</p><p>$$<br>d(i, r) &#x3D; \max\left{d(j, r’) + h\right}<br>$$</p><p>其中 $j$ 是所有那些在砖块 $i$ 以 $r$ 方式堆叠时可放上的砖块，$r’$ 对应 $j$ 此时的摆放方式，$h$ 对应砖块 $i$ 采用第 $r$ 种堆叠方式时的高度。</p><p>??? note “参考代码”<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">-8</span>&lt;-- <span class="string">&quot;docs/dp/code/dag/dag_1.cpp&quot;</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/08/23/count/"/>
      <url>/2022/08/23/count/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/08/23/basic/"/>
      <url>/2022/08/23/basic/</url>
      
        <content type="html"><![CDATA[<p>author: Ir1d, CBW2007, ChungZH, xhn16729, Xeonacid, tptpp, hsfzLZH1, ouuan, Marcythm, HeRaNO, greyqz, Chrogeek, partychicken, zhb2000, xyf007</p><p>本页面主要介绍了动态规划的基本思想，以及动态规划中状态及状态转移方程的设计思路，帮助各位初学者对动态规划有一个初步的了解。</p><p>本部分的其他页面，将介绍各种类型问题中动态规划模型的建立方法，以及一些动态规划的优化技巧。</p><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>???+note “<a href="https://www.luogu.com.cn/problem/P1216">[IOI1994]数字三角形</a>“<br>    给定一个 $r$ 行的数字三角形（$r \leq 1000$），需要找到一条从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到当前点左下方的点或右下方的点。</p><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        7 </span><br><span class="line">      3   8 </span><br><span class="line">    8   1   0 </span><br><span class="line">  2   7   4   4 </span><br><span class="line">4   5   2   6   5 </span><br></pre></td></tr></table></figure>在上面这个例子中，最优路径是 $7 \to 3 \to 8 \to 7 \to 5$。</code></pre><p>最简单粗暴的思路是尝试所有的路径。因为路径条数是 $O(2^r)$ 级别的，这样的做法无法接受。</p><p>注意到这样一个事实，一条最优的路径，它的每一步决策都是最优的。</p><p>以例题里提到的最优路径为例，只考虑前四步 $7 \to 3 \to 8 \to 7$，不存在一条从最顶端到 $4$ 行第 $2$ 个数的权值更大的路径。</p><p>而对于每一个点，它的下一步决策只有两种：往左下角或者往右下角（如果存在）。因此只需要记录当前点的最大权值，用这个最大权值执行下一步决策，来更新后续点的最大权值。</p><p>这样做还有一个好处：我们成功缩小了问题的规模，将一个问题分成了多个规模更小的问题。要想得到从顶端到第 $r$ 行的最优方案，只需要知道从顶端到第 $r-1$ 行的最优方案的信息就可以了。</p><p>这时候还存在一个问题：子问题间重叠的部分会有很多，同一个子问题可能会被重复访问多次，效率还是不高。解决这个问题的方法是把每个子问题的解存储下来，通过记忆化的方式限制访问顺序，确保每个子问题只被访问一次。</p><p>上面就是动态规划的一些基本思路。下面将会更系统地介绍动态规划的思想。</p><h2 id="动态规划原理"><a href="#动态规划原理" class="headerlink" title="动态规划原理"></a>动态规划原理</h2><p>能用动态规划解决的问题，需要满足三个条件：最优子结构，无后效性和子问题重叠。</p><h3 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h3><p>具有最优子结构也可能是适合用贪心的方法求解。</p><p>注意要确保我们考察了最优解中用到的所有子问题。</p><ol><li>证明问题最优解的第一个组成部分是做出一个选择；</li><li>对于一个给定问题，在其可能的第一步选择中，你界定已经知道哪种选择才会得到最优解。你现在并不关心这种选择具体是如何得到的，只是假定已经知道了这种选择；</li><li>给定可获得的最优解的选择后，确定这次选择会产生哪些子问题，以及如何最好地刻画子问题空间；</li><li>证明作为构成原问题最优解的组成部分，每个子问题的解就是它本身的最优解。方法是反证法，考虑加入某个子问题的解不是其自身的最优解，那么就可以从原问题的解中用该子问题的最优解替换掉当前的非最优解，从而得到原问题的一个更优的解，从而与原问题最优解的假设矛盾。</li></ol><p>要保持子问题空间尽量简单，只在必要时扩展。</p><p>最优子结构的不同体现在两个方面：</p><ol><li>原问题的最优解中涉及多少个子问题；</li><li>确定最优解使用哪些子问题时，需要考察多少种选择。</li></ol><p>子问题图中每个定点对应一个子问题，而需要考察的选择对应关联至子问题顶点的边。</p><h3 id="无后效性"><a href="#无后效性" class="headerlink" title="无后效性"></a>无后效性</h3><p>已经求解的子问题，不会再受到后续决策的影响。</p><h3 id="子问题重叠"><a href="#子问题重叠" class="headerlink" title="子问题重叠"></a>子问题重叠</h3><p>如果有大量的重叠子问题，我们可以用空间将这些子问题的解存储下来，避免重复求解相同的子问题，从而提升效率。</p><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>对于一个能用动态规划解决的问题，一般采用如下思路解决：</p><ol><li>将原问题划分为若干 <strong>阶段</strong>，每个阶段对应若干个子问题，提取这些子问题的特征（称之为 <strong>状态</strong>）；</li><li>寻找每一个状态的可能 <strong>决策</strong>，或者说是各状态间的相互转移方式（用数学的语言描述就是 <strong>状态转移方程</strong>）。</li><li>按顺序求解每一个阶段的问题。</li></ol><p>如果用图论的思想理解，我们建立一个 <a href="../graph/dag.md">有向无环图</a>，每个状态对应图上一个节点，决策对应节点间的连边。这样问题就转变为了一个在 DAG 上寻找最长（短）路的问题。</p><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p>???+note “最长公共子序列问题”<br>    给定一个长度为 $n$ 的序列 $A$ 和一个 长度为 $m$ 的序列 $B$（$n,m \leq 5000$），求出一个最长的序列，使得该序列既是 $A$ 的子序列，也是 $B$ 的子序列。</p><p>设 $f(i,j)$ 表示只考虑 $A$ 的前 $i$ 个元素，$B$ 的前 $j$ 个元素时的最长公共子序列的长度，则 $f(n,m)$ 即为所求结果。</p><p>对于每个 $f(i,j)$，存在三种决策：如果 $A_i&#x3D;B_j$，则可以将它接到公共子序列的末尾；另外两种决策分别是跳过 $A_i$ 或者 $B_j$。状态转移方程如下：</p><p>$$<br>f(i,j)&#x3D;\begin{cases}f(i-1,j-1)+1&amp;A_i&#x3D;B_j\\max(f(i-1,j),f(i,j-1))&amp;A_i\ne B_j\end{cases}<br>$$</p><p>可参考 <a href="http://lcs-demo.sourceforge.net/">SourceForge 的 LCS 交互网页</a> 来更好地理解 LCS 的实现过程。</p><p>该做法的时间复杂度为 $O(nm)$。</p><p>另外，本题存在 $O\left(\dfrac{nm}{w}\right)$ 的算法[^ref1]。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="type">int</span> a[MAXN], b[MAXM], f[MAXN][MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">      <span class="keyword">if</span> (a[i] == b[j])</span><br><span class="line">        f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        f[i][j] = std::<span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i][j - <span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">return</span> f[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长不下降子序列"><a href="#最长不下降子序列" class="headerlink" title="最长不下降子序列"></a>最长不下降子序列</h2><p>???+note “最长不下降子序列问题”<br>    给定一个长度为 $n$ 的序列 $A$（$n \leq 5000$），求出一个最长的 $A$ 的子序列，满足该子序列的后一个元素不小于前一个元素。</p><h3 id="算法一"><a href="#算法一" class="headerlink" title="算法一"></a>算法一</h3><p>设 $f(i)$ 表示以 $A_i$ 为结尾的最长不下降子序列的长度，则所求为 $\max_{1 \leq i \leq n} f(i)$。</p><p>计算 $f(i)$ 时，尝试将 $A_i$ 接到其他的最长不下降子序列后面，以更新答案。于是可以写出这样的状态转移方程：$f(i)&#x3D;\max_{1 \leq j &lt; i, A_j \leq A_i} (f(j)+1)$。</p><p>容易发现该算法的时间复杂度为 $O(n^2)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="type">int</span> a[MAXN], d[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  d[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">      <span class="keyword">if</span> (a[j] &lt;= a[i]) &#123;</span><br><span class="line">        d[i] = <span class="built_in">max</span>(d[i], d[j] + <span class="number">1</span>);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, d[i]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python Version</span></span><br><span class="line">a = [<span class="number">0</span>] * MAXN</span><br><span class="line">d = [<span class="number">0</span>] * MAXN</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dp</span>():</span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    ans = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i):</span><br><span class="line">            <span class="keyword">if</span> a[j] &lt;= a[i]:</span><br><span class="line">                d[i] = <span class="built_in">max</span>(d[i], d[j] + <span class="number">1</span>)</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, d[i])</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="算法二-ref2"><a href="#算法二-ref2" class="headerlink" title="算法二[^ref2]"></a>算法二[^ref2]</h3><p>当 $n$ 的范围扩大到 $n \leq 10^5$ 时，第一种做法就不够快了，下面给出了一个 $O(n \log n)$ 的做法。</p><p>首先，定义 $a_1 \dots a_n$ 为原始序列，$d$ 为当前的不下降子序列，$len$ 为子序列的长度，那么 $d_{len}$ 就是长度为 $len$ 的不下降子序列末尾元素。</p><p>初始化：$d_1&#x3D;a_1,len&#x3D;1$。</p><p>现在我们已知最长的不下降子序列长度为 1，那么我们让 $i$ 从 2 到 $n$ 循环，依次求出前 $i$ 个元素的最长不下降子序列的长度，循环的时候我们只需要维护好 $d$ 这个数组还有 $len$ 就可以了。<strong>关键在于如何维护。</strong></p><p>考虑进来一个元素 $a_i$：</p><ol><li>元素大于等于 $d_{len}$，直接将该元素插入到 $d$ 序列的末尾。</li><li>元素小于 $d_{len}$，找到 <strong>第一个</strong> 大于它的元素，插入进去，丢弃在它之后的全部元素。</li></ol><p>参考代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0x1f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">mx = dp[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">  *std::<span class="built_in">upper_bound</span>(dp, dp + n, a[i]) = a[i];</span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (dp[ans] != mx) ++ans;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python Version</span></span><br><span class="line">dp = [<span class="number">0x1f1f1f1f</span>] * MAXN</span><br><span class="line">mx = dp[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n):</span><br><span class="line">    bisect.insort_left(dp, a[i], <span class="number">0</span>, <span class="built_in">len</span>(dp))</span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> dp[ans] != mx:</span><br><span class="line">    ans += <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="参考资料与注释"><a href="#参考资料与注释" class="headerlink" title="参考资料与注释"></a>参考资料与注释</h2><p>[^ref1]: <a href="https://www.cnblogs.com/-Wallace-/p/bit-lcs.html">位运算求最长公共子序列 - -Wallace- - 博客园</a></p><p>[^ref2]: <a href="https://www.cnblogs.com/itlqs/p/5743114.html">最长不下降子序列 nlogn 算法详解 - lvmememe - 博客园</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/08/23/divide-and-conquer/"/>
      <url>/2022/08/23/divide-and-conquer/</url>
      
        <content type="html"><![CDATA[<p>author: fudonglai, AngelKitty, labuladong</p><p>本页面将介绍递归与分治算法的区别与结合运用。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>递归（英语：Recursion），在数学和计算机科学中是指在函数的定义中使用函数自身的方法，在计算机科学中还额外指一种通过重复将问题分解为同类的子问题而解决问题的方法。</p><p>分治（英语：Divide and Conquer），字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</p><h2 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><blockquote><p>要理解递归，就得先理解什么是递归。</p></blockquote><p>递归的基本思想是某个函数直接或者间接地调用自身，这样原问题的求解就转换为了许多性质相同但是规模更小的子问题。求解时只需要关注如何把原问题划分成符合条件的子问题，而不需要过分关注这个子问题是如何被解决的。</p><p>以下是一些有助于理解递归的例子：</p><ol><li><a href="./divide-and-conquer.md">什么是递归？</a></li><li>如何给一堆数字排序？答：分成两半，先排左半边再排右半边，最后合并就行了，至于怎么排左边和右边，请重新阅读这句话。</li><li>你今年几岁？答：去年的岁数加一岁，1999 年我出生。</li><li><img src="/images/divide-and-conquer-1.png" alt="一个用于理解递归的例子"></li></ol><p>递归在数学中非常常见。例如，集合论对自然数的正式定义是：1 是一个自然数，每个自然数都有一个后继，这一个后继也是自然数。</p><p>递归代码最重要的两个特征：结束条件和自我调用。自我调用是在解决子问题，而结束条件定义了最简子问题的答案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(传入数值)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (终止条件) <span class="keyword">return</span> 最小子问题解;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">func</span>(缩小规模);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="为什么要写递归"><a href="#为什么要写递归" class="headerlink" title="为什么要写递归"></a>为什么要写递归</h4><ol><li><p>结构清晰，可读性强。例如，分别用不同的方法实现 <a href="./merge-sort.md">归并排序</a>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="comment">// 不使用递归的归并排序算法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(vector&lt;T&gt; a)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> seg = <span class="number">1</span>; seg &lt; n; seg = seg + seg)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> start = <span class="number">0</span>; start &lt; n - seg; start += seg + seg)</span><br><span class="line">      <span class="built_in">merge</span>(a, start, start + seg - <span class="number">1</span>, std::<span class="built_in">min</span>(start + seg + seg - <span class="number">1</span>, n - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用递归的归并排序算法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(vector&lt;T&gt; a, <span class="type">int</span> front, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (front &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> mid = front + (end - front) / <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">merge_sort</span>(a, front, mid);</span><br><span class="line">  <span class="built_in">merge_sort</span>(a, mid + <span class="number">1</span>, end);</span><br><span class="line">  <span class="built_in">merge</span>(a, front, mid, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python Version</span></span><br><span class="line"><span class="comment">#不使用递归的归并排序算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">a</span>):</span><br><span class="line">  n = <span class="built_in">len</span>(a)</span><br><span class="line">  seg, start = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> seg &lt; n:</span><br><span class="line">      <span class="keyword">while</span> start &lt; n - seg:</span><br><span class="line">          merge(a, start, start + seg - <span class="number">1</span>, <span class="built_in">min</span>(start + seg + seg - <span class="number">1</span>, n - <span class="number">1</span>))</span><br><span class="line">          start = start + seg + seg</span><br><span class="line">      seg = seg + seg</span><br><span class="line">  </span><br><span class="line"><span class="comment">#使用递归的归并排序算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">a, front, end</span>):</span><br><span class="line">  <span class="keyword">if</span> front &gt;= end:</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">  mid = front + (end - front) / <span class="number">2</span></span><br><span class="line">  merge_sort(a, front, mid)</span><br><span class="line">  merge_sort(a, mid + <span class="number">1</span>, end)</span><br><span class="line">  merge(a, front, mid, end)</span><br></pre></td></tr></table></figure><p>显然，递归版本比非递归版本更易理解。递归版本的做法一目了然：把左半边排序，把右半边排序，最后合并两边。而非递归版本看起来不知所云，充斥着各种难以理解的边界计算细节，特别容易出 bug，且难以调试。</p></li><li><p>练习分析问题的结构。当发现问题可以被分解成相同结构的小问题时，递归写多了就能敏锐发现这个特点，进而高效解决问题。</p></li></ol><h4 id="递归的缺点"><a href="#递归的缺点" class="headerlink" title="递归的缺点"></a>递归的缺点</h4><p>在程序执行中，递归是利用堆栈来实现的。每当进入一个函数调用，栈就会增加一层栈帧，每次函数返回，栈就会减少一层栈帧。而栈不是无限大的，当递归层数过多时，就会造成 <strong>栈溢出</strong> 的后果。</p><p>显然有时候递归处理是高效的，比如归并排序；<strong>有时候是低效的</strong>，比如数孙悟空身上的毛，因为堆栈会消耗额外空间，而简单的递推不会消耗空间。比如这个例子，给一个链表头，计算它的长度：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 典型的递推遍历框架</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">(Node *head)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (Node *p = head; p != <span class="literal">nullptr</span>; p = p-&gt;next) size++;</span><br><span class="line">  <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我就是要写递归，递归天下第一</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">size_recursion</span><span class="params">(Node *head)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">size_recursion</span>(head-&gt;next) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/divide-and-conquer-2.png" alt="[二者的对比，compiler 设为 Clang 10.0，优化设为 O1](https://quick-bench.com/q/rZ7jWPmSdltparOO5ndLgmS9BVc)" title="[二者的对比，compiler 设为 Clang 10.0，优化设为 O1](https://quick-bench.com/q/rZ7jWPmSdltparOO5ndLgmS9BVc)"></p><h4 id="递归优化"><a href="#递归优化" class="headerlink" title="递归优化"></a>递归优化</h4><p>主页面：<a href="../search/opt.md">搜索优化</a> 和 <a href="../dp/memo.md">记忆化搜索</a></p><p>比较初级的递归实现可能递归次数太多，容易超时。这时需要对递归进行优化。[^ref1]</p><h3 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h3><p>分治算法的核心思想就是“分而治之”。</p><p>大概的流程可以分为三步：分解 -&gt; 解决 -&gt; 合并。</p><ol><li>分解原问题为结构相同的子问题。</li><li>分解到某个容易求解的边界之后，进行递归求解。</li><li>将子问题的解合并成原问题的解。</li></ol><p>分治法能解决的问题一般有如下特征：</p><ul><li>该问题的规模缩小到一定的程度就可以容易地解决。</li><li>该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质，利用该问题分解出的子问题的解可以合并为该问题的解。</li><li>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。</li></ul><p>???+warning “注意”<br>    如果各子问题是不独立的，则分治法要重复地解公共的子问题，也就做了许多不必要的工作。此时虽然也可用分治法，但一般用 <a href="../dp/basic.md">动态规划</a> 较好。</p><p>以归并排序为例。假设实现归并排序的函数名为 <code>merge_sort</code>。明确该函数的职责，即 <strong>对传入的一个数组排序</strong>。这个问题显然可以分解。给一个数组排序等于给该数组的左右两半分别排序，然后合并成一个数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(一个数组)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (可以很容易处理) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">merge_sort</span>(左半个数组);</span><br><span class="line">  <span class="built_in">merge_sort</span>(右半个数组);</span><br><span class="line">  <span class="built_in">merge</span>(左半个数组, 右半个数组);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传给它半个数组，那么处理完后这半个数组就已经被排好了。注意到，<code>merge_sort</code> 与二叉树的后序遍历模板极其相似。因为分治算法的套路是 <strong>分解 -&gt; 解决（触底）-&gt; 合并（回溯）</strong>，先左右分解，再处理合并，回溯就是在退栈，即相当于后序遍历。</p><p><code>merge</code> 函数的实现方式与两个有序链表的合并一致。</p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><h3 id="写递归的要点"><a href="#写递归的要点" class="headerlink" title="写递归的要点"></a>写递归的要点</h3><p><strong>明白一个函数的作用并相信它能完成这个任务，千万不要跳进这个函数里面企图探究更多细节，</strong> 否则就会陷入无穷的细节无法自拔，人脑能压几个栈啊。</p><p>以遍历二叉树为例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">traverse</span>(root-&gt;left);</span><br><span class="line">  <span class="built_in">traverse</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这几行代码就足以遍历任何一棵二叉树了。对于递归函数 <code>traverse(root)</code>，只要相信给它一个根节点 <code>root</code>，它就能遍历这棵树。所以只需要把这个节点的左右节点再传给这个函数就行了。</p><p>同样扩展到遍历一棵 N 叉树。与二叉树的写法一模一样。不过，对于 N 叉树，显然没有中序遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> child : root-&gt;children) <span class="built_in">traverse</span>(child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><h3 id="递归与枚举的区别"><a href="#递归与枚举的区别" class="headerlink" title="递归与枚举的区别"></a>递归与枚举的区别</h3><p>递归和枚举的区别在于：枚举是横向地把问题划分，然后依次求解子问题；而递归是把问题逐级分解，是纵向的拆分。</p><h3 id="递归与分治的区别"><a href="#递归与分治的区别" class="headerlink" title="递归与分治的区别"></a>递归与分治的区别</h3><p>递归是一种编程技巧，一种解决问题的思维方式；分治算法很大程度上是基于递归的，解决更具体问题的算法思想。</p><h2 id="例题详解"><a href="#例题详解" class="headerlink" title="例题详解"></a>例题详解</h2><p>???+note “<a href="https://leetcode-cn.com/problems/path-sum-iii/">437. 路径总和 III</a>“<br>    给定一个二叉树，它的每个结点都存放着一个整数值。</p><pre><code>找出路径和等于给定数值的路径总数。路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。二叉树不超过 1000 个节点，且节点数值范围是[-1000000,1000000]的整数。示例：<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</span><br><span class="line"></span><br><span class="line">      10</span><br><span class="line">     /  \</span><br><span class="line">    5   -3</span><br><span class="line">   / \    \</span><br><span class="line">  3   2   11</span><br><span class="line"> / \   \</span><br><span class="line">3  -2   1</span><br><span class="line"></span><br><span class="line">返回 3。和等于 8 的路径有：</span><br><span class="line"></span><br><span class="line">1.  5 -&gt; 3</span><br><span class="line">2.  5 -&gt; 2 -&gt; 1</span><br><span class="line">3. -3 -&gt; 11</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树结点的定义</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></code></pre><p>??? note “参考代码”<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pathSum</span><span class="params">(TreeNode *root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">count</span>(root, sum) + <span class="built_in">pathSum</span>(root-&gt;left, sum) +</span><br><span class="line">         <span class="built_in">pathSum</span>(root-&gt;right, sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(TreeNode *node, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> (node-&gt;val == sum) + <span class="built_in">count</span>(node-&gt;left, sum - node-&gt;val) +</span><br><span class="line">         <span class="built_in">count</span>(node-&gt;right, sum - node-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>??? note “题目解析”<br>    题目看起来很复杂，不过代码却极其简洁。</p><pre><code>首先明确，递归求解树的问题必然是要遍历整棵树的，所以二叉树的遍历框架（分别对左右子树递归调用函数本身）必然要出现在主函数 pathSum 中。那么对于每个节点，它们应该干什么呢？它们应该看看，自己和它们的子树包含多少条符合条件的路径。好了，这道题就结束了。按照前面说的技巧，根据刚才的分析来定义清楚每个递归函数应该做的事：`PathSum` 函数：给定一个节点和一个目标值，返回以这个节点为根的树中，和为目标值的路径总数。`count` 函数：给定一个节点和一个目标值，返回以这个节点为根的树中，能凑出几个以该节点为路径开头，和为目标值的路径总数。??? note &quot;参考代码（附注释）&quot;    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pathSum</span><span class="params">(TreeNode *root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> pathImLeading = <span class="built_in">count</span>(root, sum);  <span class="comment">// 自己为开头的路径数</span></span><br><span class="line">  <span class="type">int</span> leftPathSum = <span class="built_in">pathSum</span>(root-&gt;left, sum);  <span class="comment">// 左边路径总数（相信它能算出来）</span></span><br><span class="line">  <span class="type">int</span> rightPathSum =</span><br><span class="line">      <span class="built_in">pathSum</span>(root-&gt;right, sum);  <span class="comment">// 右边路径总数（相信它能算出来）</span></span><br><span class="line">  <span class="keyword">return</span> leftPathSum + rightPathSum + pathImLeading;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(TreeNode *node, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 能不能作为一条单独的路径呢？</span></span><br><span class="line">  <span class="type">int</span> isMe = (node-&gt;val == sum) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 左边的，你那边能凑几个 sum - node.val ？</span></span><br><span class="line">  <span class="type">int</span> leftNode = <span class="built_in">count</span>(node-&gt;left, sum - node-&gt;val);</span><br><span class="line">  <span class="comment">// 右边的，你那边能凑几个 sum - node.val ？</span></span><br><span class="line">  <span class="type">int</span> rightNode = <span class="built_in">count</span>(node-&gt;right, sum - node-&gt;val);</span><br><span class="line">  <span class="keyword">return</span> isMe + leftNode + rightNode;  <span class="comment">// 我这能凑这么多个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>还是那句话，**明白每个函数能做的事，并相信它们能够完成。**总结下，`PathSum` 函数提供了二叉树遍历框架，在遍历中对每个节点调用 `count` 函数（这里用的是先序遍历，不过中序遍历和后序遍历也可以）。`count` 函数也是一个二叉树遍历，用于寻找以该节点开头的目标值路径。</code></pre><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><ul><li><a href="https://leetcode.com/explore/learn/card/recursion-i/">LeetCode 上的递归专题练习</a></li><li><a href="https://leetcode.com/tag/divide-and-conquer/">LeetCode 上的分治算法专项练习</a></li></ul><h2 id="参考资料与注释"><a href="#参考资料与注释" class="headerlink" title="参考资料与注释"></a>参考资料与注释</h2><p>[^ref1]: <a href="https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/di-gui-xiang-jie">labuladong 的算法小抄 - 递归详解</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/08/23/counting-sort/"/>
      <url>/2022/08/23/counting-sort/</url>
      
        <content type="html"><![CDATA[<p>???+ warning<br>    本页面要介绍的不是 <a href="./radix-sort.md"><strong>基数排序</strong></a>。</p><p>本页面将简要介绍计数排序。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>计数排序（英语：Counting sort）是一种线性时间的排序算法。</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>计数排序的工作原理是使用一个额外的数组 $C$，其中第 $i$ 个元素是待排序数组 $A$ 中值等于 $i$ 的元素的个数，然后根据数组 $C$ 来将 $A$ 中的元素排到正确的位置。[^ref1]</p><p>它的工作过程分为三个步骤：</p><ol><li>计算每个数出现了几次；</li><li>求出每个数出现次数的 <a href="./prefix-sum.md">前缀和</a>；</li><li>利用出现次数的前缀和，从右至左计算每个数的排名。</li></ol><p><img src="/images/counting-sort-1-animate-example.svg" alt="counting sort animate example"></p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>计数排序是一种稳定的排序算法。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>计数排序的时间复杂度为 $O(n+w)$，其中 $w$ 代表待排序数据的值域大小。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><p>$$<br>\begin{array}{ll}<br>1 &amp; \textbf{Input. } \text{An array } A \text{ consisting of }n\text{ positive integers no greater than } w. \<br>2 &amp; \textbf{Output. } \text{Array }A\text{ after sorting in nondecreasing order stably.} \<br>3 &amp; \textbf{Method. }  \<br>4 &amp; \textbf{for }i\gets0\textbf{ to }w\<br>5 &amp; \qquad cnt[i]\gets0\<br>6 &amp; \textbf{for }i\gets1\textbf{ to }n\<br>7 &amp; \qquad cnt[A[i]]\gets cnt[A[i]]+1\<br>8 &amp; \textbf{for }i\gets1\textbf{ to }w\<br>9 &amp; \qquad cnt[i]\gets cnt[i]+cnt[i-1]\<br>10 &amp; \textbf{for }i\gets n\textbf{ downto }1\<br>11 &amp; \qquad B[cnt[A[i]]]\gets A[i]\<br>12 &amp; \qquad cnt[A[i]]\gets cnt[A[i]]-1\<br>13 &amp; \textbf{return } B<br>\end{array}<br>$$</p><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> W = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, w, a[N], cnt[W], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">counting_sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnt));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++cnt[a[i]];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= w; ++i) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; --i) b[cnt[a[i]]--] = a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python Version</span></span><br><span class="line">N = W = <span class="number">100010</span></span><br><span class="line">n = w = <span class="number">0</span></span><br><span class="line">a = b = [<span class="number">0</span>] * N</span><br><span class="line">cnt = [<span class="number">0</span>] * W</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">counting_sort</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        cnt[a[i]] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, w + <span class="number">1</span>):</span><br><span class="line">        cnt[i] += cnt[i - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        b[cnt[a[i]] - <span class="number">1</span>] = a[i]</span><br><span class="line">        cnt[a[i]] -= <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="参考资料与注释"><a href="#参考资料与注释" class="headerlink" title="参考资料与注释"></a>参考资料与注释</h2><p>[^ref1]: <a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F">计数排序 - 维基百科，自由的百科全书</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/08/23/construction/"/>
      <url>/2022/08/23/construction/</url>
      
        <content type="html"><![CDATA[<p>author: leoleoasd, yzxoi</p><p>本页面将简要介绍构造题这类题型。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>构造题是比赛中常见的一类题型。</p><p>从形式上来看，问题的答案往往具有某种规律性，使得在问题规模迅速增大的时候，仍然有机会比较容易地得到答案。</p><p>这要求解题时要思考问题规模增长对答案的影响，这种影响是否可以推广。例如，在设计动态规划方法的时候，要考虑从一个状态到后继状态的转移会造成什么影响。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>构造题一个很显著的特点就是高自由度，也就是说一道题的构造方式可能有很多种，但是会有一种较为简单的构造方式满足题意。看起来是放宽了要求，让题目变的简单了，但很多时候，正是这种高自由度导致题目没有明确思路而无从下手。</p><p>构造题另一个特点就是形式灵活，变化多样。并不存在一个通用解法或套路可以解决所有构造题，甚至很难找出解题思路的共性。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>下面将列举一些例题帮助读者体会构造题的一些思想内涵，给予思路上的启发。建议大家深入思考后再查看题解，也欢迎大家参与分享有趣的构造题。</p><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题 1"></a>例题 1</h3><p>???+note “<a href="http://codeforces.com/problemset/problem/743/C">Codeforces Round #384 (Div. 2) C.Vladik and fractions</a>“<br>    构造一组 $x,y,z$，使得对于给定的 $n$，满足 $\dfrac{1}{x}+\dfrac{1}{y}+\dfrac{1}{z}&#x3D;\dfrac{2}{n}$</p><p>??? note “解题思路”<br>    从样例二可以看出本题的构造方法。</p><pre><code>显然 $n,n+1,n(n+1)$ 为一组合法解。特殊地，当 $n=1$ 时，无解，这是因为 $n+1$ 与 $n(n+1)$ 此时相等。至于构造思路是怎么产生的，大概就是观察样例加上一点点数感了吧。此题对于数学直觉较强的人来说并不难。</code></pre><h3 id="例题-2"><a href="#例题-2" class="headerlink" title="例题 2"></a>例题 2</h3><p>???+note “<a href="https://www.luogu.com.cn/problem/P3599">Luogu P3599 Koishi Loves Construction</a>“<br>    Task1：试判断能否构造并构造一个长度为 $n$ 的 $1\dots n$ 的排列，满足其 $n$ 个前缀和在模 $n$ 的意义下互不相同</p><pre><code>Taks2：试判断能否构造并构造一个长度为 $n$ 的 $1\dots n$ 的排列，满足其 $n$ 个前缀积在模 $n$ 的意义下互不相同</code></pre><p>??? note “解题思路”<br>    对于 task1：</p><pre><code>当 $n$ 为奇数时，无法构造出合法解；当 $n$ 为偶数时，可以构造一个形如 $n,1,n-2,3,\cdots$ 这样的数列。首先，我们可以发现 $n$ 必定出现在数列的第一位，否则 $n$ 出现前后的两个前缀和必然会陷入模意义下相等的尴尬境地；然后，我们考虑构造出整个序列的方式：考虑通过构造前缀和序列的方式来获得原数列，可以发现前缀和序列两两之间的差在模意义下不能相等，因为前缀和序列的差分序列对应着原来的排列。因此我们尝试以前缀和数列在模意义下为$$0,1,-1,2,-2,\cdots$$这样的形式来构造这个序列，不难发现它完美地满足所有限制条件。对于 task2：当 $n$ 为除 $4$ 以外的合数时，无法构造出合法解当 $n$ 为质数或 $4$ 时，可以构造一个形如 $1,\dfrac&#123;2&#125;&#123;1&#125;,\dfrac&#123;3&#125;&#123;2&#125;,\cdots,\dfrac&#123;n-1&#125;&#123;n-2&#125;,n$ 这样的数列先考虑什么时候有解：显然，当 $n$ 为合数时无解。因为对于一个合数来说，存在两个比它小的数 $p,q$ 使得 $p\times q \equiv 0 \pmod n$，如 $(3\times6)\%9=0$。那么，当 $p,q$ 均出现过后，数列的前缀积将一直为 $0$，故合数时无解。特殊地，我们可以发现 $4=2\times 2$，无满足条件的 $p,q$，因此存在合法解。我们考虑如何构造这个数列：和 task1 同样的思路，我们发现 $1$ 必定出现在数列的第一位，否则 $1$ 出现前后的两个前缀积必然相等；而 $n$ 必定出现在数列的最后一位，因为 $n$ 出现位置后的所有前缀积在模意义下都为 $0$。手玩几组样例以后发现，所有样例中均有一组合法解满足前缀积在模意义下为 $1,2,3,\cdots,n$，因此我们可以构造出上文所述的数列来满足这个条件。那么我们只需证明这 $n$ 个数互不相同即可。我们发现这些数均为 $1 \cdots n-2$ 的逆元 $+1$，因此各不相同，此题得解。</code></pre><h3 id="例题-3"><a href="#例题-3" class="headerlink" title="例题 3"></a>例题 3</h3><p>???+note “<a href="https://atcoder.jp/contests/agc032/tasks/agc032_b">AtCoder Grand Contest 032 B</a>“<br>    给定一个整数 $N$，试构造一个节点数为 $N$ 无向图。令节点编号为 $1\ldots N$，要求其满足以下条件：</p><pre><code>- 这是一个简单连通图。- 存在一个整数 $S$ 使得对于任意节点，与其相邻节点的下标和为 $S$。保证输入数据有解。</code></pre><p>??? note “解题思路”<br>    手玩一下 $n&#x3D;3,4,5$ 的情况，我们可以找到一个构造思路。</p><pre><code>构造一个完全 $k$ 分图，保证这 $k$ 部分和相等。则每个点的 $S$ 均相等，为 $\dfrac&#123;(k-1)\sum_&#123;i=1&#125;^&#123;n&#125;i&#125;&#123;k&#125;$。如果 $n$ 为偶数，那么我们可以前后两两配对，即 $\&#123;1,n\&#125;,\&#123;2,n-1\&#125;\cdots$如果 $n$ 为奇数，那么我们可以把 $n$ 单拿出来作为一组，剩余的 $n-1$ 个两两配对，即 $\&#123;n\&#125;,\&#123;1,n-1\&#125;,\&#123;2,n-2\&#125;\cdots$这样构造出的图在 $n\ge 3$ 时连通性易证，在此不加赘述。此题得解。</code></pre><h3 id="例题-4"><a href="#例题-4" class="headerlink" title="例题 4"></a>例题 4</h3><p>???+note “BZOJ 4971「Lydsy1708 月赛」记忆中的背包”<br>    经过一天辛苦的工作，小 Q 进入了梦乡。他脑海中浮现出了刚进大学时学 01 背包的情景，那时还是大一萌新的小 Q 解决了一道简单的 01 背包问题。这个问题是这样的：</p><pre><code>给定 $n$ 个物品，每个物品的体积分别为 $v_1,v_2,…,v_n$，请计算从中选择一些物品（也可以不选），使得总体积恰好为 $w$ 的方案数。因为答案可能非常大，你只需要输出答案对 $P$ 取模的结果。因为长期熬夜刷题，他只看到样例输入中的 $w$ 和 $P$，以及样例输出是 $k$，看不清到底有几个物品，也看不清每个物品的体积是多少。直到梦醒，小 Q 也没有看清 $n$ 和 $v$，请写一个程序，帮助小 Q 一起回忆曾经的样例输入。</code></pre><p>??? note “解题思路”<br>    这道题是自由度最高的构造题之一了。这就导致了没有头绪，难以入手的情况。</p><pre><code>首先，不难发现模数是假的。由于我们自由构造数据，我们一定可以让方案数不超过模数。通过奇怪的方式，我们想到可以通过构造 $n$ 个 代价为 $1$ 的小物品和几个代价大于 $\dfrac&#123;w&#125;&#123;2&#125;$ 的大物品。由于大物品只能取一件，所以每个代价为 $x$ 的大物品对方案数的贡献为 $C_&#123;n&#125;^&#123;w-x&#125;$。令 $f_&#123;i,j&#125;$ 表示有 $i$ 个 $1$，方案数为 $j$ 的最小大物品数。用 dp 预处理出 $f$，通过计算可知只需预处理 $i\le 20$ 的所有值即可。此题得解。</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/08/23/complexity/"/>
      <url>/2022/08/23/complexity/</url>
      
        <content type="html"><![CDATA[<p>author: linehk</p><p>时间复杂度和空间复杂度是衡量一个算法效率的重要标准。</p><h2 id="基本操作数"><a href="#基本操作数" class="headerlink" title="基本操作数"></a>基本操作数</h2><p>同一个算法在不同的计算机上运行的速度会有一定的差别，并且实际运行速度难以在理论上进行计算，实际去测量又比较麻烦，所以我们通常考虑的不是算法运行的实际用时，而是算法运行所需要进行的基本操作的数量。</p><p>在普通的计算机上，加减乘除、访问变量（基本数据类型的变量，下同）、给变量赋值等都可以看作基本操作。</p><p>对基本操作的计数或是估测可以作为评判算法用时的指标。</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>衡量一个算法的快慢，一定要考虑数据规模的大小。所谓数据规模，一般指输入的数字个数、输入中给出的图的点数与边数等等。一般来说，数据规模越大，算法的用时就越长。而在算法竞赛中，我们衡量一个算法的效率时，最重要的不是看它在某个数据规模下的用时，而是看它的用时随数据规模而增长的趋势，即 <strong>时间复杂度</strong>。</p><p>考虑用时随数据规模变化的趋势的主要原因有以下几点：</p><ol><li>现代计算机每秒可以处理数亿乃至更多次基本运算，因此我们处理的数据规模通常很大。如果算法 A 在规模为 $n$ 的数据上用时为 $100n$ 而算法 B 在规模为 $n$ 的数据上用时为 $n^2$，在数据规模小于 $100$ 时算法 B 用时更短，但在一秒钟内算法 A 可以处理数百万规模的数据，而算法 B 只能处理数万规模的数据。在允许算法执行时间更久时，时间复杂度对可处理数据规模的影响就会更加明显，远大于同一数据规模下用时的影响。</li><li>我们采用基本操作数来表示算法的用时，而不同的基本操作实际用时是不同的，例如加减法的用时远小于除法的用时。计算时间复杂度而忽略不同基本操作之间的区别以及一次基本操作与十次基本操作之间的区别，可以消除基本操作间用时不同的影响。</li></ol><p>当然，算法的运行用时并非完全由输入规模决定，而是也与输入的内容相关。所以，时间复杂度又分为几种，例如：</p><ol><li>最坏时间复杂度，即每个输入规模下用时最长的输入对应的时间复杂度。在算法竞赛中，由于输入可以在给定的数据范围内任意给定，我们为保证算法能够通过某个数据范围内的任何数据，一般考虑最坏时间复杂度。</li><li>平均（期望）时间复杂度，即每个输入规模下所有可能输入对应用时的平均值的复杂度（随机输入下期望用时的复杂度）。</li></ol><p>所谓“用时随数据规模而增长的趋势”是一个模糊的概念，我们需要借助下文所介绍的 <strong>渐进符号</strong> 来形式化地表示时间复杂度。</p><h2 id="渐进符号"><a href="#渐进符号" class="headerlink" title="渐进符号"></a>渐进符号</h2><p>简单来说，渐进符号忽略了一个函数中增长较慢的部分以及各项的系数（在时间复杂度相关分析中，系数一般被称作“常数”），而保留了可以用来表明该函数增长趋势的重要部分。</p><h3 id="大-Θ-符号"><a href="#大-Θ-符号" class="headerlink" title="大 Θ 符号"></a>大 Θ 符号</h3><p>对于函数 $f(n)$ 和 $g(n)$，$f(n)&#x3D;\Theta(g(n))$，当且仅当 $\exists c_1,c_2,n_0&gt;0$，使得 $\forall n \ge n_0, 0\le c_1\cdot g(n)\le f(n) \le c_2\cdot g(n)$。</p><p>也就是说，如果函数 $f(n)&#x3D;\Theta(g(n))$，那么我们能找到两个正数 $c_1, c_2$ 使得 $f(n)$ 被 $c_1\cdot g(n)$ 和 $c_2\cdot g(n)$ 夹在中间。</p><p>例如，$3n^2+5n-3&#x3D;\Theta(n^2)$,$n\sqrt n + n\log^5 n+m\log m+nm&#x3D;\Theta(n\sqrt n+m\log m+nm)$。</p><h3 id="大-O-符号"><a href="#大-O-符号" class="headerlink" title="大 O 符号"></a>大 O 符号</h3><p>$\Theta$ 符号同时给了我们一个函数的上下界，如果只知道一个函数的渐进上界而不知道其渐进下界，可以使用 $O$ 符号。$f(n)&#x3D;O(g(n))$，当且仅当 $\exists c,n_0$，使得 $\forall n \ge n_0,0\le f(n)\le c\cdot g(n)$。</p><p>研究时间复杂度时通常会使用 $O$ 符号，因为我们关注的通常是程序用时的上界，而不关心其用时的下界。</p><p>需要注意的是，这里的“上界”和“下界”是对于函数的变化趋势而言的，而不是对算法而言的。算法用时的上界对应的是“最坏时间复杂度”而非大 $O$ 记号。所以，使用 $\Theta$ 记号表示最坏时间复杂度是完全可行的，甚至可以说 $\Theta$ 比 $O$ 更加精确，而使用 $O$ 记号的主要原因，一是我们有时只能证明时间复杂度的上界而无法证明其下界（这种情况一般出现在较为复杂的算法以及复杂度分析），二是 $O$ 在电脑上输入更方便一些。</p><h3 id="大-Ω-符号"><a href="#大-Ω-符号" class="headerlink" title="大 Ω 符号"></a>大 Ω 符号</h3><p>同样的，我们使用 $\Omega$ 符号来描述一个函数的渐进下界。$f(n)&#x3D;\Omega(g(n))$，当且仅当 $\exists c,n_0$，使得 $\forall n \ge n_0,0\le c\cdot g(n)\le f(n)$。</p><h3 id="小-o-符号"><a href="#小-o-符号" class="headerlink" title="小 o 符号"></a>小 o 符号</h3><p>如果说 $O$ 符号相当于小于等于号，那么 $o$ 符号就相当于小于号。</p><p>$f(n)&#x3D;o(g(n))$，当且仅当对于任意给定的正数 $c$，$\exists n_0$，使得 $\forall n \ge n_0,0\le f(n)&lt; c\cdot g(n)$。</p><h3 id="小-ω-符号"><a href="#小-ω-符号" class="headerlink" title="小 ω 符号"></a>小 ω 符号</h3><p>如果说 $\Omega$ 符号相当于大于等于号，那么 $\omega$ 符号就相当于大于号。</p><p>$f(n)&#x3D;\omega(g(n))$，当且仅当对于任意给定的正数 $c$，$\exists n_0$，使得 $\forall n \ge n_0,0\le c\cdot g(n)&lt; f(n)$。</p><p><img src="/images/order.png"></p><h3 id="常见性质"><a href="#常见性质" class="headerlink" title="常见性质"></a>常见性质</h3><ul><li>$f(n) &#x3D; \Theta(g(n))\iff f(n)&#x3D;O(g(n))\land f(n)&#x3D;\Omega(g(n))$</li><li>$f_1(n) + f_2(n) &#x3D; O(\max(f_1(n), f_2(n)))$</li><li>$f_1(n) \times f_2(n) &#x3D; O(f_1(n) \times f_2(n))$</li><li>$\forall a \neq 1, \log_a{n} &#x3D; O(\log_2 n)$。由换底公式可以得知，任何对数函数无论底数为何，都具有相同的增长率，因此渐进时间复杂度中对数的底数一般省略不写。</li></ul><h2 id="简单的时间复杂度计算的例子"><a href="#简单的时间复杂度计算的例子" class="headerlink" title="简单的时间复杂度计算的例子"></a>简单的时间复杂度计算的例子</h2><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; m; ++k) &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;hello world\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python Version</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">m = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, m):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果以输入的数值 $n$ 和 $m$ 的大小作为数据规模，则上面这段代码的时间复杂度为 $\Theta(n^2m)$。</p><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>在对一张 $n$ 个点 $m$ 条边的图进行 <a href="../graph/dfs.md">DFS</a> 时，由于每个节点和每条边都只会被访问常数次，复杂度为 $\Theta(n+m)$。</p><h2 id="哪些量是常量？"><a href="#哪些量是常量？" class="headerlink" title="哪些量是常量？"></a>哪些量是常量？</h2><p>当我们要进行若干次操作时，如何判断这若干次操作是否影响时间复杂度呢？例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;hello world\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python Version</span></span><br><span class="line">N = <span class="number">100000</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, N):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果 $N$ 的大小不被看作输入规模，那么这段代码的时间复杂度就是 $O(1)$。</p><p>进行时间复杂度计算时，哪些变量被视作输入规模是很重要的，而所有和输入规模无关的量都被视作常量，计算复杂度时可当作 $1$ 来处理。</p><p>需要注意的是，在进行时间复杂度相关的理论性讨论时，“算法能够解决任何规模的问题”是一个基本假设（当然，在实际中，由于时间和存储空间有限，无法解决规模过大的问题）。因此，能在常量时间内解决数据规模有限的问题（例如，对于数据范围内的每个可能输入预先计算出答案）并不能使一个算法的时间复杂度变为 $O(1)$。</p><h2 id="主定理-Master-Theorem"><a href="#主定理-Master-Theorem" class="headerlink" title="主定理 (Master Theorem)"></a>主定理 (Master Theorem)</h2><p>我们可以使用 Master Theorem 来快速求得关于递归算法的复杂度。<br>假设我们有递推关系式</p><p>$$<br>T(n) &#x3D; a T\left(\frac{n}{b}\right)＋f(n)\qquad \forall n &gt; b<br>$$</p><p>那么</p><p>$$<br>T(n) &#x3D; \begin{cases}\Theta(n^{\log_b a}) &amp; f(n) &#x3D; O(n^{\log_b a-\epsilon}) \ \Theta(f(n)) &amp; f(n) &#x3D; \Omega(n^{\log_b a+\epsilon}) \ \Theta(n^{\log_b a}\log^{k+1} n) &amp; f(n)&#x3D;\Theta(n^{\log_b a}\log^k n),k\ge 0 \end{cases}<br>$$</p><h2 id="均摊复杂度"><a href="#均摊复杂度" class="headerlink" title="均摊复杂度"></a>均摊复杂度</h2><p>算法往往是会对内存中的数据进行修改的，而同一个算法的多次执行，就会通过对数据的修改而互相影响。</p><p>例如快速排序中的“按大小分类”操作，单次执行的最坏时间复杂度，看似是 $O(n)$ 的。<br>但是由于快排的分治过程，先前的“分类”操作每次都减小了数组长度，所以实际的总复杂度 $O(n \log n)$，分摊在每一次“分类”操作上，是 $O(\log n)$。</p><p>多次操作的总复杂度除以操作次数，就是这种操作的 <strong>均摊复杂度</strong>。</p><h2 id="势能分析"><a href="#势能分析" class="headerlink" title="势能分析"></a>势能分析</h2><p>势能分析，是一种求均摊复杂度上界的方法。<br>求均摊复杂度，关键是表达出先前操作对当前操作的影响。势能分析用一个函数来表达此种影响。</p><p>定义“状态”$S$：即某一时刻的所有数据。<em>在快排的例子中，一个“状态”就是当前过程需要排序的下标区间</em></p><p>定义“初始状态”$S_0$：即未进行任何操作时的状态。<em>在快排的例子中，“初始状态”就是整个数组</em></p><p>假设存在从状态到数的函数 $F$，且对于任何状态 $S$，$F(S) \geq F(S_0)$，则有以下推论：</p><p>设 $S_1,S_2, \cdots ,S_m$ 为从 $S_0$ 开始连续做 $m$ 次操作所得的状态序列，$c_i$ 为第 $i$ 次操作的时间开销。</p><p>记 $p_i &#x3D; c_i + F(S_i) - F(S_{i-1})$，则 $m$ 次操作的总时间花销为</p><p>$$<br>\sum_{i&#x3D;1}^m p_i + F(S_0) - F(S_m)<br>$$</p><p>（正负相消，证明显然）</p><p>又因为 $F(S) \geq F(S_0)$，所以有</p><p>$$<br>\sum_{i&#x3D;1}^m p_i \geq \sum_{i&#x3D;1}^m c_i<br>$$</p><p>因此，若 $p_i &#x3D; O(T(n))$，则 $O(T(n))$ 是均摊复杂度的一个上界。</p><p>势能分析使用中有很多技巧，案例在此不题。</p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>类似地，算法所使用的空间随输入规模变化的趋势可以用 <strong>空间复杂度</strong> 来衡量。</p><h2 id="计算复杂性"><a href="#计算复杂性" class="headerlink" title="计算复杂性"></a>计算复杂性</h2><p>本文内容主要是从算法分析的角度对复杂度进行了介绍，如果有兴趣的话可以在 <a href="../misc/cc-basic.md">计算复杂性</a> 进行更深入的了解。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/08/23/bucket-sort/"/>
      <url>/2022/08/23/bucket-sort/</url>
      
        <content type="html"><![CDATA[<p>本页面将简要介绍桶排序。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>桶排序（英文：Bucket sort）是排序算法的一种，适用于待排序数据值域较大但分布比较均匀的情况。</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>桶排序按下列步骤进行：</p><ol><li>设置一个定量的数组当作空桶；</li><li>遍历序列，并将元素一个个放到对应的桶中；</li><li>对每个不是空的桶进行排序；</li><li>从不是空的桶里把元素再放回原来的序列中。</li></ol><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>如果使用稳定的内层排序，并且将元素插入桶中时不改变元素间的相对顺序，那么桶排序就是一种稳定的排序算法。</p><p>由于每块元素不多，一般使用插入排序。此时桶排序是一种稳定的排序算法。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>桶排序的平均时间复杂度为 $O(n + n^2&#x2F;k + k)$（将值域平均分成 $n$ 块 + 排序 + 重新合并元素），当 $k\approx n$ 时为 $O(n)$。[^ref1]</p><p>桶排序的最坏时间复杂度为 $O(n^2)$。</p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, w, a[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; bucket[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertion_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; A.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="type">int</span> key = A[i];</span><br><span class="line">    <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; A[j] &gt; key) &#123;</span><br><span class="line">      A[j + <span class="number">1</span>] = A[j];</span><br><span class="line">      --j;</span><br><span class="line">    &#125;</span><br><span class="line">    A[j + <span class="number">1</span>] = key;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bucket_sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> bucket_size = w / n + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    bucket[i].<span class="built_in">clear</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    bucket[a[i] / bucket_size].<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="built_in">insertion_sort</span>(bucket[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; bucket[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">      a[++p] = bucket[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python Version</span></span><br><span class="line">N = <span class="number">100010</span></span><br><span class="line">w = n = <span class="number">0</span></span><br><span class="line">a = [<span class="number">0</span>] * N</span><br><span class="line">bucket = [[] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insertion_sort</span>(<span class="params">A</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(A)):</span><br><span class="line">        key = A[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> A[j] &gt; key:</span><br><span class="line">            A[j + <span class="number">1</span>] = A[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        A[j + <span class="number">1</span>] = key</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bucket_sort</span>():</span><br><span class="line">    bucket_size = <span class="built_in">int</span>(w / n + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n):</span><br><span class="line">        bucket[i].clear()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        bucket[<span class="built_in">int</span>(a[i] / bucket_size)].append(a[i])</span><br><span class="line">    p = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n):</span><br><span class="line">        insertion_sort(bucket[i])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(bucket[i])):</span><br><span class="line">            a[p] = bucket[i][j]</span><br><span class="line">            p += <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="参考资料与注释"><a href="#参考资料与注释" class="headerlink" title="参考资料与注释"></a>参考资料与注释</h2><p>[^ref1]: <a href="https://en.wikipedia.org/wiki/Bucket_sort#Average-case_analysis">（英文）Bucket sort - Wikipedia</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/08/23/bubble-sort/"/>
      <url>/2022/08/23/bubble-sort/</url>
      
        <content type="html"><![CDATA[<p>本页面将简要介绍冒泡排序。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>冒泡排序（英语：Bubble sort）是一种简单的排序算法。由于在算法的执行过程中，较小的元素像是气泡般慢慢「浮」到数列的顶端，故叫做冒泡排序。</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>它的工作原理是每次检查相邻两个元素，如果前面的元素与后面的元素满足给定的排序条件，就将相邻两个元素交换。当没有相邻的元素需要交换时，排序就完成了。</p><p>经过 $i$ 次扫描后，数列的末尾 $i$ 项必然是最大的 $i$ 项，因此冒泡排序最多需要扫描 $n-1$ 遍数组就能完成排序。</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>冒泡排序是一种稳定的排序算法。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>在序列完全有序时，冒泡排序只需遍历一遍数组，不用执行任何交换操作，时间复杂度为 $O(n)$。</p><p>在最坏情况下，冒泡排序要执行 $\frac{(n-1)n}{2}$ 次交换操作，时间复杂度为 $O(n^2)$。</p><p>冒泡排序的平均时间复杂度为 $O(n^2)$。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><p>$$<br>\begin{array}{ll}<br>1 &amp; \textbf{Input. } \text{An array } A \text{ consisting of }n\text{ elements.} \<br>2 &amp; \textbf{Output. } A\text{ will be sorted in nondecreasing order stably.} \<br>3 &amp; \textbf{Method. }  \<br>4 &amp; flag\gets True\<br>5 &amp; \textbf{while }flag\<br>6 &amp; \qquad flag\gets False\<br>7 &amp; \qquad\textbf{for }i\gets1\textbf{ to }n-1\<br>8 &amp; \qquad\qquad\textbf{if }A[i]&gt;A[i + 1]\<br>9 &amp; \qquad\qquad\qquad flag\gets True\<br>10 &amp; \qquad\qquad\qquad \text{Swap } A[i]\text{ and }A[i + 1]<br>\end{array}<br>$$</p><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="comment">// 假设数组的大小是n+1，冒泡排序从数组下标1开始</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[i] &gt; a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> t = a[i];</span><br><span class="line">        a[i] = a[i + <span class="number">1</span>];</span><br><span class="line">        a[i + <span class="number">1</span>] = t;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python Version</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">a, n</span>):</span><br><span class="line">    flag = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">while</span> flag:</span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> a[i] &gt; a[i + <span class="number">1</span>]:</span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">                a[i], a[i + <span class="number">1</span>] = a[i + <span class="number">1</span>], a[i]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/08/23/binary-lifting/"/>
      <url>/2022/08/23/binary-lifting/</url>
      
        <content type="html"><![CDATA[<p>author: Ir1d, ShadowsEpic, Fomalhauthmj, siger-young, MingqiHuang, Xeonacid, hsfzLZH1, orzAtalod, NachtgeistW</p><p>本页面将简要介绍倍增法。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>倍增法（英语：binary lifting），顾名思义就是翻倍。它能够使线性的处理转化为对数级的处理，大大地优化时间复杂度。</p><p>这个方法在很多算法中均有应用，其中最常用的是 RMQ 问题和求 <a href="../graph/lca.md">LCA（最近公共祖先）</a>。</p><h2 id="RMQ-问题"><a href="#RMQ-问题" class="headerlink" title="RMQ 问题"></a>RMQ 问题</h2><p>参见：<a href="../topic/rmq.md">RMQ 专题</a></p><p>RMQ 是 Range Maximum&#x2F;Minimum Query 的缩写，表示区间最大（最小）值。使用倍增思想解决 RMQ 问题的方法是 <a href="../ds/sparse-table.md">ST 表</a>。</p><h2 id="树上倍增求-LCA"><a href="#树上倍增求-LCA" class="headerlink" title="树上倍增求 LCA"></a>树上倍增求 LCA</h2><p>参见：<a href="../graph/lca.md">最近公共祖先</a></p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="题-1"><a href="#题-1" class="headerlink" title="题 1"></a>题 1</h3><p>???+note “例题”<br>    如何用尽可能少的砝码称量出 $[0,31]$ 之间的所有重量？（只能在天平的一端放砝码）</p><p>??? note “解题思路”<br>    答案是使用 1 2 4 8 16 这五个砝码，可以称量出 $[0,31]$ 之间的所有重量。同样，如果要称量 $[0,127]$ 之间的所有重量，可以使用 1 2 4 8 16 32 64 这七个砝码。每次我们都选择 2 的整次幂作砝码的重量，就可以使用极少的砝码个数量出任意我们所需要的重量。</p><pre><code>为什么说是极少呢？因为如果我们要量出 $[0,1023]$ 之间的所有重量，只需要 10 个砝码，需要量出 $[0,1048575]$ 之间的所有重量，只需要 20 个。如果我们的目标重量翻倍，砝码个数只需要增加 1。这叫“对数级”的增长速度，因为砝码的所需个数与目标重量的范围的对数成正比。</code></pre><h3 id="题-2"><a href="#题-2" class="headerlink" title="题 2"></a>题 2</h3><p>???+note “例题”<br>    给出一个长度为 $n$ 的环和一个常数 $k$，每次会从第 $i$ 个点跳到第 $(i+k)\bmod n+1$ 个点，总共跳了 $m$ 次。每个点都有一个权值，记为 $a_i$，求 $m$ 次跳跃的起点的权值之和对 $10^9+7$ 取模的结果。</p><pre><code>数据范围：$1\leq n\leq 10^6$，$1\leq m\leq 10^&#123;18&#125;$，$1\leq k\leq n$，$0\le a_i\le 10^9$。</code></pre><p>??? note “解题思路”<br>    这里显然不能暴力模拟跳 $m$ 次。因为 $m$ 最大可到 $10^{18}$ 级别，如果暴力模拟的话，时间承受不住。</p><pre><code>所以就需要进行一些预处理，提前整合一些信息，以便于在查询的时候更快得出结果。如果记录下来每一个可能的跳跃次数的结果的话，不论是时间还是空间都难以承受。那么应该如何预处理呢？看看第一道例题。有思路了吗？回到本题。我们要预处理一些信息，然后用预处理的信息尽量快的整合出答案。同时预处理的信息也不能太多。所以可以预处理出以 2 的整次幂为单位的信息，这样的话在预处理的时候只需要处理少量信息，在整合的时候也不需要大费周章。在这题上，就是我们预处理出从每个点开始跳 1、2、4、8 等等步之后的结果（所处点和点权和），然后如果要跳 13 步，只需要跳 1+4+8 步就好了。也就是说先在起始点跳 1 步，然后再在跳了之后的终点跳 4 步，再接着跳 8 步，同时统计一下预先处理好的点权和，就可以知道跳 13 步的点权和了。对于每一个点开始的 $2^i$ 步，记录一个 `go[i][x]` 表示第 $x$ 个点跳 $2^i$ 步之后的终点，而 `sum[i][x]` 表示第 $x$ 个点跳 $2^i$ 步之后能获得的点权和。预处理的时候，开两重循环，对于跳 $2^i$ 步的信息，我们可以看作是先跳了 $2^&#123;i-1&#125;$ 步，再跳 $2^&#123;i-1&#125;$ 步，因为显然有 $2^&#123;i-1&#125;+2^&#123;i-1&#125;=2^i$。即我们有 `sum[i][x] = sum[i-1][x]+sum[i-1][go[i-1][x]]`，且 `go[i][x] = go[i-1][go[i-1][x]]`。当然还有一些实现细节需要注意。为了保证统计的时候不重不漏，我们一般预处理出“左闭右开”的点权和。亦即，对于跳 1 步的情况，我们只记录该点的点权和；对于跳 2 步的情况，我们只记录该点及其下一个点的点权和。相当于总是不将终点的点权和计入 sum。这样在预处理的时候，只需要将两部分的点权和直接相加就可以了，不需要担心第一段的终点和第二段的起点会被重复计算。这题的 $m\leq 10^&#123;18&#125;$，虽然看似恐怖，但是实际上只需要预处理出 $65$ 以内的 $i$，就可以轻松解决，比起暴力枚举快了很多。用行话讲，这个做法的 [时间复杂度](./complexity.md) 是预处理 $\Theta(n\log m)$，查询每次 $\Theta(\log m)$。</code></pre><p>??? note “参考代码”<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">modadd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a + b &gt;= mod) <span class="keyword">return</span> a + b - mod;  <span class="comment">// 减法代替取模，加快运算</span></span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> vi[<span class="number">1000005</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> go[<span class="number">75</span>][<span class="number">1000005</span>];  <span class="comment">// 将数组稍微开大以避免越界，小的一维尽量定义在前面</span></span><br><span class="line"><span class="type">int</span> sum[<span class="number">75</span>][<span class="number">1000005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, k;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, vi + i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    go[<span class="number">0</span>][i] = (i + k) % n + <span class="number">1</span>;</span><br><span class="line">    sum[<span class="number">0</span>][i] = vi[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> logn = <span class="number">31</span> - __builtin_clz(n);  <span class="comment">// 一个快捷的取对数的方法</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= logn; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">      go[i][j] = go[i - <span class="number">1</span>][go[i - <span class="number">1</span>][j]];</span><br><span class="line">      sum[i][j] = <span class="built_in">modadd</span>(sum[i - <span class="number">1</span>][j], sum[i - <span class="number">1</span>][go[i - <span class="number">1</span>][j]]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> m;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;m);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> curx = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; m; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (m &amp; (<span class="number">1</span> &lt;&lt; i)) &#123;  <span class="comment">// 参见位运算的相关内容，意为 m 的第 i 位是否为 1</span></span><br><span class="line">      ans = <span class="built_in">modadd</span>(ans, sum[i][curx]);</span><br><span class="line">      curx = go[i][curx];</span><br><span class="line">      m ^= <span class="number">1ll</span> &lt;&lt; i;  <span class="comment">// 将第 i 位置零</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/08/23/binary/"/>
      <url>/2022/08/23/binary/</url>
      
        <content type="html"><![CDATA[<p>本页面将简要介绍二分查找，由二分法衍生的三分法以及二分答案。</p><h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>二分查找（英语：binary search），也称折半搜索（英语：half-interval search）、对数搜索（英语：logarithmic search），是用来在一个有序数组中查找某一元素的算法。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>以在一个升序数组中查找一个数为例。</p><p>它每次考察数组当前部分的中间元素，如果中间元素刚好是要找的，就结束搜索过程；如果中间元素小于所查找的值，那么左侧的只会更小，不会有所查找的元素，只需到右侧查找；如果中间元素大于所查找的值同理，只需到左侧查找。</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>二分查找的最优时间复杂度为 $O(1)$。</p><p>二分查找的平均时间复杂度和最坏时间复杂度均为 $O(\log n)$。因为在二分搜索过程中，算法每次都把查询的区间减半，所以对于一个长度为 $n$ 的数组，至多会进行 $O(\log n)$ 次查找。</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>迭代版本的二分查找的空间复杂度为 $O(1)$。</p><p>递归（无尾调用消除）版本的二分查找的空间复杂度为 $O(\log n)$。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binary_search</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> ret = <span class="number">-1</span>;  <span class="comment">// 未搜索到数据返回-1下标</span></span><br><span class="line">  <span class="type">int</span> mid;</span><br><span class="line">  <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">    mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);  <span class="comment">// 直接平均可能会溢出，所以用这个算法</span></span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &lt; key)</span><br><span class="line">      start = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; key)</span><br><span class="line">      end = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">// 最后检测相等是因为多数搜索情况不是大于就是小于</span></span><br><span class="line">      ret = mid;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;  <span class="comment">// 单一出口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>???+note<br>    对于 $n$ 是有符号数的情况，当你可以保证 $n\ge 0$ 时，<code>n &gt;&gt; 1</code> 比 <code>n / 2</code> 指令数更少。</p><h3 id="最大值最小化"><a href="#最大值最小化" class="headerlink" title="最大值最小化"></a>最大值最小化</h3><p>注意，这里的有序是广义的有序，如果一个数组中的左侧或者右侧都满足某一种条件，而另一侧都不满足这种条件，也可以看作是一种有序（如果把满足条件看做 $1$，不满足看做 $0$，至少对于这个条件的这一维度是有序的）。换言之，二分搜索法可以用来查找满足某种条件的最大（最小）的值。</p><p>要求满足某种条件的最大值的最小可能情况（最大值最小化），首先的想法是从小到大枚举这个作为答案的「最大值」，然后去判断是否合法。若答案单调，就可以使用二分搜索法来更快地找到答案。因此，要想使用二分搜索法来解这种「最大值最小化」的题目，需要满足以下三个条件：</p><ol><li>答案在一个固定区间内；</li><li>可能查找一个符合条件的值不是很容易，但是要求能比较容易地判断某个值是否是符合条件的；</li><li>可行解对于区间满足一定的单调性。换言之，如果 $x$ 是符合条件的，那么有 $x + 1$ 或者 $x - 1$ 也符合条件。（这样下来就满足了上面提到的单调性）</li></ol><p>当然，最小值最大化是同理的。</p><h3 id="STL-的二分查找"><a href="#STL-的二分查找" class="headerlink" title="STL 的二分查找"></a>STL 的二分查找</h3><p>C++ 标准库中实现了查找首个不小于给定值的元素的函数 <a href="https://zh.cppreference.com/w/cpp/algorithm/lower_bound"><code>std::lower_bound</code></a> 和查找首个大于给定值的元素的函数 <a href="https://zh.cppreference.com/w/cpp/algorithm/upper_bound"><code>std::upper_bound</code></a>，二者均定义于头文件 <code>&lt;algorithm&gt;</code> 中。</p><p>二者均采用二分实现，所以调用前必须保证元素有序。</p><h3 id="bsearch"><a href="#bsearch" class="headerlink" title="bsearch"></a>bsearch</h3><p>bsearch 函数为 C 标准库实现的二分查找，定义在 <code>&lt;stdlib.h&gt;</code> 中。在 C++ 标准库里，该函数定义在 <code>&lt;cstdlib&gt;</code> 中。qsort 和 bsearch 是 C 语言中唯二的两个算法类函数。</p><p>bsearch 函数相比 qsort（<a href="./stl-sort.md">排序相关 STL</a>）的四个参数，在最左边增加了参数“待查元素的地址”。之所以按照地址的形式传入，是为了方便直接套用与 qsort 相同的比较函数，从而实现排序后的立即查找。因此这个参数不能直接传入具体值，而是要先将待查值用一个变量存储，再传入该变量地址。</p><p>于是 bsearch 函数总共有五个参数：待查元素的地址、数组名、元素个数、元素大小、比较规则。比较规则仍然通过指定比较函数实现，详见 <a href="./stl-sort.md">排序相关 STL</a>。</p><p>bsearch 函数的返回值是查找到的元素的地址，该地址为 void 类型。</p><p>注意：bsearch 与上文的 lower_bound 和 upper_bound 有两点不同：</p><ul><li>当符合条件的元素有重复多个的时候，会返回执行二分查找时第一个符合条件的元素，从而这个元素可能位于重复多个元素的中间部分。</li><li>当查找不到相应的元素时，会返回 NULL。</li></ul><p>用 lower_bound 可以实现与 bsearch 完全相同的功能，所以可以使用 bsearch 通过的题目，直接改写成 lower_bound 同样可以实现。但是鉴于上述不同之处的第二点，例如，在序列 1、2、4、5、6 中查找 3，bsearch 实现 lower_bound 的功能会变得困难。</p><p>利用 bsearch 实现 lower_bound 的功能比较困难，是否一定就不能实现？答案是否定的，存在比较 tricky 的技巧。借助编译器处理比较函数的特性：总是将第一个参数指向待查元素，将第二个参数指向待查数组中的元素，也可以用 bsearch 实现 lower_bound 和 upper_bound，如下文示例。只是，这要求待查数组必须是全局数组，从而可以直接传入首地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> A[<span class="number">100005</span>];  <span class="comment">// 示例全局数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找首个不小于待查元素的元素的地址</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lower</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *p1, <span class="type">const</span> <span class="type">void</span> *p2)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> *a = (<span class="type">int</span> *)p1;</span><br><span class="line">  <span class="type">int</span> *b = (<span class="type">int</span> *)p2;</span><br><span class="line">  <span class="keyword">if</span> ((b == A || <span class="built_in">compare</span>(a, b - <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; <span class="built_in">compare</span>(a, b) &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (b != A &amp;&amp; <span class="built_in">compare</span>(a, b - <span class="number">1</span>) &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 用到地址的减法，因此必须指定元素类型</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找首个大于待查元素的元素的地址</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">upper</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *p1, <span class="type">const</span> <span class="type">void</span> *p2)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> *a = (<span class="type">int</span> *)p1;</span><br><span class="line">  <span class="type">int</span> *b = (<span class="type">int</span> *)p2;</span><br><span class="line">  <span class="keyword">if</span> ((b == A || <span class="built_in">compare</span>(a, b - <span class="number">1</span>) &gt;= <span class="number">0</span>) &amp;&amp; <span class="built_in">compare</span>(a, b) &gt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (b != A &amp;&amp; <span class="built_in">compare</span>(a, b - <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 用到地址的减法，因此必须指定元素类型</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为现在的 OI 选手很少写纯 C，并且此方法作用有限，所以不是重点。对于新手而言，建议老老实实地使用 C++ 中的 lower_bound 和 upper_bound 函数。</p><h3 id="二分答案"><a href="#二分答案" class="headerlink" title="二分答案"></a>二分答案</h3><p>解题的时候往往会考虑枚举答案然后检验枚举的值是否正确。若满足单调性，则满足使用二分法的条件。把这里的枚举换成二分，就变成了“二分答案”。</p><p>???+note “<a href="https://www.luogu.com.cn/problem/P1873">Luogu P1873 砍树</a>“<br>    伐木工人米尔科需要砍倒 $M$ 米长的木材。这是一个对米尔科来说很容易的工作，因为他有一个漂亮的新伐木机，可以像野火一样砍倒森林。不过，米尔科只被允许砍倒单行树木。</p><pre><code>米尔科的伐木机工作过程如下：米尔科设置一个高度参数 $H$（米），伐木机升起一个巨大的锯片到高度 $H$，并锯掉所有的树比 $H$ 高的部分（当然，树木不高于 $H$ 米的部分保持不变）。米尔科就得到树木被锯下的部分。例如，如果一行树的高度分别为 $20,~15,~10,~17$，米尔科把锯片升到 $15$ 米的高度，切割后树木剩下的高度将是 $15,~15,~10,~15$，而米尔科将从第 $1$ 棵树得到 $5$ 米木材，从第 $4$ 棵树得到 $2$ 米木材，共 $7$ 米木材。米尔科非常关注生态保护，所以他不会砍掉过多的木材。这正是他尽可能高地设定伐木机锯片的原因。你的任务是帮助米尔科找到伐木机锯片的最大的整数高度 $H$，使得他能得到木材至少为 $M$ 米。即，如果再升高 $1$ 米锯片，则他将得不到 $M$ 米木材。</code></pre><p>??? note “解题思路”<br>    我们可以在 $1$ 到 $10^9$ 中枚举答案，但是这种朴素写法肯定拿不到满分，因为从 $1$ 枚举到 $10^9$ 太耗时间。我们可以在 $[1,~10^9]$ 的区间上进行二分作为答案，然后检查各个答案的可行性（一般使用贪心法）。<strong>这就是二分答案。</strong></p><p>??? note “参考代码”<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">1000005</span>];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;  <span class="comment">// 检查可行性，k 为锯片高度</span></span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)       <span class="comment">// 检查每一棵树</span></span><br><span class="line">    <span class="keyword">if</span> (a[i] &gt; k)                    <span class="comment">// 如果树高于锯片高度</span></span><br><span class="line">      sum += (<span class="type">long</span> <span class="type">long</span>)(a[i] - k);  <span class="comment">// 累加树木长度</span></span><br><span class="line">  <span class="keyword">return</span> sum &gt;= m;                   <span class="comment">// 如果满足最少长度代表可行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">1e9</span> + <span class="number">1</span>;   <span class="comment">// 因为是左闭右开的，所以 10^9 要加 1</span></span><br><span class="line">  <span class="keyword">while</span> (l + <span class="number">1</span> &lt; r) &#123;       <span class="comment">// 如果两点不相邻</span></span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;  <span class="comment">// 取中间值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(mid))         <span class="comment">// 如果可行</span></span><br><span class="line">      l = mid;              <span class="comment">// 升高锯片高度</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      r = mid;  <span class="comment">// 否则降低锯片高度</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> l;  <span class="comment">// 返回左边值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class="line">  cout &lt;&lt; <span class="built_in">find</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><pre><code>看完了上面的代码，你肯定会有两个疑问：1.  为何搜索区间是左闭右开的？    因为搜到最后，会这样（以合法的最大值为例）：    ![](./images/binary-final-1.png)    然后会    ![](./images/binary-final-2.png)    合法的最小值恰恰相反。2.  为何返回左边值？    同上。</code></pre><h2 id="三分法"><a href="#三分法" class="headerlink" title="三分法"></a>三分法</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>三分法可以用来查找凸函数的最大（小）值。</p><p>画一下图能够帮助理解（图待补）</p><ul><li>如果 <code>lmid</code> 和 <code>rmid</code> 在最大（小）值的同一侧：由于单调性，一定是二者中较大（小）的那个离最值近一些，较远的那个点对应的区间不可能包含最值，所以可以舍弃。</li><li>如果在两侧：由于最值在二者中间，我们舍弃两侧的一个区间后，也不会影响最值，所以可以舍弃。</li></ul><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lmid = left + (right - left &gt;&gt; <span class="number">1</span>);</span><br><span class="line">rmid = lmid + (right - lmid &gt;&gt; <span class="number">1</span>);  <span class="comment">// 对右侧区间取半</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">cal</span>(lmid) &gt; <span class="built_in">cal</span>(rmid))</span><br><span class="line">  right = rmid;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  left = lmid;</span><br></pre></td></tr></table></figure><h2 id="分数规划"><a href="#分数规划" class="headerlink" title="分数规划"></a>分数规划</h2><p>参见：<a href="../misc/frac-programming.md">分数规划</a></p><p>分数规划通常描述为下列问题：每个物品有两个属性 $c_i$，$d_i$，要求通过某种方式选出若干个，使得 $\frac{\sum{c_i}}{\sum{d_i}}$ 最大或最小。</p><p>经典的例子有最优比率环、最优比率生成树等等。</p><p>分数规划可以用二分法来解决。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【教程】Windows下安装WSL 2</title>
      <link href="/2022/08/19/%E3%80%90%E6%95%99%E7%A8%8B%E3%80%91Windows%E4%B8%8B%E5%AE%89%E8%A3%85WSL%202/"/>
      <url>/2022/08/19/%E3%80%90%E6%95%99%E7%A8%8B%E3%80%91Windows%E4%B8%8B%E5%AE%89%E8%A3%85WSL%202/</url>
      
        <content type="html"><![CDATA[<h2 id="系统版本要求"><a href="#系统版本要求" class="headerlink" title="系统版本要求"></a>系统版本要求</h2><p>必须运行 Windows 10 版本 2004 及更高版本（内部版本 19041 及更高版本）或 Windows 11</p><blockquote><p>按住<strong>Windows徽标键+R</strong>，键入<strong>winver</strong>来查看电脑版本</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>通过在<strong>管理员模式下</strong>PowerShell 或 Windows 命令提示符中输入以下命令，然后重新启动计算机来安装运行WSL</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">--install</span></span><br></pre></td></tr></table></figure><p>此命令将启用所需的可选组件，下载最新的Linux内核，<strong>将WSL 2设置为默认值</strong>，并为您安装Linux发行版（默认情况下为<strong>Ubuntu</strong>）。</p><p>首次启动新安装的 Linux 发行版时，将打开一个控制台窗口，系统将要求您等待文件解压缩并存储在您的计算机上。</p><h2 id="更改发行版"><a href="#更改发行版" class="headerlink" title="更改发行版"></a>更改发行版</h2><p>通过在<strong>管理员模式下</strong>PowerShell 或 Windows 命令提示符中输入以下命令查看可安装的有效分发</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">-l</span> <span class="literal">-o</span></span><br><span class="line">wsl <span class="literal">--list</span> <span class="literal">--online</span></span><br></pre></td></tr></table></figure><p>通过在<strong>管理员模式下</strong>PowerShell 或 Windows 命令提示符中输入以下命令安装新分发</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">--install</span> <span class="literal">-d</span> &lt;Distribution Name&gt;</span><br></pre></td></tr></table></figure><p>通过在<strong>管理员模式下</strong>PowerShell 或 Windows 命令提示符中输入以下命令用新分发替换旧分发</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">--install</span> <span class="literal">-d</span> &lt;Distribution Name&gt; &lt;Distribution Name&gt;</span><br></pre></td></tr></table></figure><h2 id="查看已安装发行版"><a href="#查看已安装发行版" class="headerlink" title="查看已安装发行版"></a>查看已安装发行版</h2><p>通过在<strong>管理员模式下</strong>PowerShell 或 Windows 命令提示符中输入以下命令查看已安装分发的状态和版本</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">-l</span> <span class="literal">-v</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【笔记】算法设计与分析笔记</title>
      <link href="/2022/08/19/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/08/19/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="一、算法基础"><a href="#一、算法基础" class="headerlink" title="一、算法基础"></a>一、算法基础</h2><h3 id="1-循环不变量的证明"><a href="#1-循环不变量的证明" class="headerlink" title="1.循环不变量的证明"></a>1.循环不变量的证明</h3><ul><li>初始化：证明循环不变量在循环开始前为真；</li><li>保持：证明每次循环之后循环不变式仍为真；</li><li>终止：循环可以有限次终止。</li></ul><h3 id="2-时间复杂度的分析"><a href="#2-时间复杂度的分析" class="headerlink" title="2.时间复杂度的分析"></a>2.时间复杂度的分析</h3><ul><li><p>整个算法的执行时间是执行所有语句的时间之和；</p></li><li><p>算法的执行时间可能依赖于给定的输入，即使规模相同；</p></li><li><p>分析执行时间时可以分析算法的最坏执行情况、最好执行情况、平均执行情况。</p></li></ul><h3 id="3-算法的五个特性"><a href="#3-算法的五个特性" class="headerlink" title="3.算法的五个特性"></a>3.算法的五个特性</h3><ul><li><p>确定性</p></li><li><p>能行性</p></li><li><p>输入</p></li><li><p>输出</p></li><li><p>有穷性</p><div class="note info flat"><p>仅仅不满足有穷性规则的算法称为计算过程，如操作系统</p></div></li></ul><h2 id="二、算法渐近"><a href="#二、算法渐近" class="headerlink" title="二、算法渐近"></a>二、算法渐近</h2><h3 id="1-限界函数"><a href="#1-限界函数" class="headerlink" title="1.限界函数"></a>1.限界函数</h3><h4 id="1-上界函数"><a href="#1-上界函数" class="headerlink" title="(1)上界函数"></a>(1)上界函数</h4><p>上界函数描述了<strong>算法最坏情况下的时间复杂度</strong>，记为$f(n)\inΟ(g(n))$或$f(n)&#x3D;Ο(g(n))$</p><img src="Chp2-上界函数.png" style="zoom: 45%;" /><h4 id="2-下界函数"><a href="#2-下界函数" class="headerlink" title="(2)下界函数"></a>(2)下界函数</h4><p>下界函数描述了<strong>渐进下界</strong>，记为$f(n)\in\Omega(g(n))$或$f(n)&#x3D;\Omega(g(n))$</p><img src="Chp2-下界函数.png" style="zoom: 50%;" /><h4 id="3-渐近紧确界函数"><a href="#3-渐近紧确界函数" class="headerlink" title="(3)渐近紧确界函数"></a>(3)渐近紧确界函数</h4><p>渐近紧确界函数代表<strong>算法在最好和最坏情况下的计算时间就一个常数因子范围内而相同</strong>，<strong>既有$ f(n) &#x3D; \Omega(g(n))$，又有$f(n) &#x3D; Ο(g(n))$</strong></p><img src="Chp2-渐近紧确界.png" style="zoom: 58%;" /><h4 id="4-记号说明"><a href="#4-记号说明" class="headerlink" title="(4)记号说明"></a>(4)记号说明</h4><ul><li>这里的”$&#x3D;$”不是通常相等的含义，<strong>代表属于</strong></li><li>$\Theta(1)$表示具有<strong>常量计算时间</strong>的复杂度，即算法的执行时间为一个固定量，与问题的规模$n$无关</li></ul><h4 id="5-非渐近紧确的上下界"><a href="#5-非渐近紧确的上下界" class="headerlink" title="(5)非渐近紧确的上下界"></a>(5)非渐近紧确的上下界</h4><ul><li><strong>$o$记号</strong></li></ul><p>对任意正常数$c$，存在常数$n_0＞0$，使对所有的$n\geq n_0$，有$\lvert f(n)\rvert\leq c\lvert g(n)\rvert$，则记作：$f(n)&#x3D;o(g(n))$</p><ul><li><strong>$\omega$记号</strong></li></ul><p>对任意正常数$c$，存在常数$n_0＞0$，使对所有的$n\geq n_0$，有$\lvert f(n)\rvert\geq c\lvert g(n)\rvert$，则记作：$f(n)&#x3D;\omega(g(n))$</p><h3 id="2-估算复杂性定理"><a href="#2-估算复杂性定理" class="headerlink" title="2.估算复杂性定理"></a>2.估算复杂性定理</h3><ul><li>多项式定理：关于$n$的$m$次多项式与最高阶$n^m$同阶</li><li>$n^x(\log n)^y&lt;n^{x+\varepsilon}$</li><li>$(\log n)^x&lt;n$</li><li>$n^x&lt;2^n$</li></ul><h3 id="3-上界函数定理"><a href="#3-上界函数定理" class="headerlink" title="3.上界函数定理"></a>3.上界函数定理</h3><ul><li>正线性性：$d(n)&#x3D;O(f(n))$，则$ad(n)&#x3D;O(f(n))$，其中$a&gt;0$</li><li>加法律：$d(n)&#x3D;O(f(n))$，$e(n)&#x3D;O(g(n))$，则$d(n)+e(n)&#x3D;O(f(n)+g(n))$</li><li>乘法律：$d(n)&#x3D;O(f(n))$，$e(n)&#x3D;O(g(n))$，则$d(n)e(n)&#x3D;O(f(n)g(n))$</li><li>指数性质：$n^x&#x3D;O(a^n)$，其中$x&gt;0$，$a&gt;1$</li><li>对数性质1：$\log n^x&#x3D;O(\log n)$，其中$x&gt;0$</li><li>对数性质2：$(\log n)^x&#x3D;O(n^y)$，其中$x&gt;0$，$y&gt;0$</li></ul><h2 id="三、分治思想"><a href="#三、分治思想" class="headerlink" title="三、分治思想"></a>三、分治思想</h2><h3 id="1-分治原理"><a href="#1-分治原理" class="headerlink" title="1.分治原理"></a>1.分治原理</h3><p><strong>分治原理的基本思想：当问题规模比较大而无法直接求解时，将原始问题分解为几个规模较小、但类似于原始问题的子问题，然后递归地求解这些子问题，最后合并子问题的解以得到原始问题的解。</strong></p><ul><li><strong>基本策略：分解原问题，解决子问题，合并问题解</strong>。</li><li><strong>问题形式：跨越子数组的问题类型、合并子问题解的问题类型。</strong></li><li>计算复杂度：<a href="#2.%E9%80%92%E5%BD%92%E5%BC%8F%E6%B1%82%E8%A7%A3">递归式求解</a></li><li>实例：<a href="#3.%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">归并排序</a>——$T(n)&#x3D;2T(n&#x2F;2)+cn$</li><li>实例：<a href="#4.%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98">最大子数组问题</a>——$T(n)&#x3D;2T(n&#x2F;2)+\Theta(n)$</li><li>实例：<a href="#6.%E6%9C%80%E8%BF%91%E7%82%B9%E5%AF%B9%E9%97%AE%E9%A2%98">最近点对问题</a>——$T(n)&#x3D;2T(n&#x2F;2)+O(n)$</li><li>实例：<a href="#7.%E9%80%86%E5%BA%8F%E5%AF%B9%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98">逆序对计数问题</a>——$T(n)&#x3D;2T(n&#x2F;2)+O(n)$</li><li>实例：<a href="#8.%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">随机化快速排序的期望</a>——$T(n)&#x3D;O(n\log n)$</li></ul><h3 id="2-递归式求解"><a href="#2-递归式求解" class="headerlink" title="2.递归式求解"></a>2.递归式求解</h3><h4 id="1-基本形式"><a href="#1-基本形式" class="headerlink" title="(1)基本形式"></a>(1)基本形式</h4><ul><li><p>求解递归式的目的是<strong>将递归式转换为渐近限界函数表示‌</strong>；</p></li><li><p>一般关系为$T(n) &#x3D;T(n_1)+T(n_2)+f(n)$，其中$f(n)$表示<strong>除递归以外的代价</strong>。</p></li></ul><h4 id="2-预处理"><a href="#2-预处理" class="headerlink" title="(2)预处理"></a>(2)预处理</h4><ul><li><p><strong>减去一个低阶项</strong>以便于代换法中的归纳证明，如$cn-d$</p><blockquote><p>减去低阶项往往能够使数学证明顺利进行：</p><img src="Chp3-减去低阶项.png" style="zoom:67%;" /></blockquote></li><li><p>对<strong>取整符号</strong>进行简化</p><blockquote><p>如$T(n)&#x3D;T(\lfloor n&#x2F;2\rfloor)+T(\lceil n&#x2F;2\rceil)+f(n)$，往往忽略上下取整函数，写作以下简单形式：$T(n)&#x3D;2T(n&#x2F;2)+f(n)$</p></blockquote></li><li><p>对<strong>对数或指数</strong>做代数转换</p><blockquote><p>改变变量来简化递归式：</p><img src="Chp3-对指数变量代换.png" style="zoom:67%;" /></blockquote></li><li><p>对<strong>限界函数项</strong>进行展开，便于化简</p><blockquote><p>对于$T(n)&#x3D;3T(\lfloor n&#x2F;4\rfloor)+\Theta(n^2)$，简化为$T(n)&#x3D;3T(n&#x2F;4)+cn^2$。</p></blockquote></li></ul><h4 id="3-求解方法"><a href="#3-求解方法" class="headerlink" title="(3)求解方法"></a>(3)求解方法</h4><h5 id="①代入法"><a href="#①代入法" class="headerlink" title="①代入法"></a>①代入法</h5><ul><li><p>利用熟悉或类似的递归式<strong>猜测解的形式</strong></p></li><li><p>用<strong>数学归纳法</strong>证明猜测的正确性，得出合适的$c$值以满足条件</p></li><li><p>讨论<strong>边界条件的正确性</strong></p><blockquote><p>代入法实例如下：</p><img src="Chp3-代入法实例.png" style="zoom:60%;" /></blockquote></li></ul><h5 id="②递归树"><a href="#②递归树" class="headerlink" title="②递归树"></a>②递归树</h5><ul><li><p>在内部节点中表达除递归以外的代价</p><blockquote><p>对于$T(n)&#x3D;aT(n&#x2F;b)+f(n)$，一般假设$n&#x3D;b^k$，$k&#x3D;\log_bn$简化计算</p></blockquote></li><li><p>列出递归树直至叶子节点，得到递归树高度</p><blockquote><p>递归至叶子节点后，递归树的层数一般为$\log_bn+1$</p><p>举例如下：</p><img src="Chp3-递归树-1.png" style="zoom:67%;" /></blockquote></li><li><p>计算内部某层节点的总代价、叶子节点总代价、树的总代价</p><blockquote><p>通过计算前几层节点的总代价，得到内部某层节点的总代价的<strong>通式</strong>；</p><p>计算叶子节点的数目，假设为$num$，则叶子节点的总代价为$\Theta(num)$；</p><p>根据等比数列求和公式得到总代价。</p><p>计算如下：</p><img src="Chp3-递归树-2.png" style="zoom:67%;" /></blockquote></li><li><p>根据树的总代价猜测渐近限界函数</p><blockquote><p>猜测如下：</p><img src="Chp3-递归树-3.png" style="zoom:67%;" /></blockquote></li><li><p><strong>利用代换法证明</strong>猜测</p><blockquote><p>证明如下：</p><img src="Chp3-递归树-4.png" style="zoom:67%;" /></blockquote></li></ul><h5 id="③主方法"><a href="#③主方法" class="headerlink" title="③主方法"></a>③主方法</h5><p>设$a≥1$，$b&gt;1$，设$f(n)$为渐近正的函数，$T(n)$是定义在非负整数上的递归式：$T(n)&#x3D;aT(n&#x2F;b)+f(n)$，其中$n&#x2F;b$指$\lfloor n&#x2F;b \rfloor$或$\lceil n&#x2F;b \rceil$，则可使用以下定理求解递归式：</p><ul><li><p>若对于某常数$\varepsilon&gt;0$，有$f(n)&#x3D;O(n^{\log_ba-\varepsilon})$，则$T(n)&#x3D;\Theta(n^{\log_ba})$</p><blockquote><p>该情况中$n^{\log_ba}$比较大，$f(n)$需<strong>多项式地小于</strong>$n^{\log_ba}$，即对某个常量$\varepsilon&gt;0$，$f(n)$必须渐近地小于$n^{\log_ba}$，两者相差了一个$n^\varepsilon$因子，如$T(n)&#x3D;2T(n&#x2F;2)+n\log n$和$T(n)&#x3D;4T(n&#x2F;2)+n^2\log n$不满足条件</p></blockquote></li><li><p>若$f(n)&#x3D;\Theta(n^{\log_ba})$，则$T(n)&#x3D;\Theta(n^{\log_ba}\log n)$</p><blockquote><p>该情况中两个函数一样大，乘以对数因子$\log n$</p></blockquote></li><li><p>若对于某常数$\varepsilon&gt;0$，有$f(n)&#x3D;\Omega(n^{\log_ba+\varepsilon})$，且对常数**$c&lt;1$**与足够大的$n$，有$af(n&#x2F;b)\leq cf(n)$，则$T(n)&#x3D;\Theta(f(n))$</p><blockquote><p>该情况中$f(n)$比较大，$f(n)$需<strong>多项式地大于</strong>$n^{\log_ba}$，并需要满足一个规则性条件$af(n&#x2F;b)\leq cf(n)$，注意其中$c&lt; 1$</p></blockquote></li></ul><h3 id="3-归并排序"><a href="#3-归并排序" class="headerlink" title="3.归并排序"></a>3.归并排序</h3><h4 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="(1)问题描述"></a>(1)问题描述</h4><p>已知包含$n$个数字的序列$A[1,\dots,n]$，对其进行升序排序。</p><h4 id="2-问题分析"><a href="#2-问题分析" class="headerlink" title="(2)问题分析"></a>(2)问题分析</h4><ul><li>将数组$A$排序问题分解为$A[1,\dots,\lfloor\frac{n}{2}\rfloor]$和$A[\lfloor\frac{n}{2}\rfloor+1,\dots,n]$排序问题；</li><li>递归解决子问题得到两个有序的子数组；</li><li>然后再将两个子数组合并，合并的代价即为<strong>除递归以外的代价</strong>；</li><li>当数组被分解为长度为1时天然有序，从而产生局部有序性，进而进行两两合并操作。</li></ul><h4 id="3-分治策略"><a href="#3-分治策略" class="headerlink" title="(3)分治策略"></a>(3)分治策略</h4><ul><li><p>算法伪代码：</p><blockquote><p>$MERGE-SORT(A,left,right)$</p><img src="Chp3-MERGE-SORT.png" style="zoom:67%;" /><p>$MERGE(A,left,mid,right)$</p><img src="Chp3-MERGE.png" style="zoom:67%;" /></blockquote></li><li><p>时间复杂度</p><ul><li>递归式为$T(n)&#x3D;2T(n&#x2F;2)+O(n)$，其中$O(n)$为$MERGE$操作的时间代价；</li><li>时间复杂度为$O(n\log n)$。</li></ul></li></ul><h3 id="4-最大子数组问题"><a href="#4-最大子数组问题" class="headerlink" title="4.最大子数组问题"></a>4.最大子数组问题</h3><h4 id="1-问题描述-1"><a href="#1-问题描述-1" class="headerlink" title="(1)问题描述"></a>(1)问题描述</h4><ul><li>寻找和最大的非空连续子数组</li><li>给定一个数组$X[1..n]$，对于任意一对数组下标为$l,r(l\leq r)$的非空子数组，其和记为$S(l,r)&#x3D;\sum\limits_{i&#x3D;l}^{r}X[i]$，求$S(l,r)$的最大值，记为$S_{max}$。</li></ul><h4 id="2-暴力求解"><a href="#2-暴力求解" class="headerlink" title="(2)暴力求解"></a>(2)暴力求解</h4><ul><li>枚举$n+C_n^2$种下标$l,r$组合，求出最大子数组之和；</li><li>处理每对下标组合最少的时间代价为常量；</li><li>时间复杂度为$\Omega(n^2)$。</li></ul><h4 id="3-分治策略-1"><a href="#3-分治策略-1" class="headerlink" title="(3)分治策略"></a>(3)分治策略</h4><ul><li><p>将子数组$A[low…high]$划分为两个规模尽量相等的子子数组；</p></li><li><p>分别求解$A[low…mid]$和$A[mid+1…high]$的最大子数组；</p></li><li><p>基于上述划分，存在三种连续子数组情况：$mid$左侧、跨越$mid$、$mid$右侧；</p></li><li><p>对于跨越$mid$的情况，从$mid$出发，分别向左和向右找出最大子区间并合并，这个步骤的代价即为<strong>除递归以外的代价</strong>，其时间复杂度为$\Theta(n^2)$；</p><blockquote><p> 算法$FIND-MAX-CROSSING-SUBARRAY$如下：</p><img src="img\Chp3-FIND-MAX-CROSSING-SUBARRAY.png" style="zoom: 50%;" /></blockquote></li><li><p>对于其他两种情况，递归调用<strong>FIND-MAXIMUM-SUBARRAY</strong>即可；</p></li><li><p>求最大子数组问题的分治算法</p><blockquote><p><strong>FIND-MAXIMUM-SUBARRAY</strong>如下图：</p><img src="img\Chp3-FIND-MAXIMUM-SUBARRAY.png" style="zoom: 50%;" /></blockquote></li><li><p>时间复杂度</p><ul><li>当$n&#x3D;1$时，$T(n)&#x3D;\Theta(1)$；</li><li>当$n&gt;1$时，$T(n)&#x3D;2T(n&#x2F;2)+\Theta(n)$；</li><li>时间复杂度为$T(n)&#x3D;\Theta(n\lg n)$。</li></ul></li></ul><h4 id="※-4-非递归的线性算法"><a href="#※-4-非递归的线性算法" class="headerlink" title="※(4)非递归的线性算法"></a>※(4)非递归的线性算法</h4><h3 id="※5-Strassen-矩阵乘法"><a href="#※5-Strassen-矩阵乘法" class="headerlink" title="※5.$Strassen$矩阵乘法"></a>※5.$Strassen$矩阵乘法</h3><h3 id="6-最近点对问题"><a href="#6-最近点对问题" class="headerlink" title="6.最近点对问题"></a>6.最近点对问题</h3><h4 id="1-问题描述-2"><a href="#1-问题描述-2" class="headerlink" title="(1)问题描述"></a>(1)问题描述</h4><ul><li>已知平面上分布着点集$P$中的$n$个点$p_1,p_2,\dots,p_n$，点$i$的坐标记为$(x_i,y_i)$，$1\leq i\leq n$。</li><li>找出一对距离最近的点(允许两个点处于同一个位置)</li></ul><h4 id="2-暴力搜索"><a href="#2-暴力搜索" class="headerlink" title="(2)暴力搜索"></a>(2)暴力搜索</h4><ul><li>对每对点都计算距离，然后比较大小，找出其中的最小者</li><li>计算点之间的距离的时间复杂度为$O(n^2)$</li><li>比较得到最小距离的时间复杂度为$O(n^2)$</li></ul><h4 id="3-分治策略-2"><a href="#3-分治策略-2" class="headerlink" title="(3)分治策略"></a>(3)分治策略</h4><ul><li><p>排序：将所有点按照$x$坐标排序——$O(n\log n)$</p></li><li><p>划分：将点集分成左、右两半$P_L$和$P_R$</p><blockquote><p>定义$d_L$为$P_L$中最近点对距离，$d_R$为$P_R$中最近点对距离，$d_C$为跨越分割线的最近点对距离，这与最大子数组问题类似。</p></blockquote></li><li><p>改进：令$\delta&#x3D;min(d_L,d_R)$，则有$d_C&lt;\delta$，即$d_C$对应点对必然落在分割线两侧的$\delta$距离内，称之为$strip$，同时易得，$d_C$的两个点的$y$坐标相差也不会大于$\delta$，因此应该对点的$y$坐标也进行排序。</p></li><li><p>实现：假设搜索到$p_j$时，$p_j$与$p_i$的$y$坐标相差大于$\delta$，那么对于$p_i$而言更远的$p_j$就可以终止搜索，转而处理$p_i$后面的点$p_{i+1}$。</p><blockquote><p>改进后的算法伪代码：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for i=1 to numPointsInStrip do</span><br><span class="line">for j=i+1 to numPointsInStrip do</span><br><span class="line">if y-coordinates of p[i] and p[j] differ by more than δ</span><br><span class="line">break;</span><br><span class="line">else if dist(p[i],p[j])&lt;δ</span><br><span class="line">            δ=dist(p[i],p[j]);</span><br></pre></td></tr></table></figure></blockquote></li><li><p>时间复杂度</p><ul><li>在最坏的情况下，计算$d_C$的时间复杂度为$O(n)$，则最终递归式为$T(n)&#x3D;2T(n&#x2F;2)+O(n)$</li><li>※预排序</li><li>综上得到所有附加工作的总时间复杂度为$O(n)$，则$T(n)&#x3D;2T(n&#x2F;2)+cn&#x3D;O(n\log n)$</li></ul></li></ul><h3 id="7-逆序对计数问题"><a href="#7-逆序对计数问题" class="headerlink" title="7.逆序对计数问题"></a>7.逆序对计数问题</h3><h4 id="1-问题描述-3"><a href="#1-问题描述-3" class="headerlink" title="(1)问题描述"></a>(1)问题描述</h4><ul><li><p>在一个数组$A$中，称满足$i&lt;j$且$A[i]&gt;A[j]$的二元组$(A[i],A[j])$为逆序对</p><blockquote><p>在数组$A&#x3D;{4,6,8,3,5}$中，$(A[1],A[4])$即为一个逆序对</p></blockquote></li><li><p>现已知长度为$n$的数组$A[1..n]$，求其<strong>逆序对的总数</strong>$\sum\limits_{1\leq i\leq j\leq n}X_{i,j}$，其中当$A[i]&gt;A[j]$时$X_{i,j}$为1，否则为0。</p></li></ul><h4 id="2-暴力枚举"><a href="#2-暴力枚举" class="headerlink" title="(2)暴力枚举"></a>(2)暴力枚举</h4><ul><li>对于每个元素$A[i]$，枚举$j(j&gt;i)$，并统计逆序对数目；</li><li>时间复杂度为$O(n^2)$。</li></ul><h4 id="3-分治策略-3"><a href="#3-分治策略-3" class="headerlink" title="(3)分治策略"></a>(3)分治策略</h4><ul><li><p>将子数组$A[low\dots high]$划分为两个规模尽量相等的子子数组；</p></li><li><p>分别递归求解仅在$A[low\dots mid]$和$A[mid+1\dots high]$中的逆序对数目；</p></li><li><p>合并子问题的解时，求解<strong>跨越子数组</strong>的逆序对数目；</p></li><li><p>求解跨越子数组的逆序对数目</p><ul><li><p>直接求解：对于每个$A[j]\in A[mid+1\dots high]$，枚举$A[i]\in A[low\dots mid]$并统计逆序对数目——算法运行时间为$O(n^2)$，得到分治策略运行时间为$O(n^2)$；</p><blockquote><p>运行时间受制于跨越子数组的逆序对计数方法，数组的<strong>有序性</strong>通常有助于提高算法的运行时间。</p></blockquote></li><li><p>排序求解：分别对数组$A[low\dots mid]和$$A[mid+1\dots high]$进行排序，对于每个$A[j]\in A[mid+1\dots high]$，采用二分查找为其在$A[low\dots mid]$中定位，则$A[j]$在$A[low\dots mid]$定位点右侧的元素均可与$A[j]$构成逆序对——算法运行时间为$O(n\log n)$，得到分治策略运行时间为$O(n(\log n)^2)$；</p><blockquote><p>排序和二分查找均无再优化空间，但未将排序过程融入整个算法框架；</p><p><strong>排序未利用子数组有序性质</strong>——使用归并排序；</p><p>合并问题解的同时对数组进行排序，归并过程中可同时计算逆序对数目。</p></blockquote></li><li><p>归并求解：从左到右扫描$A[low\dots mid]和$$A[mid+1\dots high]$，如果$A[i]&gt;A[j]$，统计逆序对，$j$向右移；否则$i$向右移——算法运行时间为$O(n)$，得到分治策略运行时间为$O(n\log n)$。</p></li></ul></li><li><p><strong>分而治之+归并求解</strong></p><blockquote><p>MergeCount：</p><img src="Chp3-MERGECOUNT.png" style="zoom: 72%;" /><p>CountInver：</p><img src="Chp3-COUNTINVER.png" style="zoom: 55%;" /></blockquote></li><li><p>时间复杂度</p><ul><li>归并求解的算法运行时间为$o(n)$；</li><li>$T(n)&#x3D;2T(n&#x2F;2)+O(n)$；</li><li>时间复杂度为$T(n)&#x3D;O(n\lg n)$。</li></ul></li></ul><h3 id="8-快速排序"><a href="#8-快速排序" class="headerlink" title="8.快速排序"></a>8.快速排序</h3><h4 id="1-问题描述-4"><a href="#1-问题描述-4" class="headerlink" title="(1)问题描述"></a>(1)问题描述</h4><ul><li>选择排序和插入排序的时间复杂度均为$O(n^2)$；</li><li>归并排序简化分解，<strong>侧重合并</strong>，快速排序<strong>侧重分解</strong>，简化合并。</li></ul><h4 id="2-分治策略"><a href="#2-分治策略" class="headerlink" title="(2)分治策略"></a>(2)分治策略</h4><ul><li><p>选取固定位置主元$x$，如尾元素；</p></li><li><p>维护两个部分的右端点下标变量$x,y$；</p><img src="Chp3-快速排序示意图.png" style="zoom:50%;" /></li><li><p>考察数组元素$A[j]$，并<strong>只和主元比较</strong>：若$A[j]\leq x$，则交换$A[j]$和$A[i+1]$，$i$和$j$右移，否则$j$右移；</p></li><li><p>到达末尾后，把主元放在中间$(i+1)$处作为分界线；</p></li><li><p>以主元作为数组的划分，得到子数组分别进行PARTITION排序，排序后进行合并</p></li><li><p>伪代码如下：</p><blockquote><p>Partition：对每个子数组进行排序操作，返回主元位置$p$</p><img src="Chp3-PARTITION.png" style="zoom:50%;" /><p>QuickSort：利用Partition和分治策略进行快速排序</p><img src="Chp3-QUICKSORT.png" style="zoom:49%;" /></blockquote></li><li><p>时间复杂度</p><ul><li><p>选取固定位置主元时最好情况下为$O(n\log n)$，最坏情况下为$O(n^2)$</p></li><li><p>选取随机位置主元，可以避免最坏情况的发生</p><blockquote><p>Randomized-Partition：</p><img src="Chp3-RANDOMIZED-PARTITION.png" style="zoom:65%;" /><p>Randomized-QuickSort：</p><img src="Chp3-RANDOMIZED-QUICKSORT.png" style="zoom: 55%;" /></blockquote></li><li><p>随机化的快速排序的期望复杂度为$O(n\log n)$</p></li><li><p><strong>基于比较的排序，其时间复杂度的下界为$\Omega(n\log n)$。</strong></p></li></ul></li></ul><h3 id="9-次序选择问题"><a href="#9-次序选择问题" class="headerlink" title="9.次序选择问题"></a>9.次序选择问题</h3><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="(1)基本概念"></a>(1)基本概念</h4><ul><li><p>顺序统计量：在一个由$n$个元素组成的集合中，第$i$个顺序统计量$(order statistic)$是该集合中的<strong>第$i$小</strong>的元素</p></li><li><p>中位数（<strong>一般指下中位数</strong>）</p><ul><li>下中位数：$i&#x3D;n&#x2F;2$或$i&#x3D;\lfloor(n+1)&#x2F;2\rfloor$</li><li>上中位数：$i&#x3D;n&#x2F;2+1$或$i&#x3D;\lceil(n+1)&#x2F;2\rceil$</li></ul></li><li><p>选择问题：从$n$个元素的集合中选择第$i$个顺序统计量的问题形式化地归结为<strong>“选择问题”</strong></p><ul><li>输入：一个包含$n$个（互异的）数的集合$A$和一个整数$i$，$1\leq i\leq n$</li><li>输出：元素$x\in A$,且$A$中恰好有$i-1$个其他元素小于它</li></ul></li><li><p>采用排序求解的方式解决选择问题时，其时间复杂度为$O(n\log n)$，可以求得所有元素的次序，选择元素的时间复杂度为$O(1)$。</p></li></ul><h4 id="2-期望为线性时间的选择算法"><a href="#2-期望为线性时间的选择算法" class="headerlink" title="(2)期望为线性时间的选择算法"></a>(2)期望为线性时间的选择算法</h4><ul><li><p>受启发于快速排序的Partition过程：</p><blockquote><img src="Chp3-受启发于快速排序.png" style="zoom: 45%;" /></blockquote></li><li><p>选择算法：</p><img src="Chp3-RANDOMIZED-SELECT.png" style="zoom: 50%;" /><blockquote><p>第1行检查$A[p..r]$中只包括一个元素的情况；</p><p>其余情况调用第3行的RANDOMIZED-PARTITION，将数组$A[p..r]$划分为两个子数组$A[p..q-1]$和$A[q+1..r]$<strong>（可能为空）</strong>，使前者的每个元素都小于$A[q]$，后者的每个元素都大于$A[q]$，称$A[q]$为主元；</p><p>第4行计算处于划分的低区的元素个数加1；</p><p>第5行检查$A[q]$是否为第$i$小的元素；</p><p>如果不是，则确定第$i$小的元素是在哪个子数组并在其中递归查找，当$i&gt;k$时，要找的元素必定为$A[q+1..r]$中第$i-k$小的元素。</p></blockquote></li><li><p>最坏情况运行时间为$\Theta(n^2)$，期望运行时间为$\Theta(n)$</p></li></ul><h4 id="※-3-最坏情况为线性时间的选择算法"><a href="#※-3-最坏情况为线性时间的选择算法" class="headerlink" title="※(3)最坏情况为线性时间的选择算法"></a>※(3)最坏情况为线性时间的选择算法</h4><h2 id="四、动态规划"><a href="#四、动态规划" class="headerlink" title="四、动态规划"></a>四、动态规划</h2><h3 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1.基本原理"></a>1.基本原理</h3><h4 id="1-基本概念-1"><a href="#1-基本概念-1" class="headerlink" title="(1)基本概念"></a>(1)基本概念</h4><ul><li>最优化问题：这一类问题的可行解可能有很多个。每个解都有一个值，我们希望寻找具有最优值的解（最小值或最大值）；</li><li>最优解可能有多个；</li><li>根据描述约束条件和目标函数的数学模型的特性和问题的求解方法的不同，可分为：线性规划、整数规划、非线性规划、 动态规划等问题。</li></ul><h4 id="2-动态规划的步骤"><a href="#2-动态规划的步骤" class="headerlink" title="(2)动态规划的步骤"></a>(2)动态规划的步骤</h4><ol><li><p><strong>问题结构分析</strong>：刻画结构特征，<strong>给出问题的表示</strong>，并<strong>明确原始问题</strong>；</p></li><li><p><strong>递推关系建立</strong>：分析最优(子)结构特征，构造递推公式；</p><blockquote><p>问题的最优解由相关子问题最优解组合而成，子问题可以独立求解；</p><p>递推公式又称状态转移方程。</p></blockquote></li><li><p><strong>自底向上计算</strong>：确定计算顺序，计算最优解的值；</p><blockquote><p>子问题的无关性和重叠性</p><ul><li>两个子问题如果不共享资源，它们就是独立的，比如在分治算法中子问题相互独立；</li><li>重叠是指两个子问题实际上是同一个子问题，只是作为不同问题的子问题出现而已，如果暴力枚举，则会导致大量重叠子问题重复计算。</li></ul><p>重叠子问题的解决：动态规划<strong>付出额外空间保存结果</strong>，对每个子问题只求解一次。</p></blockquote></li><li><p><strong>最优方案追踪</strong>：利用辅助数组等记录决策过程，输出最优方案。</p></li></ol><h4 id="3-证明最优子结构性"><a href="#3-证明最优子结构性" class="headerlink" title="(3)证明最优子结构性"></a>(3)证明最优子结构性</h4><ul><li>证明问题满足最优性原理是实施动态规划的必要条件。</li><li>证明的通用模式<ol><li>证明问题最优解的第一个组成部分是做出一个选择，例如，选择钢条第一次切割位置，选择矩阵链的划分位置等。</li><li>利用<strong>“剪切一粘贴”</strong>技术证明<ul><li>作为原问题最优解的组成部分，每个子问题的解就是它本身的最优解。</li><li>利用反证法：假定子问题的解不是其自身的最优解，那么我们就可以从原问题的解中<strong>“剪切”</strong>掉这些非最优解，将最优解<strong>“粘贴”</strong>进去，从而得到原问题一个更优的解，<strong>这与最初的解是原问题最优解的前提假设矛盾</strong>。</li></ul></li></ol></li></ul><h4 id="4-备忘机制"><a href="#4-备忘机制" class="headerlink" title="(4)备忘机制"></a>(4)备忘机制</h4><p>为了避免对重叠子问题的重复计算，在递归过程中加入<strong>备忘</strong>机制。当第一次遇到子问题时，计算其解，并将结果存储在备忘表中；而其后遇到同一个子问题时，通过简单的查表即可返回其解，无需重复计算，节省了时间。</p><h4 id="5-重构最优解"><a href="#5-重构最优解" class="headerlink" title="(5)重构最优解"></a>(5)重构最优解</h4><p>通常定义一个表，<strong>记录每个子问题所做的决策</strong>。当求出最优解的值后，利用该表<strong>回溯</strong>即可得到最优方案。</p><h4 id="6-子问题图"><a href="#6-子问题图" class="headerlink" title="(6)子问题图"></a>(6)子问题图</h4><ul><li><strong>子问题图用于描述子问题与子问题之间的依赖关系</strong>。</li><li>子问题图是一个有向图，每个顶点唯一地对应一个子问题。</li><li>若求子问题$x$的最优解时直接用到子问题$y$的最优解，则在子问题图中就会有一条从子问题$x$的顶点到子问题$y$的顶点的有向边。</li><li>子问题图是<strong>自顶向下递归调用树的“简化版”</strong>。</li><li>在自底向上方法中，对于任何子问题，仅当它依赖的所有子问题都求解完成，才会求解它。</li><li>子问题的数目等于顶点数；</li><li>一个子问题的求解时间与子问题图中对应顶点的“出度”成正比；</li><li>一般情况下，<strong>动态规划算法的运行时间与顶点和边的数量至少呈线性关系</strong>。</li></ul><h3 id="2-01背包问题"><a href="#2-01背包问题" class="headerlink" title="2.01背包问题"></a>2.01背包问题</h3><h4 id="1-问题描述-5"><a href="#1-问题描述-5" class="headerlink" title="(1)问题描述"></a>(1)问题描述</h4><p>$n$个商品组成集合$O$，每个商品有两个属性$v_i$和$p_i$，分别表示体积和价格，背包容量为$C$</p><p>试求解一个商品子集$S\subseteq O$，使得$max\sum\limits_{i\in S}p_i$且$\sum\limits_{i\in S}v_i\leq C$。</p><h4 id="2-问题分析-1"><a href="#2-问题分析-1" class="headerlink" title="(2)问题分析"></a>(2)问题分析</h4><ul><li>可以选取以下策略：<ul><li>策略1：按商品价格由高到低排序，优先挑选价格高的商品</li><li>策略2：按商品体积由小到大排序，优先挑选体积小的商品</li><li>策略3：按商品价值与体积的比由高到低排序，优先挑选比值高的商品</li></ul></li><li>以上三种策略<strong>都不能达到最优解</strong></li></ul><h4 id="3-暴力枚举"><a href="#3-暴力枚举" class="headerlink" title="(3)暴力枚举"></a>(3)暴力枚举</h4><ul><li><p>枚举所有组合共$2^n-1$种情况，并检查体积约束</p></li><li><p>伪代码如下：</p><blockquote><p>$KnapsackSR(i,c)$：前$i$个商品中，容量为$c$时为最优解</p><img src="Chp4-KnapsackSR.png" style="zoom:40%;" /></blockquote></li><li><p>时间复杂度为$O(2^n)$</p></li></ul><h4 id="4-带备忘递归-自顶向下"><a href="#4-带备忘递归-自顶向下" class="headerlink" title="(4)带备忘递归(自顶向下)"></a>(4)带备忘递归(自顶向下)</h4><ul><li><p>记录子问题解，避免重复计算</p></li><li><p>伪代码如下：</p><blockquote><p>$KnapsackMR(i,c)$：带备忘的递归求解</p><img src="Chp4-KnapsackMR.png" style="zoom: 45%;" /><p>构造备忘录$P[i,c]$，表示在前$i$个商品中选择，背包容量为$c$时的最优解</p></blockquote></li></ul><h4 id="5-递推计算-自底向上"><a href="#5-递推计算-自底向上" class="headerlink" title="(5)递推计算(自底向上)"></a>(5)递推计算(自底向上)</h4><ul><li><p>递推公式：$P[i,c]&#x3D;max{P[i-1,c-v[i]]+p[i],P[i-1,c]}$；</p></li><li><p>使用$Rec[i,c]$记录决策过程，选择时为1，否则为0；</p></li><li><p>回溯解决方案时，倒序判断是否选择商品，根据选择结果，确定最优子问题；</p></li><li><p>伪代码如下：</p><blockquote><p>$KnapsackDP(n,p,v,C)$</p><img src="Chp4-KnapsackDP-1.png" style="zoom:50%;" /><p>对数组进行初始化，默认每个商品都不选择；</p><img src="Chp4-KnapsackDP-2.png" style="zoom:48%;" /><p>在$for$循环中依次计算子问题，对于每个子问题，如果商品体积$v[i]\leq c$且选择该商品后得到的总价格$(P[i-1,c-v[i]]+p[i])$高，则选择该商品并更新$P[i,c]$，否则不选择该商品；</p><img src="Chp4-KnapsackDP-3.png" style="zoom:47%;" /><p>倒序判断是否选择了该商品，如果选择了该商品，则回溯子问题。</p></blockquote></li><li><p>求解表格的算法复杂度为$O(n\cdot C)$。</p></li></ul><h3 id="※3-最大子数组问题"><a href="#※3-最大子数组问题" class="headerlink" title="※3.最大子数组问题"></a>※3.最大子数组问题</h3><p>使用分治算法解决最大子数组问题的时间复杂度为$O(n\log n)$，使用动态规划方法能达到时间复杂度仅为$O(n)$的算法。</p><h3 id="4-钢条切割问题"><a href="#4-钢条切割问题" class="headerlink" title="4.钢条切割问题"></a>4.钢条切割问题</h3><h4 id="1-问题描述-6"><a href="#1-问题描述-6" class="headerlink" title="(1)问题描述"></a>(1)问题描述</h4><ul><li><p>给定一段长度为$n$英寸的钢条和一个价格表$P$，切割工序本身没有成本支出，求切割钢条方案，使得销售收益 $r_n$ 最大。</p></li><li><p>假定出售一段长度为i英寸的钢条的价格为$p_i(i&#x3D;1,2,\dots)$，下面是价格表$P$：</p><img src="Chp4-价格表P.png" style="zoom: 50%;" /></li></ul><h4 id="2-问题分析-2"><a href="#2-问题分析-2" class="headerlink" title="(2)问题分析"></a>(2)问题分析</h4><ul><li>每一英寸都可切割，共有$n-1$个切割点，因此长度为$n$英寸的钢条共有$2^{n-1}$中不同的切割方案。</li><li>如果一个最优解将总长度为$n$的钢条切割为$k$段，每段的长度为$i_j(1\leq j\leq k)$，则有$n&#x3D;i_1+i_2+\dots+i_k$，得到的最大收益为$r_n&#x3D;p_{i_1}+p_{i_2}+\dots+p_{i_k}$</li><li>首次切割后，将两段钢条看成<strong>两个独立的钢条切割问题</strong>实例。若分别获得两段钢条的最优切割收益$r_j$和$r_{n-j}$，则原问题的解就可以通过<strong>组合这两个相关子问题的最优子解</strong>获得。</li><li>也即<strong>最优子结构性</strong>——如果$r_n&#x3D;r_i+r_{n-i}$是最优切割收益，则$r_i$、$r_{n-i}$是相应子问题的最优切割收益。</li></ul><h4 id="3-朴素递归"><a href="#3-朴素递归" class="headerlink" title="(3)朴素递归"></a>(3)朴素递归</h4><ul><li><p>$r_n&#x3D;\max\limits_{1\leq i\leq n}{(p_i+r_{n-i})}$</p><img src="Chp4-CUT-ROD.png" style="zoom: 33%;" /></li><li><p>运行效率很差，存在一些相同的子问题重复调用解决</p></li><li><p>$T(n)&#x3D;1+\sum\limits_{j&#x3D;0}^{n-1}T(j)$，也即$T(n)&#x3D;2^n$</p></li></ul><h4 id="4-带备忘递归-自顶向下-1"><a href="#4-带备忘递归-自顶向下-1" class="headerlink" title="(4)带备忘递归(自顶向下)"></a>(4)带备忘递归(自顶向下)</h4><ul><li><p>依旧按照<strong>递归</strong>的形式编写过程，但处理过程中会<strong>保存每个子问题的解</strong>。</p></li><li><p>具体实现如下：</p><blockquote><img src="Chp4-MEMOIZED-CUT-ROD.png" style="zoom: 50%;" /></blockquote><blockquote><img src="Chp4-MEMOIZED-CUT-ROD-AUX.png" style="zoom: 40%;" /></blockquote><blockquote><p>其中辅助数组$r[0\dots n]$用于保存子问题的结果。</p><p>​初始化为$-\infty$；</p><p>​当有新的结果时，$r[n]$保存结果$q$；</p><p>​当$r[n]\geq 0$时，直接引用其中已保存的值。</p></blockquote></li><li><p>运行时间为$\Theta(n^2)$</p></li></ul><h4 id="5-自底向上"><a href="#5-自底向上" class="headerlink" title="(5)自底向上"></a>(5)自底向上</h4><ul><li><p>将子问题按规模排序，按<strong>由小到大的顺序顺次求解</strong>，当求解某个子问题时，它所依赖的<strong>更小子问题都已求解完毕</strong>，结果已经保存，故可以直接引用并组合出它自身的解</p><img src="Chp4-BOTTOM-UP-CUT-ROD.png" style="zoom: 50%;" /></li><li><p>运行时间为$\Theta(n^2)$，相比自顶向下的方法具有更小的系数</p></li></ul><h4 id="6-自底向上-给出切割方案"><a href="#6-自底向上-给出切割方案" class="headerlink" title="(6)自底向上(给出切割方案)"></a>(6)自底向上(给出切割方案)</h4><img src="Chp4-EXTENDED-BOTTOM-UP-CUT-ROD.png" style="zoom: 50%;" /><img src="Chp4-PRINT-CUT-ROD-SOLUTION.png" style="zoom: 50%;" /><h3 id="5-矩阵链乘法问题"><a href="#5-矩阵链乘法问题" class="headerlink" title="5.矩阵链乘法问题"></a>5.矩阵链乘法问题</h3><h4 id="1-基本背景"><a href="#1-基本背景" class="headerlink" title="(1)基本背景"></a>(1)基本背景</h4><ul><li>已知$A$为$p\times r$的矩阵，$B$为$r\times q$的矩阵，则$A$与$B$的乘积是一个$p\times q$的矩阵，矩阵相乘需要进行**$pqr$**次标量乘法运算。</li><li>$n$个要连续相乘的矩阵构成一个矩阵链$&lt;A_1,A_2,\dots,A_n&gt;$，要计算这$n$个矩阵的连乘乘积：$A_1A_2\dots A_n$，称为矩阵链乘问题。<ul><li>矩阵链乘满足结合律，不满足交换律。</li><li>不同的加括号方式代表不同的<strong>计算模式</strong>，而不同的计算模式计算矩阵链乘积的<strong>代价不同</strong>。</li></ul></li></ul><h4 id="2-问题描述"><a href="#2-问题描述" class="headerlink" title="(2)问题描述"></a>(2)问题描述</h4><ul><li>给定$n$个矩阵的链，记为$&lt;A_1,A_2,\dots,A_n&gt;$，其中$i&#x3D;1,\dots,n$，矩阵$A_i$的维数为$p_{i-1}\times P_i$。</li><li>求<strong>“完全括号化方案”</strong>，使得计算乘积$A_1A_2\dots A_n$所需的标量乘法次数最小。</li><li>穷举所有方案的数量：当$n&#x3D;1$时，$P(n)&#x3D;1$，当$n\geq 2$时，$P(n)&#x3D;\sum\limits_{k&#x3D;1}^{n-1}P(k)P(n-k)$，证明得到时间复杂度为$P(n)&#x3D;\Omega(2^n)$</li></ul><h4 id="3-动态规划"><a href="#3-动态规划" class="headerlink" title="(3)动态规划"></a>(3)动态规划</h4><ul><li><p>最优括号化方案的结构特征——寻找最优子结构</p><ul><li>整体的最优括号化方案可以通过寻找使最终标量乘法次数最小的两个最优括号化子方案得到，形如：$(A_1A_{i+1}\dots A_k)(A_{k+1}\dots A_n)$</li></ul></li><li><p>递推求解方案</p><ul><li>递推求解公式</li></ul><img src="Chp4-矩阵链乘递归式.png" style="zoom: 80%;" /><ul><li>使用$s[i,j]$保存$A_iA_{i+1}\dots A_j$最优括号化方案的分割点位置$k$</li></ul></li><li><p>计算最优代价</p><ul><li><p>对应子问题为$\Theta(n^2)$个，存在<strong>子问题重叠</strong>现象，同最优子结构性一样，这也是应用动态规划的标识。</p></li><li><p>采用自底向上法替代该递推求解公式</p><ul><li><p>算法的输入为序列$p&#x3D;\langle p_0,p_1,\dots,p_n\rangle$，长度为$p.length&#x3D;n+1$</p></li><li><p>算法伪代码如下：</p><img src="Chp4-MATRIX-CHAIN-ORDER.png" style="zoom: 50%;" /><blockquote><p>第$3\thicksim 4$行计算$m[i,i]&#x3D;0$</p><p>第$5\thicksim 13$行计算不同矩阵链长度下$m[i,i+l-1]$的最小计算代价，长度依次递增计算。</p><p>可以使用一个上三角矩阵表表示$m[i,j]$和$s[i,j]$</p><p>具体实例如下：</p><img src="Chp4-MATRIX-CHAIN-ORDER-SAMPLE.png" style="zoom: 67%;" /></blockquote></li><li><p>算法运行时间为$\Omega(n^3)$，空间复杂度为$\Theta(n^2)$</p></li></ul></li></ul></li><li><p>构造最优解</p><ul><li><p>$s[i,j]$记录了$A_iA_{i+1}\dots A_j$的最优括号化方案的“首个”分割点$k$。基于$s[i,j]$，对$A_iA_{i+1}\dots A_j$的括号化方案是：</p><p>​       $(A_iA_{i+1}\dots A_{s[i,j]})(A_{s[i,j]+1}\dots A_j)$</p></li><li><p>打印结果的伪代码如下：</p><img src="Chp4-PRINT-OPTIMAL-PARENS.png" style="zoom: 50%;" /></li></ul></li></ul><h3 id="6-最长公共子序列"><a href="#6-最长公共子序列" class="headerlink" title="6.最长公共子序列"></a>6.最长公共子序列</h3><h4 id="1-基本背景-1"><a href="#1-基本背景-1" class="headerlink" title="(1)基本背景"></a>(1)基本背景</h4><ul><li><p>子序列</p><p>给定两个序列$X&#x3D;&lt;X_1,X_2,\dots,X_n&gt;$和序列$Z&#x3D;&lt;z_1,z_2,\dots,z_k&gt;$，若存在$X$的一个严格递增下标序列$&lt;i_1,i_2,\dots,i_k&gt;$,使得对所有$j&#x3D;1,2,\dots,k$，有$x_{i_j}&#x3D;z_j$，则称$Z$是$X$的子序列。</p><blockquote><p>$Z&#x3D;&lt;B,C,D,B&gt;$是$X&#x3D;&lt;A,B,C,B,D,A,B&gt;$的一个子序列，对应下标序列为$&lt;2,3,5,7&gt;$。</p></blockquote></li><li><p>公共子序列</p><p>对给定的两个序列$X$和$Y$，若序列$Z$既是$X$的的子序列，也是$Y$的子序列，则称$Z$是$X$和$Y$的公共子序列。</p><blockquote><p>$X&#x3D;&lt;A,B,C,B,D,A,B&gt;$，$Y&#x3D;&lt;B,D,C,A,B,A&gt;$，则序列$&lt;B,C,A&gt;$是$X$和$Y$的一个公共子序列。</p></blockquote></li><li><p>最长公共子序列(LCS)</p><p>两个序列的长度最大的公共子序列称为它们的最长公共子序列。</p><blockquote><p>$&lt;B,C,A&gt;$是上面$X$和$Y$的一个公共子序列，但不是$X$和$Y$的最长公共子<br>序列。最长公共子序列是$&lt;B,C,B,A&gt;$。</p></blockquote></li><li><p>前缀</p><p>给定一个序列$X&#x3D;&lt;x_1,x_2,\dots,x_m&gt;$，对于$i&#x3D;0,1,\dots,m$，定义$X$的第$i$个前缀为$X_i&#x3D;&lt;x_1,x_2,\dots,x_i&gt;$，即前$i$个元素构成的子序列。</p><blockquote><p>$X&#x3D;&lt;A,B,C,B,D,A,B&gt;$，则$X_4&#x3D;&lt;A,B,C,B&gt;$，$X_0&#x3D;\Phi$。</p></blockquote></li></ul><h4 id="2-最优子结构性"><a href="#2-最优子结构性" class="headerlink" title="(2)最优子结构性"></a>(2)最优子结构性</h4><p>两个序列的一个$LCS$也包含了两个序列的前缀的$LCS$，即$LCS$问题具有最优子结构性质。</p><blockquote><p>定理：设有序列$X&#x3D;&lt;x_1,x_2,\dots,x_m&gt;$和$Y&#x3D;&lt;y_1,y_2,\dots,y_n&gt;$，并设序列$Z&#x3D;&lt;z_1,z_2,\dots,z_k&gt;$为$X$和$Y$的任意一个**$LCS$**。</p><p>（1）若$x_m＝y_n$，则$z_k&#x3D;x_m&#x3D;y_n$，且$Z_{k-1}$是$X_{m-1}$和$Y_{n-1}$的一个$LCS$。</p><p>（2）若$x_m\ne y_n$，则$z_k\ne x_m$蕴含$Z$是$X_{m-1}$和Y的一个$LCS$。</p><p>（3）若$x_m\ne y_n$，则$z_k\ne y_n$蕴含$Z$是$X$和$Y_{n-1}$的一个$LCS$。</p></blockquote><h4 id="3-递推关系式"><a href="#3-递推关系式" class="headerlink" title="(3)递推关系式"></a>(3)递推关系式</h4><p>记$c[i,j]$为前缀序列$X_i$和$Y_j$的一个$LCS$的长度，则有</p><img src="Chp4-LCS递推关系式.png" style="zoom: 33%;" /><blockquote><p>1）若$i&#x3D;0$或$j&#x3D;0$，即其中一个序列的长度为零，则$LCS$的长度为0，$LCS&#x3D;\Phi$；</p><p>2）若$x_i&#x3D;y_j$，则$X_i$和$Y_j$的$LCS$是在$X_{i-1}$和$Y_{j-1}$的$LCS$之后附加将$x_i$得到的，所以                </p><p>$c[i,j]&#x3D;c[i-1,j-1]+1$；</p><p>3）若$x_i\ne y_j$，则$X_i$和$Y_j$的$LCS$的最后一个字符不会是$x_i$或$y_j$(不可能同时等于两者，或与两者都不同)，此时该$LCS$应等于$X_{i-1}$和$Y_j$的$LCS$与$X_i$和$Y_{j-1}$的$LCS$之中的较长者。所以</p><p>$c[i,j]&#x3D;max(c[i-1,j],c[i,j-1])$。</p></blockquote><h4 id="4-自底向上"><a href="#4-自底向上" class="headerlink" title="(4)自底向上"></a>(4)自底向上</h4><ul><li><p>过程$LCS-LENGTH(X,Y)$用来求序列$X&#x3D;&lt;x_1,x_2,\dots,x_m&gt;$和$Y&#x3D;&lt;y_1,y_2,\dots,y_n&gt;$的$LCS$的长度，其时间复杂度为$O(mn)$。</p><img src="Chp4-LCS-LENGTH.png" style="zoom: 50%;" /><blockquote><p>表$c[1..m,1..n]$中包含每一阶段的$LCS$长度，$c[m,n]$等于$X$和$Y$的$LCS$的长度。</p><p>表$b[1..m,1..n]$记录当前$c[i,j]$的计值情况，以此来构造该$LCS$。</p><p>下图给出了在$X&#x3D;&lt;A,B,C,B,D,A,B&gt;$和$Y&#x3D;&lt;B,D,C,A,B,A&gt;$上运行$LCS-LENGTH$计算出的表：</p><img src="Chp4-LCS-LENGTH-SAMPLE.png" style="zoom: 67%;" /><blockquote><p>1）第$i$行和第$j$列中的方块包含了$c[i,j]$的值以及$b[i,j]$记录的箭头。</p><p>2）对于$i,j＞0$，项$c[i,j]$仅依赖于是否有$x_i&#x3D;y_j$及项$c[i-1,j]$、$c[i,j-1]$、$c[i-1,j-1]$的值。</p><p>3）为了重构一个$LCS$，从右下角开始跟踪$b[i,j]$箭头即可</p><p>4）图中，$c[7,6]&#x3D;4$，$LCS(X,Y)&#x3D;&lt;B,C,B,A&gt;$。</p></blockquote></blockquote></li></ul><h4 id="5-构建最优解"><a href="#5-构建最优解" class="headerlink" title="(5)构建最优解"></a>(5)构建最优解</h4><ul><li><p>借助$b[i,j]$反序输出$LCS$，由于每一次循环使$i$或$j$减1，最终$m&#x3D;0$，$n&#x3D;0$，算法结束，所以$PRINT-LCS$的时间复杂度为$O(m+n)$。</p><img src="Chp4-PRINT-LCS.png" style="zoom: 33%;" /></li><li><p>改进：去掉表$b$，直接基于$c$求$LCS$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PRINT-LCS-WITHOUTAUXI(c, X, Y, i, j)</span><br><span class="line">    if c[i, j] == 0</span><br><span class="line">        return</span><br><span class="line">    if X[i] == Y[j]</span><br><span class="line">        PRINT-LCS-WITHOUTAUXI(c, X, Y, i - 1, j - 1)</span><br><span class="line">        print X[i]</span><br><span class="line">    else if c[i - 1, j] &gt;= c[i, j - 1]</span><br><span class="line">        PRINT-LCS-WITHOUTAUXI(c, X, Y, i - 1, j)</span><br><span class="line">    else</span><br><span class="line">        PRINT-LCS-WITHOUTAUXI(c, X, Y, i, j - 1)</span><br></pre></td></tr></table></figure></li><li><p>改进：算法中，每个$c[i,j]$的计算仅需$c$的两行的数据：正在被计算的一行和前面的一行。</p></li></ul><h3 id="※7-最长公共子串"><a href="#※7-最长公共子串" class="headerlink" title="※7.最长公共子串"></a>※7.最长公共子串</h3><h3 id="8-最优二叉搜索树"><a href="#8-最优二叉搜索树" class="headerlink" title="8.最优二叉搜索树"></a>8.最优二叉搜索树</h3><h4 id="1-基本背景-2"><a href="#1-基本背景-2" class="headerlink" title="(1)基本背景"></a>(1)基本背景</h4><ul><li><p>二叉搜索树$T$是一棵二元树，它或者为空，或者其每个结点含有一个可以比较大小的数据元素，且有：</p><ul><li>$T$的左子树的所有元素比根结点中的元素小；</li><li>$T$的右子树的所有元素比根结点中的元素大；</li><li>$T$的左子树和右子树也是二叉搜索树。</li></ul></li><li><p>给定一个$n$个关键字的升序序列$K&#x3D;&lt;k_1,k_2,\dots,k_n&gt;$，对每个关键字$k_i$，都有一个概率$p_i$表示其被搜索的频率。根据$k_i$和$p_i$构建一个二叉搜索树$T$，每个$k_i$对应树中的一个结点。</p></li><li><p>引入外部结点$d_0,d_1,\dots,d_n$，用来表示不在$K$中的值,称为伪关键字。</p><ul><li><p>伪关键字在$T$中对应外部结点，共有$n+1$个。</p><blockquote><p>​<strong>扩展二叉树</strong>：内结点表示关键字$k_i$，外结点(叶子结点)表示$d_i$。</p></blockquote></li><li><p>每个$d_i$代表一个区间，$d_0$表示所有小于$k_1$的值，$d_n$表示所有大于$k_n$的值，对于$i&#x3D;1,\dots,n-1$，$d_i$表示所有在$k_i$和$k_{i+1}$之间的值。</p></li><li><p>每个$d_i$也有一个概率$q_i$<strong>，</strong>表示搜索对象$x$恰好落入区间$d_i$的频率。</p></li></ul></li><li><p>一次搜索的代价等于从根结点开始访问结点的数量(<strong>包括外部结点</strong>)</p><blockquote><p>从根结点开始访问结点的数量等于<strong>“结点在$T$中的深度+1”</strong>；</p><p>记$depth_{T(i)}$为结点$i$在$T$中的深度</p></blockquote></li><li><p>二叉搜索树$T$的期望代价为</p><img src="Chp4-SEARCH-COST-EXPECTATION.png" style="zoom: 33%;" /></li><li><p><strong>最优二叉搜索树</strong>：对于给定的关键字及其概率集合，期望搜索代价最小的二叉搜索树。</p></li></ul><h4 id="2-动态规划"><a href="#2-动态规划" class="headerlink" title="(2)动态规划"></a>(2)动态规划</h4><ul><li><p>最优二叉搜索树的最优子结构</p><blockquote><p>如果$T$是一棵相对于关键字$k_1,\dots,k_n$和伪关键字$d_0,\dots,d_n$的最优二叉搜索树，则$T$中一棵包含关键字$k_i,\dots,k_j$的子树$T’$必然是相对于关键字$k_i,\dots,k_j$（和伪关键字$d_{i-1},\dots,d_j$）的最优二叉搜索子树。</p></blockquote></li><li><p>构造最优二叉搜索树</p><ul><li><p>求解包含关键字$k_i,\dots,k_j$的最优二叉搜索树，其中$i\geq 1$，$j\leq n$且 $j\geq i-1$</p></li><li><p>定义$e[i,j]$：为包含关键字$k_i,\dots,k_j$的最优二叉搜索树的期望搜索代价。</p></li><li><p>当$j&#x3D;i-1$时，由于子树只包含伪关键字$d_{i-1}$,期望搜索代价为$e[i,i-1]&#x3D;q_{i-1}$</p></li><li><p>当$j\geq i$时，从$k_i,\dots,k_j$中选择出根结点$k_r$，以此构建两个最优左右二叉搜索子树。</p><img src="Chp4-最优二叉搜索树期望搜索代价递归公式.png" style="zoom:67%;" /></li></ul></li><li><p>计算期望搜索代价</p><ul><li><p>定义$root[i,j]$，保存计算$e[i, j]$时，使$e[i, j]$取得最小值的$r$，$k_r$即为关键字$k_i,\dots,k_j$的最优二叉搜索（子）树的树根。在求出$e[1,n]$后，利用$root$即可构造出最终的最优二叉搜索树。</p></li><li><p>$w[1..n+1,0..n]$用于保存子树的结点概率之和，每个$w[i,j]$的计算时间仅为$\Theta(1)$</p><blockquote><p>满足<img src="Chp4-BST-w[i,j].png" style="zoom: 33%;" /></p></blockquote></li><li><p>自底向上的迭代计算，时间复杂度为$\Theta(n^3)$</p><img src="Chp4-OPTIMAL-BST.png" style="zoom:50%;" /></li></ul></li></ul><h2 id="五、贪心算法"><a href="#五、贪心算法" class="headerlink" title="五、贪心算法"></a>五、贪心算法</h2><h3 id="1-基本原理-1"><a href="#1-基本原理-1" class="headerlink" title="1.基本原理"></a>1.基本原理</h3><h4 id="1-基本概念-2"><a href="#1-基本概念-2" class="headerlink" title="(1)基本概念"></a>(1)基本概念</h4><ul><li>分步骤实施，它在每一步仅作出当时看起来最佳的选择，即<strong>局部最优的选择</strong>，并寄希望这样的选择最终能导致<strong>全局最优解</strong>。</li><li>实例：最小生成树问题的$Prim$算法、$Kruskal$算法，单源最短路径$Dijkstra$算法，<strong>分数背包</strong>。</li><li>贪心算法<strong>不总能对所有问题能求解</strong>，只是对一些问题确实有效，可以求出最优解或近似最优解。</li></ul><h4 id="2-贪心算法的步骤"><a href="#2-贪心算法的步骤" class="headerlink" title="(2)贪心算法的步骤"></a>(2)贪心算法的步骤</h4><ul><li><p>提出贪心策略：观察问题特征，构造贪心选择；</p></li><li><p>证明策略正确：假设最优方案，通过替换证明。</p><blockquote><p>对应每个贪心算法，都有一个动态规划算法，但动态规划算法要繁琐的多。</p></blockquote></li></ul><h4 id="3-贪心选择性质"><a href="#3-贪心选择性质" class="headerlink" title="(3)贪心选择性质"></a>(3)贪心选择性质</h4><p>可以通过做出局部最优（贪心）选择来构造全局最优解的性质。</p><p>贪心选择性使得我们进行选择时， 只需做出当前看起来最优的选择，而不用考虑子问题的解。  </p><h3 id="2-活动选择问题"><a href="#2-活动选择问题" class="headerlink" title="2.活动选择问题"></a>2.活动选择问题</h3><h4 id="1-问题描述-7"><a href="#1-问题描述-7" class="headerlink" title="(1)问题描述"></a>(1)问题描述</h4><ul><li><p>假定有一个活动的集合$S$​含有$n$​个活动${a_1,a_2,\dots,a_n}$​，每个活动$a_i$​都有一个开始时间$s_i$​和结束时间$f_i$​，$0\leq s_i&lt;f_i&lt;\infty$。同时，这些活动都要使用同一资源(如演讲会场)，而这个资源在任何时刻只能供一个活动使用。</p></li><li><p>活动的兼容性：如果选择了活动$a_i$，则它在半开时间区间 $[s_i, f_i)$内占用资源。若两个活动$a_i$和$a_j$满足$[s_i, f_i)$与区间$[s_j, f_j)$不重叠，则称它们是<strong>兼容</strong>的。</p></li><li><p><strong>活动选择问题</strong>：假设活动按照结束时间单调递增排序，对给定的包含$n$个活动的集合$S$，在已知每个活动开始时间和结束时间的条件下，从中选出最多可兼容活动的子集合，称为<strong>最大兼容活动集合</strong>。</p><blockquote><p>考虑下列活动集合$S$：</p><img src="Chp5-活动选择问题SAMPLE.png" style="zoom:67%;" /></blockquote></li></ul><h4 id="2-问题分析-3"><a href="#2-问题分析-3" class="headerlink" title="(2)问题分析"></a>(2)问题分析</h4><ul><li><p>设$S_{ij}$表示在$a_i$结束之后开始且在$a_j$开始之前结束的活动集合，$A_{ij}$表示$S_{ij}$的一个最大兼容活动子集，设$A_{ij}$包括活动$a_k$，则得到两个子问题——寻找$S_{ik}$和$S_{kj}$的最大兼容活动集合。</p><blockquote><p>图解如下：</p><img src="Chp5-活动选择问题的最优子结构性.png" style="zoom:50%;" /></blockquote></li><li><p>必有：$A_{ik}$是$S_{ik}$一个最大兼容活动子集，$A_{kj}$是$S_{kj}$一个最大兼容活动子集。</p><blockquote><p>$A_{ij}&#x3D;A_{ik}∪{a_k}∪A_{kj}$</p></blockquote></li><li><p>令$c[i,j]$表示集合$S_{ij}$的最优解大小，可使用动态规划方法解决</p></li></ul><h4 id="3-贪心算法"><a href="#3-贪心算法" class="headerlink" title="(3)贪心算法"></a>(3)贪心算法</h4><ul><li><p>每次总选择具有最早结束时间的兼容活动加入到集合$A$中——使剩余的可安排时间段最大化，以便安排尽可能多的兼容活动。</p></li><li><p>当输入的活动已按结束时间的递增顺序排列，贪心算法只需$O(n)$的时间即可选择出来$n$个活动的最大兼容活动集合。</p><blockquote><p>考虑任意非空子问题$S_k$，令$a_m$是$S_k$中结束时间最早的活动，则$a_m$必在$S_k$的某个最大兼容活动子集中。</p></blockquote></li><li><p>自顶向下的递归方法</p><blockquote><p>首先做出一个选择，然后求解剩下的子问题。每次选择将问题转化成一个规模更小的问题。</p><p>伪代码如下：</p><img src="Chp5-RECURSIVE-ACTIVITY-SELECTOR.png" style="zoom: 50%;" /><blockquote><p>第$2\thicksim 3$行查找$S_k$中最早结束的活动，循环检查$a_{k+1},a_{k+2},\dots,a_n$，直至找到第一个与$a_k$兼容的活动$a_m$，也即满足$s_m\geq f_k$。</p><p>如果成功找到$m$（也即$m\leq n$），则返回${a_m}$与$RECURSIVE-ACTIVITY-SELECTOR(s,f,m,n)$返回的$S_m$的最大子集的并集。</p><p>如果未成功找到$m$，则说明未找到与$a_k$兼容的活动，则返回$\Phi$。</p></blockquote></blockquote></li><li><p>迭代实现的贪心算法</p><blockquote><p>伪代码如下：</p><img src="Chp5-GREEDY-ACTIVITY-SELECTOR.png" style="zoom:50%;" /><blockquote><p>$k$对应最后一个加入$A$的活动，$f_k$是$A$中活动的最大结束时间，若$m$的开始时间大于$f_k$，则$m$就是下一个被选中的活动。</p><p>算法的运行时间是$O(n)$。</p></blockquote></blockquote></li></ul><h3 id="3-带权活动选择问题"><a href="#3-带权活动选择问题" class="headerlink" title="3.带权活动选择问题"></a>3.带权活动选择问题</h3><h4 id="1-问题描述-8"><a href="#1-问题描述-8" class="headerlink" title="(1)问题描述"></a>(1)问题描述</h4><ul><li>在活动选择问题中，如果每个活动都具有权重$w$，现寻找活动子集$S’$，使得权重和最大</li></ul><h4 id="2-问题分析-4"><a href="#2-问题分析-4" class="headerlink" title="(2)问题分析"></a>(2)问题分析</h4><ul><li>存在重叠子问题，可以使用动态规划求解</li><li>设$p[i]$表示在$a_i$开始前最后结束的活动编号</li><li>设$Rec[i]$表示是否选择问题$i$</li><li>设$D[i]$表示集合${a_1,a_2,a_3,\dots,a_i}$中兼容活动最大权重和</li><li>将活动按照结束时间升序进行排序，则可得到$D[i]&#x3D;max{D[p[i]]+w_i,D[i-1]}$；其中不选择$a_i$时，其最大权重和即为$D[i-1]$，选择$a[i]$时，其最大权重和应为在$a_i$开始前最后结束的活动编号对应的最大权重和加上$w_i$，即$D[p[i]]+w_i$。</li></ul><h4 id="3-动态规划-1"><a href="#3-动态规划-1" class="headerlink" title="(3)动态规划"></a>(3)动态规划</h4><ul><li><p>伪代码如下</p><blockquote><img src="Chp5-带权活动选择问题.png" style="zoom:67%;" /></blockquote></li><li><p>时间复杂度为$O(n\log n)$</p></li></ul><h3 id="4-Huffman-编码"><a href="#4-Huffman-编码" class="headerlink" title="4.$Huffman$编码"></a>4.$Huffman$编码</h3><h4 id="1-基本概念-3"><a href="#1-基本概念-3" class="headerlink" title="(1)基本概念"></a>(1)基本概念</h4><ul><li><p>码字：每个字符用唯一的二进制串表示，称为码字。</p></li><li><p>定长编码：每个字符的编码长度一样。</p><blockquote><p>对于$a\thicksim f$六个字符，应采用3位码字编码，则10万个字符需用30万个二进制位编码。</p></blockquote></li><li><p>变长编码：每个字符赋予不同长度的码字。</p><blockquote><p>赋予高频字符短码字，低频字符长码字，字符的码字互不为前缀，这样才能唯一解码，同时能够提高编码效率。如$a$用1位的串0表示，$b$用3位的串101表示，$f$用4位的串1100表示等。</p></blockquote></li><li><p>前缀码$(Prefix code)$：任何码字都不是其它码字的前缀。</p><blockquote><p>前缀码可以简化解码过程，由于没有码字是其它码字的前缀，所以编码文件的开始部分是没有歧义的，可以唯一地转换回原字符。</p></blockquote></li><li><p>编码树：一种为表示字符二进制编码而构造的二叉树。</p><blockquote><img src="Chp5-赫夫曼编码树-SAMPLE.png" style="zoom:50%;" /><p>叶子结点：对应给定的字符，每个字符对应一个叶子结点。</p><p>编码构造：字符的二进制码字由根结点到该字符叶子结点的简单路径</p><p>路径表示：0代表转向左孩子，1代表转向右孩子</p></blockquote></li><li><p>最优字符编码方案总对应一棵<strong>满二叉树</strong>， 即每个非叶子结点都有两个孩子结点。</p></li></ul><h4 id="2-最优字符编码方案"><a href="#2-最优字符编码方案" class="headerlink" title="(2)最优字符编码方案"></a>(2)最优字符编码方案</h4><ul><li><p>符号表示</p><ul><li><p>设$C$为字母表</p><blockquote><p>对字母表$C$中的任意字符$c$，令属性$c.freq$表示字符$c$在文件中出现的频率</p><p>最优前缀码对应的树中恰好有$|C|$个叶子结点，每个叶子结点对应字母表中的一个字符，且恰有$|C|-1$个内部结点。</p></blockquote></li><li><p>设$T$表示一棵前缀编码树</p></li><li><p>设$d_T(c)$表示c的叶子结点在树T中的深度（根到叶子结点的路径长度）</p><blockquote><p>$d_T(c)$也表示字符$c$的码字长度</p></blockquote></li><li><p>设$B(T)$表示采用$T$编码时的文件编码长度，即$B(T)&#x3D;\sum\limits_{c\in C}c.freq\cdot d_T(c)$，称$B(T)$为T的代价。</p><blockquote><p>使得$B(T)$最小的编码称为最优编码。</p><p>对给定的字符集和文件，$Huffman$编码是一种最优编码。</p></blockquote></li></ul></li></ul><h4 id="3-Huffman-编码"><a href="#3-Huffman-编码" class="headerlink" title="(3)$Huffman$编码"></a>(3)$Huffman$编码</h4><ul><li><p>算法$HUFFMAN$从$|C|$个叶子结点开始，每次选择频率最低的两个结点合并，将得到的新结点加入集合继续合并，这样执行$|C|-1$次<strong>“合并”</strong>后即可构造出一棵编码树——$Huffman$树。</p><blockquote><p>伪代码如下：</p><img src="Chp5-HUFFMAN.png" style="zoom:50%;" /><p>第2行用$C$中字符初始化最小优先队列$Q$；</p><p>第$3\thicksim 8$行的循环反复从队列中合并频率最低的结点$x$和$y$，合并为新结点$z$并替代之；</p><p>经过$n-1$次合并后，最后返回剩下的唯一结点——编码树的根结点</p><p>示例如下：</p><blockquote><img src="Chp5-HUFFMAN-SAMPLE.png" style="zoom: 67%;"/></blockquote></blockquote></li><li><p>时间复杂度的分析</p><ul><li><p>假设$Q$使用最小二叉堆实现，则其初始化花费$O(n)$的时间</p></li><li><p>循环的总代价是$O(n\lg n)$</p><blockquote><p>$for$循环共执行了$n-1$次，每次从堆中找出当前频率最小的两个结 点及把合并得到的新结点插入到堆中均花费$O(\lg n)$，所以循环的总代价是$O(n\lg n)$。</p></blockquote></li><li><p>因此，$HUFFMAN$的总运行时间$O(n\lg n)$</p></li></ul></li><li><p>※$Huffman$算法的正确性</p><ul><li>证明贪心选择性</li><li>证明最优子结构性</li></ul></li></ul><h3 id="5-分数背包问题"><a href="#5-分数背包问题" class="headerlink" title="5.分数背包问题"></a>5.分数背包问题</h3><h4 id="1-问题描述-9"><a href="#1-问题描述-9" class="headerlink" title="(1)问题描述"></a>(1)问题描述</h4><ul><li>已知$n$个物品组成的集合O，每个物品有两个属性$v_i$和$p_i$，分别表示体积和价格；</li><li>背包容量为$C$；</li><li>试求解$S&#x3D;{x_i|1\leq i\leq n,0\leq x_i\leq 1}$，使得$max\sum\limits_{x_i\in S}x_ip_i$且$\sum\limits_{x_i\in S}x_iv_i\leq C$。</li></ul><h4 id="2-问题分析-5"><a href="#2-问题分析-5" class="headerlink" title="(2)问题分析"></a>(2)问题分析</h4><ul><li><p>采用贪心算法，每次选择**最高性价比($p_i&#x2F;v_i$)**的物品，证明可得贪心解不劣于最优解</p></li><li><p>伪代码如下</p><blockquote><p>$FractionalKnapsack(n,p,v,C)$</p><img src="Chp5-FractionlKnapsack.png" style="zoom:67%;" /><p>当背包未装满且商品未装完时填入商品，商品体积不大于容量则全部装入，否则装入部分商品填满背包</p></blockquote></li><li><p>算法复杂度为$O(n\log n)$</p></li></ul><h2 id="六、基本图算法"><a href="#六、基本图算法" class="headerlink" title="六、基本图算法"></a>六、基本图算法</h2><h3 id="1-基本概念-4"><a href="#1-基本概念-4" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><ul><li><p>图的定义</p><p>图可以表示为一个二元组$G&#x3D;&lt;V,E&gt;$</p><blockquote><p>相关术语：</p><p>$V$表示非空顶点集，其元素称为顶点(Vertex) ，$|V|$表示顶点数；</p><p>$E$表示边集，其元素称为边(Edge)，$|E$表示顶点数 ；</p><p>$e&#x3D;(u,v)$表示一条边，其中$u\in V,v\in V,e\in E$；</p><p>相邻$(Adjacent)$：边$(u,v)$连接的顶点$u$和$v$相邻；</p><p>关联$(Incident)$：边$(u,v)$和其连接的顶点$u(或v)$相互关联。</p></blockquote></li><li><p>相关数据结构</p><ul><li>子图：如果$V’\subseteq V,E’\subseteq E$，则称图$G’&#x3D;&lt;V’,E’&gt;$为G的一个子图</li><li>生成子图：如果$V’&#x3D;V,E’\subseteq E$，则称图$G’&#x3D;&lt;V’,E’&gt;$为G的一个生成子图</li><li>树：连通、无环图$T&#x3D;&lt;V_T,E_T&gt;$，树有$|V_T|-1$条边</li><li>森林：一至多棵树组成的无环图</li></ul></li><li><p>图的表示</p><ul><li>邻接表<ul><li>邻接表是一个包含$|V|$条链表的数组$Adj$；</li><li>在$Adj$中，每个结点$u\in V$有一条链表$Adj[u]$，包含所有与结点$u$之间有边相连的结点$v$；</li><li>用$G.Adj[u]$表示结点$u$在邻接表$Adj$中的邻接链表；</li><li>稀疏图一般用邻接表表示；</li><li>可用于表示有向图也可用于表示无向图，空间需求均为$O(V+E)$。</li></ul></li><li>邻接矩阵<ul><li>将图$G$中的结点编号为$1,2,\dots,|V|$，则图$G$的邻接矩阵是一个$|V|\times|V|$的矩阵$A&#x3D;(a_{ij})$；</li><li>当$(i,j)\in E$，$a_{ij}&#x3D;1$；否则$a_{ij}&#x3D;0$；</li><li>稠密图更倾向于用邻接矩阵表示；</li><li>可以快速判断任意两个结点之间是否有边相连，空间需求为$O(V^2)$。</li></ul></li><li>权重图<ul><li>权重值通常以权重函数$\omega:E\to R$给出；</li><li>用邻接表表示权重图：<ul><li>将边$(u,v)\in E$的权重值$ω(u,v)$存放在$u$的邻接链表结点中, 作为其属性。</li></ul></li><li>用邻接矩阵表示权重图：<ul><li>对于边$(u,v)\in E$，令邻接矩阵$A[u][v]&#x3D;ω(u,v)$；</li><li>若$(u,v)$不是$E$中的边，则令$A[u][v]&#x3D;NIL$，或$\infty$、0。</li></ul></li></ul></li></ul></li></ul><h3 id="2-图的搜索与周游"><a href="#2-图的搜索与周游" class="headerlink" title="2.图的搜索与周游"></a>2.图的搜索与周游</h3><h4 id="1-宽度优先搜索与周游"><a href="#1-宽度优先搜索与周游" class="headerlink" title="(1)宽度优先搜索与周游"></a>(1)宽度优先搜索与周游</h4><h5 id="①宽度优先搜索"><a href="#①宽度优先搜索" class="headerlink" title="①宽度优先搜索"></a>①宽度优先搜索</h5><ul><li><p>算法过程描述</p><ul><li>从结点$v$开始，首先访问结点$v$，给$v$标上已访问标记；</li><li>访问邻接于$v$且目前尚未被访问的所有结点，此时结点$v$被检测，而$v$的邻接结点是新的未被检测结点。将这些结点依次放置到一个称为**未检测结点表的队列(Q)**中；</li><li>若未检测结点表为空，则算法终止；</li><li>否则<strong>取Q的表头</strong>作为下一个检测结点，重复上述过程。直到$Q$为空，算法终止。</li></ul></li><li><p>算法伪代码</p><blockquote><img src="Chp6-BFS-1.png"  /><img src="Chp6-BFS-2.png"  /></blockquote></li><li><p>复杂度分析</p><ul><li>空间复杂度：$s(V,E)&#x3D;\Theta(n)$</li><li>采用邻接表的时间复杂度：$t(V,E)&#x3D;O(n+e)$</li><li>采用邻接矩阵的时间复杂度：$t(V,E)&#x3D;O(n^2)$</li></ul></li></ul><h5 id="②宽度优先周游"><a href="#②宽度优先周游" class="headerlink" title="②宽度优先周游"></a>②宽度优先周游</h5><ul><li><p>若$G$是无向连通图或强连通有向图，则一次调用$BFS$即可完成对$G$的周游。否则，需要多次调用$BFS$</p></li><li><p>算法伪代码</p><blockquote><img src="Chp6-BFT.png" style="zoom:67%;" /></blockquote></li></ul><h5 id="③宽度优先生成树"><a href="#③宽度优先生成树" class="headerlink" title="③宽度优先生成树"></a>③宽度优先生成树</h5><ul><li><p>向前边：$BFS$中由$u$到达未访问结点$w$的边$(u,w)$称为向前边。 </p></li><li><p>宽度优先生成树： 记$T$是$BFS$中处理的所有向前边集合。若$G$是<strong>连通图</strong>，则$BFS$终止时，$T$构成一棵生成树，称为图$G$的宽度优先生成树。</p></li><li><p>对于图$G&#x3D;(V,E)$和源结点$s$，定义图$G$的<strong>前驱子图</strong>为$G_\pi&#x3D;(V_\pi,E_\pi)$，其中$V_\pi&#x3D;{v\in V:v.\pi\ne NIL}\cup{s}$，$E_\pi&#x3D;{(v.\pi,v):v\in V_\pi-{s}}$。该前驱子图构成一棵广度优先树。</p><blockquote><img src="Chp6-BFS-PRINT-PATH.png" style="zoom:67%;" /></blockquote></li></ul><h4 id="2-深度优先搜索与周游"><a href="#2-深度优先搜索与周游" class="headerlink" title="(2)深度优先搜索与周游"></a>(2)深度优先搜索与周游</h4><h5 id="①深度优先搜索"><a href="#①深度优先搜索" class="headerlink" title="①深度优先搜索"></a>①深度优先搜索</h5><ul><li><p>算法过程描述</p><ul><li>从结点$v$开始，首先访问$v$， 给$v$标上已访问标记；</li><li>然后中止对$v$的检测，并从邻接于$v$且尚未被访问的结点的中找出一个结点$w$开始新的检测；</li><li>在$w$被检测后，再恢复对$v$的检测。当所有可到达的结点全部被检测完毕后，算法终止</li></ul></li><li><p>算法伪代码</p><blockquote><img src="Chp6-DFS.png" style="zoom: 67%;" /></blockquote></li><li><p>复杂度分析</p><ul><li>运行时间为$\Theta(V+E)$</li></ul></li></ul><h5 id="②深度优先周游"><a href="#②深度优先周游" class="headerlink" title="②深度优先周游"></a>②深度优先周游</h5><ul><li><p>算法伪代码</p><blockquote><img src="Chp6-DFT.png" style="zoom: 50%;" /></blockquote></li></ul><h4 id="3-深度检索"><a href="#3-深度检索" class="headerlink" title="(3)深度检索"></a>(3)深度检索</h4><ul><li>改造$BFS$算法，用<strong>栈</strong>来保存未被检测的结点</li></ul><h3 id="3-回溯法"><a href="#3-回溯法" class="headerlink" title="3.回溯法"></a>3.回溯法</h3><h4 id="1-n-皇后问题"><a href="#1-n-皇后问题" class="headerlink" title="(1)$n$-皇后问题"></a>(1)$n$-皇后问题</h4><h4 id="2-子集和问题"><a href="#2-子集和问题" class="headerlink" title="(2)子集和问题"></a>(2)子集和问题</h4><h3 id="4-分支-限界法"><a href="#4-分支-限界法" class="headerlink" title="4.分支-限界法"></a>4.分支-限界法</h3><h4 id="1-n-皇后问题-1"><a href="#1-n-皇后问题-1" class="headerlink" title="(1)$n$-皇后问题"></a>(1)$n$-皇后问题</h4><h4 id="2-子集和问题-1"><a href="#2-子集和问题-1" class="headerlink" title="(2)子集和问题"></a>(2)子集和问题</h4><h2 id="七、最小生成树"><a href="#七、最小生成树" class="headerlink" title="七、最小生成树"></a>七、最小生成树</h2><h3 id="1-问题背景"><a href="#1-问题背景" class="headerlink" title="1.问题背景"></a>1.问题背景</h3><ul><li>生成树**(Spanning Tree)** <ul><li>图$T’&#x3D;&lt;V’,E’&gt;$是无向图$G&lt;V,E,W&gt;$的一个生成子图，并且是连通、无环路的(树)</li><li>权重最小的生成树可能不唯一</li></ul></li></ul><h3 id="2-通用框架"><a href="#2-通用框架" class="headerlink" title="2.通用框架"></a>2.通用框架</h3><ul><li><p>新建一个空边集$A$，边集$A$可逐步扩展为最小生成树</p></li><li><p>每次向边集$A$中新增加一条边，需保证边集$A$仍是一个无环图，且仍是最小生成树的子集</p><blockquote><p>$A$是某棵最小生成树$T$边的子集，$A\subseteq T$；</p><p>$A\cup{(u,v}$仍是$T$边的一个子集，则称$(u,v)$是$A$的安全边。</p><p>若每次向边集$A$中新增安全边，可保证边集$A$是最小生成树的子集</p></blockquote></li><li><p>$Generic-MST(G)$</p><blockquote><img src="Chp7-GENERIC-MST.png" style="zoom:50%;" /></blockquote></li><li><p>为了有效辨识安全边，给出以下定义</p><blockquote><p>割：对于连通无向图$G&#x3D;&lt;V,E&gt;$，<strong>割</strong>$(S,V-S)$将顶点集$V$划分为两部分</p><p>给定割$(S,V-S)$和边$(u,v)$，$u\in S,v\in V-S$，称边$(u,v)$<strong>横跨</strong>割$(S,V-S)$</p><p>轻边：横跨割的所有边中，<strong>权重最小</strong>的称为横跨这个割的一条轻边</p><p>如果一个边集$A$中<strong>没有边横跨某割</strong>，则称该割不妨害边集$A$</p></blockquote></li><li><p>安全边辨识定理</p><blockquote><p>给定图$G&#x3D;&lt;V,E&gt;$是一个带权的连通无向图，令$A$为边集$E$的一个子集，且$A$包含在图$G$的某棵最小生成树中。若割$(S,V-S)$是图$G$中不妨害边集$A$的任意割，且$(u,v)$是横跨该割的轻边，则对于边集$A$，边$(u,v)$是其安全边。</p><img src="Chp6-安全边辨识定理.png" style="zoom: 50%;" /><img src="Chp6-安全边辨识定理推论.png" style="zoom: 50%;" /></blockquote></li><li><p>在算法推进的过程中，集合$A$始终保持无环状态；算法执行的任意时刻，图$G_A&#x3D;(V,A)$是一个森林。对于安全边$(u,v)$，由于$A\cup{(u,v)}$必须无环，所以 $(u,v) $连接的是$G_A$中的两个不同连通分量。</p></li></ul><h3 id="3-Prim-算法"><a href="#3-Prim-算法" class="headerlink" title="3.$Prim$算法"></a>3.$Prim$算法</h3><p>贪心策略：集合$A$始终是<strong>一棵树</strong>，每次加入到$A$中的安全边是连接$A$和$A$之外某个结点的边中权重最小的边。</p><ul><li><p><strong>采用的数据结构：最小优先队列</strong>。</p></li><li><p>步骤1：选择任意一个顶点，作为生成树的起始顶点</p></li><li><p>步骤2：保持边集$A$始终为一棵树，选择割$(V_A,V-V_A)$</p></li><li><p>步骤3：选择横跨割$(V_A,V-V_A)$的轻边，添加到边集$A$中</p></li><li><p>步骤4：重复步骤2和步骤3，直至覆盖所有顶点</p></li><li><p>伪代码：</p><blockquote><img src="Chp6-MST-PRIM.png" style="zoom:67%;" /><p>第$1\thicksim 5$行将每个结点的$key$值设为$\infty$（除了根节点$r$的$key$值为0，以便其为第一个被处理的结点），将每个结点的父节点设为$NIL$，并对最小优先队列$Q$进行初始化；</p><p>在每遍$while$循环前，有</p><ul><li>$A&#x3D;{(v,v.\pi):v\in V-{r}-Q}$</li><li>已经加入到最小生成树的结点为集合$V-Q$</li><li>对于所有结点$v\in Q$，如果$v.\pi\ne NIL$，则$v.key&lt;\infty$且$v.key$是连接结点$v$和最小生成树中某个结点的轻边$(v,v.\pi)$的权重。</li></ul><p>第7行找出结点$u\in Q$，该结点是某条横跨割$(V-Q,Q)$的轻边的一个端点，将$u$从$Q$中删除并将$(u,u.\pi)$加入集合$A$中；</p><p>$for$循环对与$u$相邻却不在树中的结点$v$的属性进行更新。</p></blockquote></li><li><p>优先队列</p><ul><li><p>采用二叉堆实现</p></li><li><p><strong>队列中每个元素有一个关键字，依据关键字大小离开队列</strong></p></li></ul></li></ul><table><thead><tr><th align="center">算法</th><th align="center">说明</th><th align="center">时间复杂度</th></tr></thead><tbody><tr><td align="center">$INSERT()$</td><td align="center">向优先队列中插入元素</td><td align="center">$O(\log n)$</td></tr><tr><td align="center">$EXTRACT-MIN(Q)$</td><td align="center">移除优先队列中的最小元素</td><td align="center">$O(\log n)$</td></tr><tr><td align="center">$DECREASE-KEY(u,u.d)$</td><td align="center">更新距离数组，调整优先队列</td><td align="center">$O(\log n)$</td></tr></tbody></table><ul><li><p>算法复杂度</p><ul><li>算法运行时间取决于$Q$的实现方式，如果实现为二叉最小优先队列，则可以使用$BUILD-MIN-HEAP$执行第$1\thicksim 5$行，时间成本为$O(V)$；</li><li>$while$循环一共执行$|V|$次，$EXTRACT-MIN$需要时间成本为$O(\lg V)$，$for$循环执行次数为$O(E)$，第11行隐藏$DECREASE-KEY$操作，在二叉最小堆上执行时间成本为$O(\lg V)$；</li><li>总成本为$O(E\lg V)$。</li></ul></li></ul><h3 id="4-Kruskal-算法"><a href="#4-Kruskal-算法" class="headerlink" title="4.$Kruskal$算法"></a>4.$Kruskal$算法</h3><p>贪心策略：集合$A$始终是<strong>一个森林</strong>，开始时，其结点集就是$G$的结点集，并且$A$是所有单节点树构成的森林。之后每次加入到集合$A$中的安全边是$G$中连接$A$的两个不同分量的权重最小的边。</p><ul><li><p><strong>采用的数据结构：不相交集合</strong>。</p></li><li><p>伪代码：</p><blockquote><img src="Chp6-MST-KRUSKAL.png" style="zoom: 75%;" /><p>第$1\thicksim 3$行将$A$初始化为空集，并创建$|V|$棵树，每棵树只包含一个结点；</p><p>第$5\thicksim 8$行的$for$循环按照权重从低到高的次序对每条边进行检查，如果不在同一棵树中，则加入到集合$A$中，并将两棵树的结点进行合并。</p><p>证明算法保证选择的边为安全边：</p><img src="Chp6-MST-KRUSKAL-安全边证明.png" style="zoom:50%;" /></blockquote></li><li><p>不相交集合</p><ul><li><p>$MAKE-SET(v)$</p><ul><li><p>初始化集合：创建根结点，并设置一条指向自身的边</p></li><li><p>时间复杂度为$O(1)$</p></li><li><p>&#96;&#96;&#96;pseudocode<br>x.parent&#x3D;x<br>return x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- $FIND-SET(v)$</span><br><span class="line"></span><br><span class="line">  - 判定顶点是否在同一集合：回溯查找树根，检查树根是否相同</span><br><span class="line"></span><br><span class="line">  - 时间复杂度为$O(h)$，且$|V|\geq 2^h$，则为$O(\log |V|)$</span><br><span class="line"></span><br><span class="line">  - ```pseudocode</span><br><span class="line">    while x.parent ≠ x do</span><br><span class="line">    x=x.parent</span><br><span class="line">    end</span><br><span class="line">    return x</span><br></pre></td></tr></table></figure></li></ul></li><li><p>$UNION(u,v)$</p><ul><li><p>合并两棵树</p></li><li><p>时间复杂度为$O(h)$，且$|V|\geq 2^h$，则为$O(\log |V|)$</p></li><li><pre><code class="pseudocode">a=FIND-SET(x)b=FIND-SET(y)if a.height ≤ b.height then    if a.height = b.height then        b.height=b.height+1    end    a.parent=bendelse    b.parent=aend</code></pre></li></ul></li></ul></li><li><p>算法复杂度</p><ul><li>将边按照权重升序排序的时间成本为$O(E\log E)$；</li><li>建立不相交集合的时间成本为$O(V)$；</li><li>$while$循环进行了$|E|$次，内部时间复杂度为$O(\log V)$，也即$while$循环总时间复杂度为$O(E\log V)$；</li><li>假设$E&#x3D;O(V^2)$，则总成本为$O(E\lg V)$。</li></ul></li></ul><h3 id="5-算法对比"><a href="#5-算法对比" class="headerlink" title="5.算法对比"></a>5.算法对比</h3><table><thead><tr><th align="center"></th><th align="center">Prim算法</th><th align="center">Kruskal算法</th></tr></thead><tbody><tr><td align="center">核心思想</td><td align="center">保持一颗树，不断扩展</td><td align="center">子树森林，合并为一棵树</td></tr><tr><td align="center">数据结构</td><td align="center">优先队列</td><td align="center">不相交集合</td></tr><tr><td align="center">求解视角</td><td align="center">微观视角，基于当前点选边</td><td align="center">宏观视角，基于全局顺序选边</td></tr><tr><td align="center">算法策略</td><td align="center">采用贪心策略的图算法</td><td align="center">采用贪心策略的图算法</td></tr></tbody></table><h2 id="八、单源点最短路问题"><a href="#八、单源点最短路问题" class="headerlink" title="八、单源点最短路问题"></a>八、单源点最短路问题</h2><h3 id="1-问题背景-1"><a href="#1-问题背景-1" class="headerlink" title="1.问题背景"></a>1.问题背景</h3><p>给定一个带权重的有向图$G&#x3D;(V,E)$和权重函数$\omega:E\rightarrow R$。图中一条路径$p$的权重$\omega(p)$是构成该路径的所有边的权重之和。从结点$u$到结点$v$的最短路径权重定义为$\delta(u,v)$，当没有从$u$到$v$的路径时，$\delta(u,v)&#x3D;\infty$。</p><p>试找出从给定的源点$s\in V$到其他每个结点$v\in V$的最短路径及其最短路径。</p><ul><li><p>单源点最短路问题(单目的地最短路径问题，单节点对最短路径问题)，所有结点对最短路径问题</p></li><li><p>最优子结构性质：两个结点之间的最短路径的任何子路径都是最短的。</p></li><li><p><strong>松弛操作</strong></p><blockquote><p>对于每个结点$v$，维持一个属性$v.d$，记录从源点$s$到结点$v$的最短路径权重的上界。称$v.d$为$s$到$v$的最短路径估计。$INITIALIZE-SINGLE-SOURCE$过程中，对所有$v\in V-{s}$有，$v.d&#x3D;\infty$，$s.d&#x3D;0$。</p><p>松弛操作中，首先进行测试(对$s$到$v$所经过的最后一个中间结点$u$，比较$v.d$和$u.d+w(u,v)$的值)，如果可以<strong>改善</strong>，则更新$v.d$和$v.\pi$。</p><img src="Chp8-RELAX.png"  /><p>时间复杂度为$O(1)$</p></blockquote></li><li><p><strong>松弛操作的性质</strong></p><blockquote><p>三角不等式性质：$\delta(s,v)\leq\delta(s,u)+\omega(u,v)$</p><p>上界性质：$v.d$是$s$到$v$的最短路径权重$\delta(s,v)$的上界</p><p>非路径性质：假定从源结点$s$到给定点$v$之间不存在路径，则该图在由算法$INITIALIZE-SINGLE-SOURCE(G,s)$进行初始化后，有$v.d\geq \delta(s,v)&#x3D;\infty$， 并且该等式作为不变式一直维持到图$G$的所有松弛操作结束。</p></blockquote></li><li><p>若源点$s$无可达负环，则存在源点$s$的单源最短路径(如果有可达负环，则总有更小距离，最终可以松弛到$-\infty$)</p></li></ul><h3 id="2-Bellman-Ford-算法"><a href="#2-Bellman-Ford-算法" class="headerlink" title="2.$Bellman-Ford$算法"></a>2.$Bellman-Ford$算法</h3><ul><li><p>给定带权图$G&#x3D;&lt;V,E,W&gt;$和源点编号$s$，找到源点$s$到所有其他顶点$t$的最短距离$\delta(s,t)$和最短路径$&lt;s,\dots,t&gt;$或存在源点$s$可达的负环。</p></li><li><p>解决挑战1：图中存在负权边时，如何求解单源最短路径? </p><ul><li>每轮对所有边进行松弛，持续迭代$|V|-1$轮。</li></ul></li><li><p>解决挑战2：图中存在负权边时，如何发现源点可达负环?</p><ul><li>若第$|V|$轮仍松弛成功，存在源点$s$可达的负环。</li></ul></li><li><p>伪代码如下</p><blockquote><img src="Chp8-BELLMAN-FORD.png"  /><p>第1行对所有结点的值进行初始化——$\Theta(V)$；</p><p>第$2\thicksim 4$行对每条边进行$|V|-1$次松弛处理，每次循环中都对每条边进行一次松弛操作——$\Theta(E)$，共进行$|V|-1$次循环，总的时间复杂度为$\Theta(VE)$；</p><p>第$5\thicksim 8$行检查图中是否存在权重为负值的环路并返回检查结果——$\O(E)$；</p><p><strong>总的运行时间为$O(VE)$。</strong></p></blockquote></li><li><p>证明在<strong>无可达负环</strong>的情况下可以正确计算最短路径权重</p><blockquote><p>设$G&#x3D;(V,E)$为一个带权重的源点为$s$的有向图，其权重函数为$\omega:E\rightarrow R$，并假定图$G$中<strong>不包含</strong>从源结点$s$可以到达的权重为负值的环路。则$Bellman-ford$算法的第$2\thicksim 4$行的$for$循环在执行$|V|-1$次 之后，对于所有从源结点$s$可以到达的结点$v$有$v.d&#x3D;\delta(s,v)$。</p><p>证明：<strong>利用路径松弛性质</strong>。</p><p>设$G&#x3D;(V,E)$为一个带权重的源点为$s$的有向图，其权重函数为$\omega:E\rightarrow R$，并假定图$G$中<strong>不包含</strong>从源结点$s$可以到达的权重为负值的环路。则对于所有结点$v\in V$，存在一条从源结点$s$到结点$v$的路径当且仅当$BELLMAN-FORD$算法终止时有$v.d&lt;\infty$。</p></blockquote></li><li><p>证明在<strong>有可达负环</strong>的情况下可以返回FALSE值，否则返回TRUE值</p><blockquote><p>假设不包含可达负环时，可以得到$G_\pi$为一棵最短路径树，则当算法终止时，对于所有边$(u,v)\in E$，有$v.d&#x3D;\delta(s,v)\leq \delta(s,u)+\omega(u,v)&#x3D;u.d+\omega(u,v)$，因此返回TRUE；</p><p>假设包含可达负环时，设该环路为$c&#x3D;&lt;v_0,v_1,\dots,v_k&gt;$，其中$v_0&#x3D;v_k$，则有$\sum\limits_{i&#x3D;1}^{k}\omega(v_{i-1},v_i)&lt;0$，假设返回TRUE值，则有$v_i.d\leq v_{i-1}.d+\omega(v_{i-1},v_i)$，这里$i&#x3D;1,2,\dots,k$。将所有不等式相加得到$\sum\limits_{i&#x3D;1}^{k}v_i.d\leq \sum\limits_{i&#x3D;1}^{k}(v_{i-1}.d+\omega(v_{i-1},v_i))&#x3D;\sum\limits_{i&#x3D;1}^{k}v_{i-1}.d+\sum\limits_{i&#x3D;1}^{k}\omega(v_{i-1},v_i)$，而$v_0&#x3D;v_k$，则得到$\sum\limits_{i&#x3D;1}^{k}v_i.d&#x3D;\sum\limits_{i&#x3D;1}^{k}v_{i-1}.d$，又有$\sum\limits_{i&#x3D;1}^{k}\omega(v_{i-1},v_i)\geq 0$，二者矛盾，得证。</p></blockquote></li></ul><h3 id="3-Dijkstra-算法"><a href="#3-Dijkstra-算法" class="headerlink" title="3.$Dijkstra$算法"></a>3.$Dijkstra$算法</h3><ul><li><p>给定带权图$G&#x3D;&lt;V,E,W&gt;$（所有边的权重为正值）和源点编号$s$，找到源点$s$到所有其他顶点$t$的最短距离$\delta(s,t)$和最短路径$&lt;s,\dots,t&gt;$。</p></li><li><p>算法从结点集$V-S$中选择当前最短路径估计最小的结点$u$，将$u$从$Q$中删除，并加入到$S$中，$u.d$就是源结点$s$到$u$的最短路径的 长度。这里$Q$是一个最小优先队列，保存结点集$V-S$。</p></li><li><p>伪代码如下：</p><blockquote><img src="Chp8-DIJKSTRA.png" style="zoom:80%;" /><p>$while$循环执行次数为$|V|$次，$for$循环执行$|E|$次（也即松弛操作次数）。</p></blockquote></li><li><p>证明算法的正确性</p><blockquote><p>采用反证法，假设顶点$u$被添加到$V_A$时，$u.d\ne \delta(s,u)$，而由上界性质有$u.d&gt; \delta(s,u)$。</p><p>应存在一条长度为$\delta(s,u)$的最短路径，设最短路径为$&lt;s,\dots,x,y,\dots,u&gt;$，其中$(x,y)$横跨割$&lt;S,V-S&gt;$，$x\in S$，$y\in V-S$；将$x$加入$S$时，有$x.d&#x3D;\delta(s,x)$，因此$(x,y)$将被松弛，由于$y$是最短路径$p$上的结点，因此有$\delta(s,y)&#x3D;\delta(s,x)+\omega(x,y)&#x3D;x.d+\omega(x,y)$，$y.d\leq x.d+\omega(x,y)$，得到$y.d&#x3D;\delta(s,y)$，因此有$u.d&gt;\delta(s,u)\geq \delta(s,y)&#x3D;y.d$，显然$u$不是下一个被添加结点，矛盾，得证。</p></blockquote></li><li><p>时间复杂度分析</p><ul><li>总运行时间依赖于$Q$的实现，采用二叉堆实现时，每次找到结点$u$需要$O(\lg V)$的时间，总运行时间为$O((V+E)\lg V)$。</li></ul></li></ul><h3 id="4-算法对比"><a href="#4-算法对比" class="headerlink" title="4.算法对比"></a>4.算法对比</h3><table><thead><tr><th align="center"></th><th align="center">广度优先搜索</th><th align="center">Dijkstra算法</th><th align="center">Bellman-Ford算法</th></tr></thead><tbody><tr><td align="center">适用范围</td><td align="center">无权图</td><td align="center">带权图（所有边权重为正）</td><td align="center">带权图</td></tr><tr><td align="center">松弛次数</td><td align="center">——</td><td align="center">$</td><td align="center">E</td></tr><tr><td align="center">数据结构</td><td align="center">队列</td><td align="center">优先队列</td><td align="center">——</td></tr><tr><td align="center">运行时间</td><td align="center">$O(</td><td align="center">V</td><td align="center">+</td></tr></tbody></table><h3 id="5-差分约束系统"><a href="#5-差分约束系统" class="headerlink" title="5.差分约束系统"></a>5.差分约束系统</h3><ul><li><p>线性规划：给定一个$m\times m$的矩阵$A$、一个$m$维的向量$b$和一个$n$维的向量$c$。试找一$n$维向量$x$，使得在$Ax\leq b$的约束下，目标函数$\sum\limits_{i&#x3D;1}^{n}{c_ix_i}$最大。</p></li><li><p>差分约束系统：矩阵$A$的每一行包括一个1和一个-1，其他所有项均为0。则上述问题转化为$m$个涉及$n$个变量的差额限制条件，每个约束条件均为简单的线性不等关系：$x_j-x_i\leq b_k$，这里$1\leq i,j\leq n,i\ne j,1\leq k\leq m$。</p></li><li><p>解的线性性</p><blockquote><p>$x&#x3D;(x_1,x_2,\dots,x_n)$为解，则$x+d&#x3D;(x_1+d,x_2+d,\dots,x_n+d)$也为解；</p></blockquote></li><li><p>约束图</p><blockquote><img src="Chp6-约束图.png" style="zoom: 80%;" /><p>引入额外结点$v_0$，从其出发可到达任何结点，因此节点集合$V$为${v_0,v_1,\dots,v_n}$</p><p>边集合$E$包含代表每个差分约束的边，同时包含$v_0$到其他所有结点的边$(v_0,v_i)$</p><p>如果$x_j-x_i\leq b_k$是一个差分约束条件，则边$(v_i,v_j)$的权重记为$\omega(v_i,v_j)&#x3D;b_k$，而从$v_0$出发到其他结点的边的权重$\omega(v_0,v_j)&#x3D;0$。</p><img src="Chp6-约束图-SAMPLE.png" style="zoom:67%;" /></blockquote></li><li><p>问题的转换</p></li></ul><p>给定差分约束系统$Ax\leq b$，设$G&#x3D;(V,E)$是该差分约束系统所对应的约束图。如果图$G$不包含权重为负值的回路，则$x&#x3D;(\delta(v_0,v_1),\delta(v_0,v_2),\delta(v_0,v_3),\dots,\delta(v_0,v_n))$是该系统的一个可行解。如果图$G$包含权重为负值的回路，则该系统没有可行解。</p><p><img src="/2022/08/19/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0/Chp6-%E7%BA%A6%E6%9D%9F%E5%9B%BE%E8%AF%81%E6%98%8E.png"></p><p>设未知变量的个数$n&#x3D;|x_i|$，不等式个数为m。则使用$Bellman-Ford$算法时，顶点数为$n+1$，边数为$m+n$，因此可以在$O(n^2+mn)$的时间内完成求解。</p><h2 id="九、所有结点对的最短路径问题"><a href="#九、所有结点对的最短路径问题" class="headerlink" title="九、所有结点对的最短路径问题"></a>九、所有结点对的最短路径问题</h2><h3 id="1-问题背景-2"><a href="#1-问题背景-2" class="headerlink" title="1.问题背景"></a>1.问题背景</h3><p>给定一个带权重的有向图$G&#x3D;(V,E)$和权重函数$\omega:E\rightarrow R$。图中一条路径$p$的权重$\omega(p)$是构成该路径的所有边的权重之和。从结点$u$到结点$v$的最短路径权重定义为$\delta(u,v)$，当没有从$u$到$v$的路径时，$\delta(u,v)&#x3D;\infty$。</p><p>求$\forall u,v\in V$，从$u$到$v$的最短路径。</p><h3 id="2-问题分析-6"><a href="#2-问题分析-6" class="headerlink" title="2.问题分析"></a>2.问题分析</h3><ul><li><p>直观上，可以使用$Dijkstra$算法依次求解所有点，此时存在重叠子问题；</p></li><li><p>使用$Dijkstra$算法依次求解所有点的算法复杂度为$O(|V||E|\log|V|)$，对于稠密图有$|E|&#x3D;O(|V|^2)$，因此算法复杂度为$O(|V|^3\log|V|)$；</p></li><li><p>而观察松弛过程发现，具有最优子结构性：</p></li></ul><img src="Chp9-最优子结构示意图.png" style="zoom:50%;" /><ul><li><p>设$D[k,i,j]$表示：可从前$k$个点选点经过时，$i$到$j$的最短距离，则原始问题为$D[|V|,i,j]$</p><blockquote><p>如果不选第$k$个点经过，则$D[k,i,j]&#x3D;D[k-1,i,j]$；</p><p>如果选则第$k$个点经过，则$D[k,i,j]&#x3D;D[k-1,i,k]+D[k-1,k,j]$；</p><p>因此，$D[k,i,j]&#x3D;min{D[k-1,i,k]+D[k-1,k,j],D[k-1,i,j]}$</p></blockquote></li></ul><h3 id="3-自底向上的-Floyd-Warshall-算法"><a href="#3-自底向上的-Floyd-Warshall-算法" class="headerlink" title="3.自底向上的$Floyd-Warshall$算法"></a>3.自底向上的$Floyd-Warshall$算法</h3><ul><li><p>初始化数组</p><ul><li>$D[0,i,i]&#x3D;0$：起点和终点重合，路径长度为0</li><li>$D[0,i,j]&#x3D;e[i,j]$：任意两点直达距离为边权</li></ul></li><li><p>自底向上计算</p><ul><li>按$k$增加的顺序计算，求解时当前层只依赖上一层</li><li>只需要两层表格——待计算和上一次结果</li><li>当**$k&#x3D;i或k&#x3D;j$**时，$D[k,i,j]&#x3D;D[k-1,i,j]$，可以直接覆盖；</li><li>当**$k\ne i且k\ne j$<strong>时，$D[k-1,i,k]+D[k-1,k,j]$和$D[k-1,i,j]$不是相同子问题，当求出$D[k,i,j]$后，$D[k-1,i,j]$不再被使用，可直接覆盖——</strong>求出新值可直接在原位置覆盖，只需存储一层表格**；</li></ul></li><li><p>构建最优解</p><ul><li><p>使用前驱结点矩阵记录经过的中间点，此处使用追踪数组$Rec$记录经过的中间点</p><blockquote><p>$D_k[i,j]&#x3D;D_{k-1}[i,j]$时$Rec$记录为0，表示没有中间点</p><p>$D[k,i,j]&#x3D;D[k-1,i,k]+D[k-1,k,j]$时$Rec$记录为$k$，表示经过中间点$k$</p></blockquote></li></ul></li><li><p>伪代码如下：</p><blockquote><p>$All-Pairs-Shortest-Paths$：</p><img src="Chp9-ALL-PAIRS-SHORTEST-PATHS-1.png" style="zoom: 33%;" /><p>初始化数组$D$和$Rec$；</p><img src="Chp9-ALL-PAIRS-SHORTEST-PATHS-2.png" style="zoom: 33%;" /><p>按照$k$增大的顺序，对于任意一对$i,j$，进行松弛操作，并更新相关数组。</p><p>$Find-Path$：</p><img src="Chp9-FIND-PATH.png" style="zoom:50%;" /></blockquote></li><li><p>算法复杂度为$O(|V|^3)$</p></li></ul><h3 id="4-最短路径算法小结"><a href="#4-最短路径算法小结" class="headerlink" title="4.最短路径算法小结"></a>4.最短路径算法小结</h3><img src="Chp9-最短路径算法小结.png" style="zoom: 80%;" /><h2 id="十、最大流"><a href="#十、最大流" class="headerlink" title="十、最大流"></a>十、最大流</h2><h3 id="1-最大二分匹配"><a href="#1-最大二分匹配" class="headerlink" title="1.最大二分匹配"></a>1.最大二分匹配</h3><h4 id="1-问题描述-10"><a href="#1-问题描述-10" class="headerlink" title="(1)问题描述"></a>(1)问题描述</h4><ul><li><p>给定一个无向图$G&#x3D;&lt;V,E&gt;$，其中$V&#x3D;L\cup R,L\cap R&#x3D;\Phi$，并且每条边$e\in E$有一个端点在$L$中而另一个端点在$R$中，可记为二分图$G&#x3D;&lt;L,R,E&gt;$。</p></li><li><p>图$G&#x3D;&lt;V,E&gt;$中的一个匹配$M$是图$G$边集$E$的子集$(M\subseteq E)$，其中每个顶点至多关联$M$的一条边。</p></li><li><p>现给定二分图$G&#x3D;&lt;L,R,E&gt;$，求出匹配$M&#x3D;{e_1,e_2,\dots,e_k}$，使得$max|M|$，满足$\forall i,j(i\ne j),e_i&#x3D;(l_i,r_i),e_j&#x3D;(l_j,r_j)$，有$l_i\ne l_j$且$r_i\ne r_j$。</p><blockquote><p>即使得匹配数最大且每个顶点至多关联一条边。</p></blockquote></li></ul><h4 id="2-问题分析-7"><a href="#2-问题分析-7" class="headerlink" title="(2)问题分析"></a>(2)问题分析</h4><ul><li><p>直观上，可以遍历$L$中的顶点，依次检查之并与$R$中顶点进行匹配，这种策略可能达不到最大匹配，需要通过撤销边和连接边来增广原匹配。</p></li><li><p>定义<strong>交替路径</strong>：从未匹配顶点出发，依次经过<strong>“非匹配边、匹配边…非匹配边”</strong>形成的路径</p><blockquote><img src="Chp10-交替路径举例.png" style="zoom:67%;" /></blockquote></li><li><p>不断寻找交替路径进行增广</p><ul><li>依次检测左侧顶点，若相邻顶点<strong>未匹配</strong>，则构成交替路径，<strong>直接进行匹配</strong>；若相邻顶点<strong>已经匹配</strong>，则尝试寻找交替路径，<strong>增广成新匹配</strong>；</li><li>直至所有左侧顶点检测完后结束。</li></ul></li><li><p>辅助数组</p><ul><li><p>$matched$表示$L$与$R$中顶点的匹配关系</p><blockquote><p>以$R$中顶点作为下标，如$match[R_2]\leftarrow L_1$</p></blockquote></li><li><p>$color$表示深度优先搜索辅助数组</p><ul><li>white表示未被搜索过，black已被搜索过</li><li>每次搜索前初始化$color$数组</li></ul></li></ul></li></ul><h4 id="3-匈牙利算法"><a href="#3-匈牙利算法" class="headerlink" title="(3)匈牙利算法"></a>(3)匈牙利算法</h4><ul><li><p>伪代码如下：</p><blockquote><p>$Hungarian(G)$</p><img src="Chp10-Hungarian.png" style="zoom: 50%;" /><p>$DFS-Find(v)$</p><img src="Chp10-DFS-Find.png" style="zoom:49%;" /></blockquote></li><li><p>正确性证明：</p><ul><li>命题1：匈牙利算法得到的匹配$M$无交替路径</li><li>命题2：匹配$M$无交替路径$\Leftrightarrow$匹配$M$是最大匹配</li></ul></li></ul><h3 id="2-最大流算法"><a href="#2-最大流算法" class="headerlink" title="2.最大流算法"></a>2.最大流算法</h3><h4 id="1-问题描述-11"><a href="#1-问题描述-11" class="headerlink" title="(1)问题描述"></a>(1)问题描述</h4><ul><li><p>给定有向图$G&#x3D;&lt;V,E,C&gt;$，称之为流网络，$C$代表边权。</p><ul><li><p>源点为$s$，汇点为$t$</p></li><li><p>容量：每条边的边权$c(e)\geq 0$</p></li><li><p>流量：每条边的被占有容量$f(e)\geq 0$</p></li><li><p>剩余容量：对于每条边，剩余容量为$c(e)-f(e)$</p></li><li><p>总流量&#x3D;源点流出量&#x3D;汇点流入量：$|f|&#x3D;\sum_{e\ out\ of\ s}f(e)&#x3D;\sum_{e\ in\ to\ t}f(e)$</p></li><li><p>容量限制：对于边$e\in E$，有$0\leq f(e)\leq c(e)$</p><blockquote><p>边上的流量不应超过边上的容量</p></blockquote></li><li><p>流量守恒：对顶点$v\in V-{s,t}$，$\sum_{e\ out\ of\ s}f(e)&#x3D;\sum_{e\ in\ to\ t}f(e)$</p><blockquote><p>进入某顶点$v$流量和等于流出此顶点流量和</p></blockquote></li></ul></li><li><p>现根据有向图$G&#x3D;&lt;V,E,C&gt;$，源点$s$，汇点$t$，在满足容量限制和流量守恒的约束条件下，求出最大流量。</p></li></ul><h4 id="2-直观策略"><a href="#2-直观策略" class="headerlink" title="(2)直观策略"></a>(2)直观策略</h4><ul><li><p>算法思想</p><ul><li>对于所有边$e\in E$，初始化流量为$f(e)&#x3D;0$</li><li>寻找一条$s$到$t$的路径$P$，此路径上每条边$e$均满足$f(e)&lt;c(e)$</li><li>按路径$P$上的最小剩余容量增加路径流量</li><li>迭代寻找路径$P$直至无法增加路径流量</li></ul></li><li><p><strong>此方法可能无法达到最大流量</strong></p></li><li><p><strong>不足之处：只能扩充边的流量，不能缩减边的流量</strong></p></li><li><p>如果允许缩减边上的容量 ，则可以进一步增大总流量$\rightarrow$如果寻找路径时允许逆向搜索，可以增大总流量$\rightarrow$引入反向边，实现逆向搜索</p></li><li><p>残存网络</p><ul><li><p>定义反向边权重：可缩减流量的上限，也即原始边上的流量$f(e)$</p></li><li><p>定义正向边权重：可扩充流量的上限，也即原始边上的剩余容量$c(e)-f(e)$</p></li><li><p>则根据流网络$G&#x3D;&lt;V,E,C&gt;$和流量$f$，可得残存网络$G_f&#x3D;&lt;V,E_f&gt;$，其中每条边的残存容量满足上述规则</p></li><li><p>定义增广路径：增广路径$p$是残存网络$G_f$中一条从源点$s$到汇点$t$的简单路径(路径上的各顶点均不互相重复)</p></li><li><p>定义增广路径的残存容量：路径上各边残存容量的最小值</p><blockquote><p>流量扩充的最大值为增广路径的残存容量</p></blockquote></li></ul></li></ul><h4 id="3-Ford-Fulkerson-算法"><a href="#3-Ford-Fulkerson-算法" class="headerlink" title="(3)$Ford-Fulkerson$算法"></a>(3)$Ford-Fulkerson$算法</h4><ul><li>算法思想<ul><li>对于所有边$e\in E$，初始化流量为$f(e)&#x3D;0$</li><li><strong>构造残存网络$G_f$，寻找$s$到$t$的增广路径$P$</strong></li><li>按路径$P$的<strong>残存容量</strong>增加路径流量</li><li>迭代寻找路径$P$直至无法增加路径流量</li></ul></li><li>伪代码如下</li><li>算法复杂度</li><li>正确性证明<ul><li>充分性：$f$是最大流$\Rightarrow$残存网络$G_f$中无增广路径</li><li>必要性：$f$是最大流$\Leftarrow$残存网络$G_f$中无增广路径</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 专业核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 专业课程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
