<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【笔记】数据库系统概论笔记</title>
      <link href="/2023/02/22/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/02/22/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="一、绪论"><a href="#一、绪论" class="headerlink" title="一、绪论"></a>一、绪论</h2><h3 id="1-1-数据模型"><a href="#1-1-数据模型" class="headerlink" title="1.1 数据模型"></a>1.1 数据模型</h3><h4 id="1-1-1-数据模型概述"><a href="#1-1-1-数据模型概述" class="headerlink" title="1.1.1 数据模型概述"></a>1.1.1 数据模型概述</h4><ul><li>数据模型是严格定义的一组概念，精确的描述了系统的静态特性、动态特性和完整性约束</li><li>组成要素<ul><li>数据结构：描述系统的<strong>静态特性</strong>，即组成数据库的对象类型</li><li>数据操作：描述系统的<strong>动态特性</strong>，即对数据库中对象的实例允许执行的操作的集合，包括操作及操作规则</li><li>数据的约束条件：数据的约束条件是<strong>完整性规则</strong>的集合，规定数据库状态及状态变化所应满足的条件，以保证数据的正确、有效</li></ul></li><li>类型<ul><li>概念模型</li><li>层次模型</li><li>网状模型</li><li>关系模型</li></ul></li></ul><h4 id="1-1-2-实体-联系模型（E-R模型）"><a href="#1-1-2-实体-联系模型（E-R模型）" class="headerlink" title="1.1.2 实体-联系模型（E-R模型）"></a>1.1.2 实体-联系模型（E-R模型）</h4><ul><li>基本概念<ul><li>世界是由一组称作<strong>实体</strong>的基本对象和这些对象之间的<strong>联系</strong>构成的</li><li>实体(Entity)：客观存在并可相互区别的人、事物、事件和概念</li><li>属性(Attribute)：实体具有的特性</li><li>码(Key、实体标识符)：唯一标识实体的属性集</li><li>域(Domain)：属性的取值范围</li><li>实体型(Entity Type)：用实体名及其属性名集合来抽象刻画同类实体</li><li>实体集(Entity Set)：同型实体的集合，如全体学生，全部的系</li><li>联系(Relationship)：实体(型)内部的联系(组成实体的各属性间)；实体(型)之间的联系(不同的实体集之间)</li></ul></li><li>图形表示<ul><li>矩形框 – 实体型</li><li>菱形框 – 联系类型</li><li>椭圆形框 – 实体型&#x2F;联系类型的属性</li><li>直线 – 实体型与联系之间用直线相连，线旁标注联系的种类(1:1, 1:N, M:N)</li><li>实体集属性中<strong>作为主码的一部分的属性用下划线</strong>来标明</li><li>在1:N的联系中，联系集的主码是n端的主码</li></ul></li></ul><h4 id="1-1-3-由E-R图到数据库设计"><a href="#1-1-3-由E-R图到数据库设计" class="headerlink" title="1.1.3 由E-R图到数据库设计"></a>1.1.3 由E-R图到数据库设计</h4><ul><li>E-R图的设计要点<ul><li>确定实体：实体名、实体属性、实体码</li><li>确定联系：存在性联系、功能性联系、事件联系</li></ul></li><li>E-R图向关系模型的转换<ul><li>实体→关系</li><li>属性→关系的属性</li><li>一对一联系→新的关系，属性为双方的码</li><li>一对一联系→与某一端关系合并，合并后在该端加入另一端关系的码和联系本身的属性，其码不变</li><li>多对多联系→新的关系，其属性为与该联系相连的各实体的码以及联系本身的属性，其码是与该联系相连的各实体的码的组合</li><li>一对多联系→新的关系，其属性为与该联系相连的各实体的码以及联系本身的属性，其码是<strong>n端实体的码</strong></li><li>一对多联系→与n端关系合并，合并后在n端关系加入1端关系的码和联系本身的属性，<strong>n端关系的码不变</strong></li><li>三个或三个以上实体间的多元联系→新的关系，其属性为与该多元联系相连的各实体的码以及联系本身的属性，其码是与该联系相连的各实体的码的组合</li><li>合并具有相同码的关系模式，并去除同义属性</li></ul></li><li>从关系模型到数据库实施<ul><li>定义数据库结构：表结构、视图</li><li>装载数据</li><li>编制与调试应用程序</li><li>数据库试运行</li><li>数据库运行与维护</li></ul></li></ul><h4 id="1-1-4-关系模型"><a href="#1-1-4-关系模型" class="headerlink" title="1.1.4 关系模型"></a>1.1.4 关系模型</h4><ul><li><p>关系模型使用二维表来表示实体及其联系：行、列</p><ul><li>用表格表示实体集，用列表示属性，表结构表示实体的型</li><li>用表间的特定冗余信息表示实体间的联系(主键、外键)</li><li>行、列无序</li><li>列不可再分</li></ul></li><li><p>关系模型中的概念</p><img src="关系模型中的概念.png" style="zoom:30%;" /><ul><li>关系：即通常说的表，用于表示实体以及实体间的联系</li><li>元组：表中的一行即为一个元组</li><li>属性：表中的一列即为一个属性</li><li>主码(key)：图中的某个属性组，它可以唯一确定一个元组</li><li>域(domain)：属性的取值范围</li><li>分量：元组中的一个属性值</li><li>关系模式：对关系的描述，一般表示为：关系名(属性1，属性2，…，属性n)</li></ul></li></ul><h3 id="1-2-数据库系统"><a href="#1-2-数据库系统" class="headerlink" title="1.2 数据库系统"></a>1.2 数据库系统</h3><ul><li>数据库系统：由应用程序、DBMS、操作系统、硬件、人员（数据库管理员DBA）组成</li><li>数据库管理系统DBMS<ul><li>DB定义</li><li>操纵语言及编译程序</li><li>DB运行控制程序</li><li>实用程序</li></ul></li></ul><h2 id="二、关系数据库"><a href="#二、关系数据库" class="headerlink" title="二、关系数据库"></a>二、关系数据库</h2><h3 id="2-1-关系数据结构"><a href="#2-1-关系数据结构" class="headerlink" title="2.1 关系数据结构"></a>2.1 关系数据结构</h3><ul><li>域：一组值的集合，这组值具有相同的数据类型</li><li>笛卡尔积<ul><li>一组域$D_1,D_2,\cdots,D_n$的笛卡尔积为：$D_1\times D_2\times\cdots\times D_n &#x3D; {(d_1 , d_2 , \cdots, d_n) | d_i∈D_i , i&#x3D;1,\cdots,n}$</li><li>笛卡尔积的每个元素$(d_1,d_2,\cdots,d_n)$称作一个$n$元组</li><li>元组的每个值$d_i$称为一个分量</li><li>若$D_i$的基数为$m_i$，则笛卡尔积的基数为$\prod\limits_{i&#x3D;1}^{n}m_i$</li></ul></li><li>关系<ul><li>笛卡尔积$D_1\times D_2\times\cdots\times D_n$的子集叫做在域$D_1,D_2,\cdots,D_n$上的关系，用$R(D_1 , D_2 ,\cdots, D_n )$表示</li><li>关系是笛卡尔积中有意义的子集</li></ul></li><li>候选码<ul><li>关系中的一个属性组，其值能唯一标识一个元组。</li><li>若从该属性组中去掉任何一个属性，它就不具有这一性质</li></ul></li><li>主属性：任何一个候选码中的属性称作主属性</li><li>主码：从一个关系的多个候选码中选定一个作为主码</li><li>外部码：关系R中的一个属性组，它不是R的码，但它与另一个关系S的码相对应，则称这个属性组为R的外部码</li><li>关系模式<ul><li>关系的描述称作关系模式，包括关系名、关系中的属性名、属性向域的映象、属性间的数据依赖关系等</li><li>关系模式是一个5元组$R(U,D,Dom，F)$，其中R是关系名；U是关系的属性集合；D是U中属性所来自的域的集合；DOM是属性向域映射的集合；F是属性间的依赖关系集合</li></ul></li><li>关系数据库<ul><li>在一个应用领域内，用关系表示实体及其联系，关系的集合构成一个关系数据库</li><li>其型是关系模式的集合，即数据库描述，称作数据库的<strong>内涵</strong>(Intension)</li><li>其值是某一时刻关系的集合，称作数据库的<strong>外延</strong>(Extension)</li></ul></li></ul><h3 id="2-2-关系的完整性"><a href="#2-2-关系的完整性" class="headerlink" title="2.2 关系的完整性"></a>2.2 关系的完整性</h3><ul><li>实体完整性：若属性A是基本关系R的主属性，则A不能取空值</li><li>参照完整性：如果关系$R_2$的外部码$F_k$与关系$R_1$的主码$P_k$相对应，则$R_2$中的每一个元组的$F_k$值或者等于$R_1$中某个元组的$P_k$值，或者为空值</li><li>用户定义的完整性:用户针对具体的应用环境定义的完整性约束条件</li></ul><h3 id="2-3-关系代数"><a href="#2-3-关系代数" class="headerlink" title="2.3 关系代数"></a>2.3 关系代数</h3><ul><li><p>关系代数是一种抽象的查询语言，通过对关系的运算来表达查询操作</p></li><li><p>基本概念</p><ul><li>如果两个关系的属性数目相同，且各属性的域相同，则两个关系是相容的</li><li>元组的连串：若$r&#x3D;(r_1,r_2,\cdots,r_n)$，$s&#x3D;(s_1,s_2,\cdots,s_n)$则定义二者的连串$\widehat{AB}&#x3D;(r_1,r_2,\cdots,r_n,s_1,s_2,\cdots,s_n)$</li><li>给定关系模式$R(A_1 , A_2 ,\cdots, A_n)$，设$R$是它的一个具体的关系，$t\in R$是关系的一个元组<ul><li>$A&#x3D;{A_{i1},A_{i2},\cdots,A_{ik}}\subseteq {A_a,A_2,\cdots,A_n}$是<strong>属性列</strong>，$\overline{A}$表示${A_1,A_2,\cdots,A_n}$去掉$A$后剩余的属性组</li><li>$t[A_i]$表示元组$t$中相应于属性$A_i$的一个<strong>分量</strong></li><li>$t[A]&#x3D;{t[A_{i1}],t[A_{i2}],\cdots,t[A_{ik}]}$表示元组$t$在属性列$A$上各分量的集合</li><li>给定关系$R(X,Z)$，$X$和$Z$为属性组。当$t[X]&#x3D;x$时，$x$在$R$中的<strong>象集</strong>为：$Z_X&#x3D;{t[Z]|t∈ R,t[X]&#x3D;x}$ ,它表示$R$中属性组$X$上值为$x$的诸元组在$Z$上分量的集合</li></ul></li></ul></li><li><p>集合运算符（进行集合运算的两个关系必须相容）：并$\cup$、交$\cap$、差$-$</p></li><li><p>关系运算符</p><ul><li><p>笛卡尔积$\times$</p><ul><li>设两个关系R，S，其度分别为n，m，则它们的广义笛卡尔积为$R\times S&#x3D;{\widehat{rs}|r\in R\land s\in S}$</li></ul></li><li><p>选择$\sigma$</p><ul><li>$\sigma_F(R)&#x3D;{t|t\in R\land F(t)&#x3D;true}$</li><li>即$\sigma$运算的结果为满足条件F的元组集合</li></ul></li><li><p>投影$\Pi$</p><ul><li>$\Pi_A(R)&#x3D;{t[A]|t\in R}$，其中$A$为$R$的属性列</li><li>投影结果中要去掉相同的行</li></ul></li><li><p>连接$\Join$</p><ul><li><p>$R\underset{A\Theta B}\Join S&#x3D;{\widehat{rs}|r\in R\land s\in S\land r[A]\Theta S[B]}$</p></li><li><p>$R\underset{A\Theta B}\Join S&#x3D;\sigma_{R[A]\Theta S[B]}(R\times S)$</p></li><li><p>即从两个关系的笛卡尔积中选取给定属性间满足一定条件的元组</p></li><li><p>等值连接：从两个关系的广义笛卡儿积中选取满足某一等值条件的元组，两个关系<strong>可以没有相同属性列</strong></p></li><li><p>自然连接：<strong>特殊的等值连接</strong>，从两个关系的广义笛卡儿积中选取在<strong>相同属性列</strong>上取值相等的元组，并<strong>去掉重复的列</strong></p></li></ul></li><li><p>除$÷$</p><ul><li>设有关系$R(X,Y)$和$S(Y,Z)$，则$R÷Z$可根据如下过程得到</li><li>在关系$S$中对$Y$做投影，得到$\Pi_Y(Z)$</li><li>关系$R$在属性列$X$上作取消重复值的投影，得到$\Pi_X(R)$</li><li>判断$\Pi_X(R)$中$x_i$的象集$Y_i$是否包含$\Pi_Y(Z)$，如果包含，则最终结果中包含$x_i$</li><li>即$R÷Z$表示【$R$在$X$上分量值$x$的象集$Y_x$包含$S$在$Y$上投影的集合】在$X$属性列上的投影</li></ul></li></ul></li><li><p>比较运算符：&lt;、≤、＞、≥、≠、&#x3D;</p></li><li><p>逻辑运算符：与$\land$、或$\lor$、非$\lnot$</p></li></ul><h2 id="三、SQL语言"><a href="#三、SQL语言" class="headerlink" title="三、SQL语言"></a>三、SQL语言</h2><h3 id="3-1-数据库、表、索引、完整性约束"><a href="#3-1-数据库、表、索引、完整性约束" class="headerlink" title="3.1 数据库、表、索引、完整性约束"></a>3.1 数据库、表、索引、完整性约束</h3><ul><li><p>数据库、表、索引的创建、修改、删除</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#创建数据库</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE <span class="operator">&lt;</span>数据库名<span class="operator">&gt;</span></span><br><span class="line">#删除数据库</span><br><span class="line"><span class="keyword">DROP</span> DATABASE <span class="operator">&lt;</span>数据库名<span class="operator">&gt;</span></span><br><span class="line">#指定数据库</span><br><span class="line">DATABASE <span class="operator">&lt;</span>数据库名<span class="operator">&gt;</span></span><br><span class="line">USE <span class="operator">&lt;</span>数据库名<span class="operator">&gt;</span></span><br><span class="line">#创建表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] <span class="operator">&lt;</span>数据表名<span class="operator">&gt;</span></span><br><span class="line">(</span><br><span class="line">    <span class="operator">&lt;</span>列定义列表<span class="operator">&gt;</span></span><br><span class="line">    <span class="operator">&lt;</span>表约束列表<span class="operator">&gt;</span></span><br><span class="line">)</span><br><span class="line">#修改表</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>数据表名<span class="operator">&gt;</span> <span class="operator">&lt;</span>修改子句列表<span class="operator">&gt;</span></span><br><span class="line">#删除表</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">#创建索引</span><br><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span>] [CLUSTER] INDEX <span class="operator">&lt;</span>索引名<span class="operator">&gt;</span> <span class="keyword">ON</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> (<span class="operator">&lt;</span>列名列表:<span class="operator">&lt;</span>列名<span class="operator">&gt;</span> [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>]<span class="operator">&gt;</span>)</span><br><span class="line">#删除索引</span><br><span class="line"><span class="keyword">DROP</span> INDEX <span class="operator">&lt;</span>索引名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>表的列定义</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> [列级约束列表<span class="operator">|</span><span class="keyword">NOT</span> <span class="keyword">NULL</span><span class="operator">|</span>AUTO_INCREMENT<span class="operator">|</span><span class="keyword">DEFAULT</span> <span class="operator">&lt;</span>默认值<span class="operator">&gt;</span>]</span><br></pre></td></tr></table></figure></li><li><p>表的约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#主码约束</span><br><span class="line">#单属性主码：列级约束方式</span><br><span class="line"><span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> <span class="keyword">PRIMARY</span> KEY</span><br><span class="line">#单属性主码：表级约束方式</span><br><span class="line">[CONSTRANIT [约束名]] <span class="keyword">PRIMARY</span> KEY (<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>)</span><br><span class="line">#多属性主码：表级约束方式</span><br><span class="line">[CONSTRANIT [约束名]] <span class="keyword">PRIMARY</span> KEY (<span class="operator">&lt;</span>列名列表<span class="operator">&gt;</span>)</span><br><span class="line">#唯一性约束</span><br><span class="line">#列级约束方式</span><br><span class="line"><span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> <span class="keyword">UNIQUE</span></span><br><span class="line">#表级约束方式</span><br><span class="line">[CONSTRANIT [约束名]] <span class="keyword">UNIQUE</span> (<span class="operator">&lt;</span>列名列表<span class="operator">&gt;</span>)</span><br><span class="line">#外码约束</span><br><span class="line">#列级约束方式</span><br><span class="line"><span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> <span class="keyword">REFERENCES</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>(<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>)</span><br><span class="line">#表级约束方式</span><br><span class="line">[CONSTRANIT [约束名]] <span class="keyword">FOREIGN</span> KEY (<span class="operator">&lt;</span>列名列表<span class="operator">&gt;</span>) <span class="keyword">REFERENCES</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>(<span class="operator">&lt;</span>列名列表<span class="operator">&gt;</span>)</span><br><span class="line">#检查约束</span><br><span class="line">#列级约束方式</span><br><span class="line"><span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> <span class="keyword">CHECK</span> (<span class="operator">&lt;</span>检查条件<span class="operator">&gt;</span>)</span><br><span class="line">#表级约束方式</span><br><span class="line">[CONSTRANIT [约束名]] <span class="keyword">CHECK</span> (<span class="operator">&lt;</span>检查条件<span class="operator">&gt;</span>)</span><br></pre></td></tr></table></figure></li><li><p>表的修改子句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#添加约束</span><br><span class="line"><span class="keyword">ADD</span> <span class="operator">&lt;</span>表级约束子句<span class="operator">&gt;</span></span><br><span class="line">#删除约束</span><br><span class="line"><span class="keyword">DROP</span> &#123;<span class="keyword">CHECK</span><span class="operator">|</span><span class="keyword">CONSTRAINT</span><span class="operator">|</span><span class="keyword">FOREIGN</span> KEY&#125; <span class="operator">&lt;</span>约束名<span class="operator">&gt;</span></span><br><span class="line">#删除主码</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PRIMARY</span> KEY</span><br><span class="line">▲注:等同于语句<span class="keyword">DROP</span> INDEX &quot;PRIMARY&quot; <span class="keyword">on</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">#删除唯一性约束</span><br><span class="line">▲注:等同于语句<span class="keyword">DROP</span> INDEX <span class="operator">&lt;</span>索引名<span class="operator">&gt;</span> <span class="keyword">on</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>断言</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#创建断言，其中<span class="keyword">CHECK</span>子句类似于<span class="keyword">WHERE</span>子句</span><br><span class="line"><span class="keyword">CREATE</span> ASSERTION <span class="operator">&lt;</span>断言名<span class="operator">&gt;</span> <span class="operator">&lt;</span><span class="keyword">CHECK</span>子句<span class="operator">&gt;</span></span><br><span class="line">#删除断言</span><br><span class="line"><span class="keyword">DROP</span> ASSERTION <span class="operator">&lt;</span>断言名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2-数据查询"><a href="#3-2-数据查询" class="headerlink" title="3.2 数据查询"></a>3.2 数据查询</h3><ul><li><p>查询子句的基本结构</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">&lt;</span>列组合<span class="operator">&gt;</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>数据表列表<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">WHERE</span> <span class="operator">&lt;</span>行条件子句<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>分组子句<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">HAVING</span> <span class="operator">&lt;</span>组条件子句<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>排序子句<span class="operator">&gt;</span>]</span><br></pre></td></tr></table></figure><ul><li>根据WHERE子句的检索条件，从FROM子句指定的基本表或视图中选取满足条件的元组，再按照SELECT子句中指定的列，投影得到结果表</li><li>如果有GROUP子句，则将查询结果按照&lt;列名1&gt;相同的值进行分组</li><li>如果GROUP子句后有HAVING短语，则只输出满足HAVING条件的元组</li><li>如果有ORDER子句，查询结果还要按照&lt;列名2&gt;的值进行排序</li></ul></li><li><p>SELECT子句</p><ul><li><p>目标列形式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#全部列</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> SC</span><br><span class="line">#列名</span><br><span class="line"><span class="keyword">SELECT</span> Sno,Score <span class="keyword">from</span> SC</span><br><span class="line">#算术表达式，可包含<span class="operator">+</span>、<span class="operator">-</span>、<span class="operator">*</span>、<span class="operator">/</span>、百分数</span><br><span class="line"><span class="keyword">SELECT</span> Sno,Score<span class="operator">*</span><span class="number">1.2</span> <span class="keyword">from</span> SC</span><br><span class="line">#聚集函数：SUM、AVG</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(Score) <span class="keyword">from</span> SC</span><br></pre></td></tr></table></figure></li><li><p>重复元组的处理</p><ul><li><p>缺省或关键字ALL表示保留重复元组</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span>] <span class="operator">&lt;</span>列组合<span class="operator">&gt;</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>数据表列表<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>关键字DISTINCT表示去除重复元组</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="operator">&lt;</span>列组合<span class="operator">&gt;</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>数据表列表<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>列的重命名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#旧目标列可以是列名、表达式、聚集函数名</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">&lt;</span>旧目标列<span class="operator">&gt;</span> <span class="keyword">AS</span> <span class="operator">&lt;</span>新列名<span class="operator">&gt;</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>数据表列表<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>FROM子句</p><ul><li><p>限定：同时指定一个或多个表（或视图）时，如果选择列表中存在同名列，这时应使用对象名限定这些列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> username,city.cityid <span class="keyword">FROM</span> <span class="keyword">user</span>,city <span class="keyword">WHERE</span> user.cityid<span class="operator">=</span>city.cityid</span><br></pre></td></tr></table></figure></li><li><p>表的重命名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.cityid <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">AS</span> A</span><br></pre></td></tr></table></figure></li><li><p>子查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CS.name <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> S <span class="keyword">WHERE</span> dept<span class="operator">=</span>&quot;CS&quot;) <span class="keyword">AS</span> CS <span class="keyword">WHERE</span> CS.age<span class="operator">&gt;</span><span class="number">20</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>WHERE子句</p><ul><li><p>比较运算符</p></li><li><p>逻辑运算符：AND、OR、NOT</p></li><li><p>BETWEEN条件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname <span class="keyword">FROM</span> SC <span class="keyword">WHERE</span> Score <span class="keyword">BETWEEN</span> <span class="number">80</span> <span class="keyword">AND</span> <span class="number">100</span></span><br></pre></td></tr></table></figure></li><li><p>模糊查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#<span class="operator">%</span>匹配零个以上字符、_匹配单个字符、\转义字符</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> SC <span class="keyword">WHERE</span> Sname <span class="keyword">LIKE</span> <span class="string">&#x27;张%&#x27;</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> SC <span class="keyword">WHERE</span> Sname <span class="keyword">LIKE</span> <span class="string">&#x27;张\_%&#x27;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>ORDER子句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT &lt;列组合&gt; FROM &lt;数据表列表&gt; ORDER BY &lt;列名列表:&lt;列名&gt; [ASC|DESC]&gt;</span><br></pre></td></tr></table></figure></li><li><p>GROUP与HAVING子句</p><ul><li>GROUP BY：将表中的元组按指定列上值相等的原则分组，然后在每一分组上使用聚集函数，得到单一值</li><li>HAVING：对分组进行选择，可以针对聚集函数的结果值进行筛选，作用于分组计算的结果集</li></ul></li><li><p>空值</p><ul><li>如果null参与算术运算，则该算术表达式的值为null</li><li>如果null参与比较运算，则结果可视为false</li><li>如果null参与聚集运算，则除count(*)之外其它聚集函数都忽略null</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname <span class="keyword">FROM</span> SC <span class="keyword">WHERE</span> Score <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">SELECT</span> Sname <span class="keyword">FROM</span> SC <span class="keyword">WHERE</span> Score <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure></li><li><p>连接查询</p><ul><li>等值连接：某两张表在某个属性上相等</li><li>自然连接：在等值连接中去掉重复的属性列</li><li>自身连接：一个表与其自己进行连接，同一个数据表取不同别名</li><li>外连接：将悬浮元组包含在连接结果中的连接</li></ul></li><li><p>嵌套查询</p><ul><li><p>子查询是嵌套在另一查询中的 Select-From-Where 表达式</p></li><li><p>子查询中不能使用 Order By 子句，Order By子句只能对最终查询结果进行排序</p></li><li><p>集合成员资格</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#判断表达式的值是否在子查询的结果中</span><br><span class="line"><span class="operator">&lt;</span>表达式<span class="operator">&gt;</span> [<span class="keyword">NOT</span>] <span class="keyword">IN</span> <span class="operator">&lt;</span>子查询<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>集合之间的比较</p><ul><li><p>当用户能确切知道内层查询返回的是单值时，可以用&gt;、&lt;、＝、&gt;＝、&lt;＝、!＝或&lt;&gt;等比较运算符</p></li><li><p>ANY：表达式的值至少与子查询结果中的一个值相比满足</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname <span class="keyword">FROM</span> Student <span class="keyword">WHERE</span> Sage <span class="operator">&lt;</span> <span class="keyword">ANY</span> (<span class="keyword">SELECT</span> Sage <span class="keyword">FROM</span>  Student <span class="keyword">WHERE</span> Sdept＝’<span class="keyword">IS</span>’)</span><br></pre></td></tr></table></figure></li><li><p>ALL：表达式的值与子查询结果中的所有的值相比都满足</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname <span class="keyword">FROM</span> Student <span class="keyword">WHERE</span> Sage <span class="operator">&lt;</span> <span class="keyword">ALL</span> (<span class="keyword">SELECT</span> Sage <span class="keyword">FROM</span>  Student <span class="keyword">WHERE</span> Sdept＝’<span class="keyword">IS</span>’)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>相关嵌套查询</p><ul><li>Exists：测试该子查询的结果是否有元组，带有Exists的子查询不返回任何数据，只产生True&#x2F;False</li></ul></li></ul></li><li><p>集合查询</p><ul><li>集合并：union</li><li>集合交：intersect</li><li>集合差：minus</li><li>集合操作自动去除重复元组，如果要保留重复元组，必须用all关键词指明</li></ul></li></ul><h3 id="3-3-数据的增删改"><a href="#3-3-数据的增删改" class="headerlink" title="3.3 数据的增删改"></a>3.3 数据的增删改</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#插入单个元组</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> [(<span class="operator">&lt;</span>列列表<span class="operator">&gt;</span>)] <span class="keyword">VALUES</span>(<span class="operator">&lt;</span>值列表<span class="operator">&gt;</span>)</span><br><span class="line">#插入子查询结果(要求子查询结果的模式和要插入的模式相同)</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> [(<span class="operator">&lt;</span>列列表<span class="operator">&gt;</span>)] (<span class="operator">&lt;</span>子查询结果集<span class="operator">&gt;</span>)</span><br><span class="line">#删除元组(没有<span class="keyword">WHERE</span>语句时，删除所有元组)</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> [<span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span>]</span><br><span class="line">#更新元组</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">SET</span> <span class="operator">&lt;</span>列修改列表:<span class="operator">&lt;</span>列名<span class="operator">&gt;=</span>表达式<span class="operator">|</span>子查询<span class="operator">&gt;</span> [<span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span>]</span><br><span class="line">#跨表更新</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">SET</span> <span class="operator">&lt;</span>列修改列表:<span class="operator">&lt;</span>列名<span class="operator">&gt;=</span>表达式<span class="operator">|</span>子查询<span class="operator">&gt;</span> [<span class="keyword">FROM</span> <span class="operator">&lt;</span>表列表<span class="operator">&gt;</span>][<span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span>]</span><br></pre></td></tr></table></figure><h3 id="3-4-视图"><a href="#3-4-视图" class="headerlink" title="3.4 视图"></a>3.4 视图</h3><ul><li><p>视图是从一个或几个基本表（或视图）导出的一个虚表</p></li><li><p>数据库中只存放视图的定义而不存放视图的数据</p></li><li><p>当基表中的数据发生变化时从视图中查出的数据也随之改变</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#创建视图</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> <span class="operator">&lt;</span>视图名<span class="operator">&gt;</span> <span class="keyword">AS</span> <span class="operator">&lt;</span>查询表达式<span class="operator">&gt;</span> [<span class="keyword">WITH</span> <span class="keyword">CHECK</span> OPTION]</span><br><span class="line">#删除视图</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> <span class="operator">&lt;</span>视图名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>视图的属性名缺省为子查询结果中的属性名，也可以显式指明</p></li><li><p>当对视图进行insert，update时，要检查是否满足with check option条件</p></li><li><p>视图更新</p><ul><li>对视图的更新，最终要转换为<strong>对基表的更新</strong></li><li>SELECT子句中的目标列不能包含聚集函数</li><li>SELECT子句中不能使用UNIQUE或DISTINCT关键字</li><li>不能包括GROUP BY子句</li><li>不能包括经算术表达式计算出来的列</li><li>对于行列子集视图可以更新（视图是从单个基本表使用选择、投影操作导出的，并且包含了基本表的主码）</li></ul></li></ul><h3 id="3-5-触发器、存储过程、用户自定义函数"><a href="#3-5-触发器、存储过程、用户自定义函数" class="headerlink" title="3.5 触发器、存储过程、用户自定义函数"></a>3.5 触发器、存储过程、用户自定义函数</h3><ul><li><p>触发器</p><ul><li><p>触发器是与某个表绑定的命名存储对象，由一组SQL语句组成</p></li><li><p>当该表发生某个操作时，触发器将会被触发执行，一般用于维护数据库<strong>完整性规则</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#创建触发器</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> <span class="operator">&lt;</span>触发器名<span class="operator">&gt;</span></span><br><span class="line">&#123;BEFORE<span class="operator">|</span>AFTER&#125;</span><br><span class="line">&#123;<span class="operator">&lt;</span>触发事件列表，以<span class="keyword">OR</span>连接<span class="operator">&gt;</span>&#125;</span><br><span class="line"><span class="keyword">ON</span> <span class="operator">&lt;</span>数据表名<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">FROM</span> <span class="operator">&lt;</span>引用数据表名<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">FOR</span> [<span class="keyword">EACH</span>] &#123;<span class="type">ROW</span><span class="operator">|</span>STATEMENT&#125;]</span><br><span class="line">[<span class="keyword">WHEN</span> (<span class="operator">&lt;</span>条件<span class="operator">&gt;</span>)]</span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">PROCEDURE</span> <span class="operator">&lt;</span>函数名<span class="operator">&gt;</span>(<span class="operator">&lt;</span>参数列表<span class="operator">&gt;</span>)</span><br><span class="line">#删除触发器</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> <span class="operator">&lt;</span>触发器名<span class="operator">&gt;</span> <span class="keyword">ON</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>行级触发器：数据每发生一次操作即执行一次触发器动作，如UPDATE多行的某个字段时</p></li><li><p>语句级触发器（默认）：触发事件语句执行完后才执行一次触发器动作</p></li><li><p>触发器的激活</p><ul><li>执行该表上的BEFORE触发器</li><li>执行激活触发器的SQL语句</li><li>执行该表上的AFTER触发器</li></ul></li></ul></li><li><p>游标</p><ul><li><p>SQL操作都是面向集合的，即操作的对象以及运算的结果均为集合</p></li><li><p>游标(CURSOR)相当于一个存储于内存的带有指针的表，每次可以存取指针指向的一行数据，并将指针向前推进一行</p></li><li><p>使用游标可以遍历某个查询语句的结果集</p></li><li><p>游标不可滚动，即只能依次遍历，不能反向遍历，不能跳跃遍历，不能随机访问，不能修改游标中的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#定义变量</span><br><span class="line"><span class="keyword">DECLARE</span> <span class="operator">&lt;</span>变量名<span class="operator">&gt;</span> <span class="operator">&lt;</span>变量数据类型<span class="operator">&gt;</span> [<span class="keyword">DEFAULT</span> <span class="operator">&lt;</span>默认值<span class="operator">&gt;</span>]</span><br><span class="line">#定义游标，游标的数据集将为查询语句的结果</span><br><span class="line"><span class="keyword">CURSOR</span> <span class="operator">&lt;</span>游标名<span class="operator">&gt;</span> <span class="keyword">FOR</span> <span class="operator">&lt;</span>查询语句<span class="operator">&gt;</span></span><br><span class="line">#打开定义过的游标，并初始化指针</span><br><span class="line"><span class="keyword">OPEN</span> <span class="operator">&lt;</span>游标名<span class="operator">&gt;</span></span><br><span class="line">#读取游标，将读取到的一行数据写入变量列表中</span><br><span class="line">#读取未打开的游标会出错</span><br><span class="line"><span class="keyword">FETCH</span> [[NEXT] <span class="keyword">FROM</span>] <span class="operator">&lt;</span>游标名<span class="operator">&gt;</span> <span class="keyword">INTO</span> <span class="operator">&lt;</span>变量列表<span class="operator">&gt;</span></span><br><span class="line">#关闭游标，关闭未打开的游标会出错</span><br><span class="line"><span class="keyword">CLOSE</span> <span class="operator">&lt;</span>游标名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>存储过程</p><ul><li><p>存储过程是一个SQL语句组合</p></li><li><p>在创建时进行预编译，首次被调用时进行解析，以后再被调用，则可直接执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#创建存储过程</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> <span class="operator">&lt;</span>存储过程名称<span class="operator">&gt;</span></span><br><span class="line">([@<span class="operator">&lt;</span>参数名称<span class="operator">&gt;</span> <span class="operator">&lt;</span>参数数据类型<span class="operator">&gt;</span> [<span class="type">VARYING</span>][<span class="operator">=</span><span class="operator">&lt;</span>默认值<span class="operator">&gt;</span>][<span class="keyword">OUT</span><span class="operator">|</span>OUTPUT]])</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line">[定义变量列表]</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">SQL</span>语句组合<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">#执行存储过程</span><br><span class="line">[<span class="keyword">EXECUTE</span><span class="operator">|</span><span class="keyword">EXEC</span>] <span class="operator">&lt;</span>存储过程名称<span class="operator">&gt;</span> <span class="operator">&lt;</span>参数列表<span class="operator">&gt;</span></span><br><span class="line">#删除存储过程</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> <span class="operator">&lt;</span>存储过程名称<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>数据传递方式</p><ul><li>输入参数</li><li>输出参数使用OUTPUT标识</li><li>RETURN语句返回单个int型数据，如操作过程中受影响的行数，错误码</li><li>RETURN不能返回NULL，若试图返回NULL，将生成警告信息并返回0</li></ul></li></ul></li><li><p>用户自定义函数</p><ul><li><p>自定义函数可以像数据库内部函数一样在SQL语句中使用，如WHERE子句、SELECT子句、表达式中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> <span class="operator">&lt;</span>函数名<span class="operator">&gt;</span></span><br><span class="line">([参数列表:<span class="operator">&lt;</span>参数名称<span class="operator">&gt;</span> <span class="operator">&lt;</span>参数数据类型<span class="operator">&gt;</span>])</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="operator">&lt;</span>返回数据类型<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="operator">&lt;</span>函数体<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">RETURN</span> <span class="operator">&lt;</span>返回值:常量<span class="operator">/</span>表达式<span class="operator">/</span>语句查询结果<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-6-安全性控制"><a href="#3-6-安全性控制" class="headerlink" title="3.6 安全性控制"></a>3.6 安全性控制</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#创建用户</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="operator">&lt;</span>用户名<span class="operator">&gt;</span> <span class="keyword">with</span> PASSWORD <span class="operator">&lt;</span>密码<span class="operator">&gt;</span></span><br><span class="line">#创建角色，角色是权限的集合</span><br><span class="line"><span class="keyword">CREATE</span> ROLE [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] <span class="operator">&lt;</span>角色列表<span class="operator">&gt;</span></span><br><span class="line">#删除角色，拥有该角色的用户失去该角色定义的权限集合</span><br><span class="line"><span class="keyword">DROP</span> ROLE [IF <span class="keyword">EXISTS</span>] <span class="operator">&lt;</span>角色列表<span class="operator">&gt;</span></span><br><span class="line">#授权，其中<span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION表示获得权限的用户可以把权限授予他人</span><br><span class="line"><span class="keyword">GRANT</span> <span class="operator">&lt;</span>角色名<span class="operator">&gt;</span> <span class="keyword">TO</span> <span class="operator">&lt;</span>用户列表<span class="operator">&gt;</span> [<span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION]</span><br><span class="line"><span class="keyword">GRANT</span> <span class="operator">&lt;</span>权限列表<span class="operator">&gt;</span> [<span class="keyword">ON</span> <span class="operator">&lt;</span>对象类型<span class="operator">&gt;</span> <span class="operator">&lt;</span>对象名<span class="operator">&gt;</span>] <span class="keyword">TO</span> <span class="operator">&lt;</span>用户列表<span class="operator">&gt;</span> [<span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION]</span><br><span class="line">#收回，若用户已将权限授予其它用户，则也一并收回</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="operator">&lt;</span>权限列表<span class="operator">&gt;</span> [<span class="keyword">ON</span> <span class="operator">&lt;</span>对象类型<span class="operator">&gt;</span> <span class="operator">&lt;</span>对象名<span class="operator">&gt;</span>] <span class="keyword">FROM</span> <span class="operator">&lt;</span>用户列表<span class="operator">|</span>PUBLIC<span class="operator">&gt;</span></span><br><span class="line">#权限列表</span><br><span class="line"><span class="keyword">ALL</span> PRIVILIGES</span><br><span class="line">&#123;<span class="keyword">SELECT</span><span class="operator">|</span><span class="keyword">UPDATE</span>&#125; [(<span class="operator">&lt;</span>字段列表<span class="operator">&gt;</span>)]</span><br><span class="line">&#123;<span class="keyword">INSERT</span><span class="operator">|</span><span class="keyword">DELETE</span><span class="operator">|</span><span class="keyword">ALTER</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="3-7-并发控制"><a href="#3-7-并发控制" class="headerlink" title="3.7 并发控制"></a>3.7 并发控制</h3><h4 id="3-7-1-并发控制概述"><a href="#3-7-1-并发控制概述" class="headerlink" title="3.7.1 并发控制概述"></a>3.7.1 并发控制概述</h4><ul><li>并发控制的必要性<ul><li>事务串行执行：每个时刻只有一个事务运行，其他事务必须等到这个事务结束以后方能运行，不能充分利用系统资源，发挥数据库共享资源的特点</li><li>交叉并发方式：单处理机系统中，并行事务的并行操作轮流交叉运行</li><li>同时并发方式：多处理机系统中，可实现多个事务真正的并行运行</li></ul></li><li>并发控制带来的数据不一致性<ul><li>丢失修改<ul><li>两个事务T1和T2读入同一数据并修改，T2的提交结果破坏了T1提交的结果，导致T1的修改被丢失</li></ul></li><li>不可重复读<ul><li>事务T1读取某一数据后，事务T2对其做了修改，当事务T1再次读该数据时，得到与前一次不同的值</li><li>事务T1按一定条件从数据库中读取了某些数据记录后，事务T2删除了其中部分记录，当T1再次按相同条件读取数据时，发现某些记录消失了</li><li>事务T1按一定条件从数据库中读取某些数据记录后，事务T2插入了一些记录，当T1再次按相同条件读取数据时，发现多了一些记录。</li></ul></li><li>读脏数据<ul><li>事务T1修改某一数据，并将其写回磁盘，事务T2读取同一数据后，T1由于某种原因被撤销，这时T1已修改过的数据恢复原值，T2读到的数据就与数据库中的数据不一致，此时T2读到的数据就为“脏”数据</li></ul></li></ul></li></ul><h4 id="3-7-2-封锁"><a href="#3-7-2-封锁" class="headerlink" title="3.7.2 封锁"></a>3.7.2 封锁</h4><ul><li><p>封锁概述</p><ul><li><p>事务T在对某个数据对象操作之前，先向系统发出请求，对其加锁</p></li><li><p>排它锁（Exclusive Locks，简记为X锁、写锁）</p><ul><li>若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁</li><li>保证其他事务在T释放A上的锁之前<strong>不能再读取和修改</strong>A</li></ul></li><li><p>共享锁（Share Locks，简记为S锁、读锁）</p><ul><li>若事务T对数据对象A加上S锁，则其它事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁</li><li><strong>保证其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改</strong></li></ul></li><li><p>锁的相容性矩阵（Y表示相容，N表示不相容）</p><table><thead><tr><th align="center"></th><th align="center">X</th><th align="center">S</th><th align="center">-</th></tr></thead><tbody><tr><td align="center">X</td><td align="center">N</td><td align="center">N</td><td align="center">Y</td></tr><tr><td align="center">S</td><td align="center">N</td><td align="center">Y</td><td align="center">Y</td></tr><tr><td align="center">-</td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td></tr></tbody></table></li></ul></li><li><p>封锁解决数据不一致性</p><ul><li>解决丢失修改问题：修改前先对待修改数据对象加X锁</li><li>解决不可重复读问题：读前先对待读数据对象加S锁</li><li>解决读脏数据问题：T1修改前先对待修改数据对象加X锁，T2读前先对待读数据对象加S锁</li></ul></li><li><p>活锁</p><ul><li>T2、T3、…、Tn依次等待事务T1释放锁，而系统依次批准了T3、…、Tn的请求，T2将有可能永远等待，即活锁</li><li>采用<strong>先来先服务</strong>的策略避免活锁：当多个事务请求封锁同一数据对象时，按请求封锁的先后次序对这些事务排队，该数据对象上的锁一旦释放，首先批准申请队列中第一个事务获得锁</li></ul></li><li><p>死锁</p><ul><li>事务T1封锁了数据R1，而T2封锁了数据R2；T1又请求封锁R2，因T2已封锁了R2，于是T1等待T2释放R2上的锁；接着T2又申请封锁R1，因T1已封锁了R1，T2也只能等待T1释放R1上的锁，这样T1在等待T2，而T2又在等待T1，T1和T2两个事务永远不能结束，形成死锁</li><li>预防死锁<ul><li>一次封锁法：每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行</li><li>顺序封锁法：预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁</li><li>时间戳优先级法：较老时间戳具有更高优先级，当一事务重启时，它的新优先级仍为原先的时间戳</li></ul></li><li>死锁的检测与解除<ul><li>超时法检测：如果一个事务的等待时间超过了规定的时限，就认为发生了死锁；阈值过短则可能误判，过长则死锁不能及时发现</li><li>事务等待图法检测<ul><li>事务等待图是一个有向图G&#x3D;(T,U)，其中T为结点的集合，每个结点表示正运行的事务，U为边的集合，每条边表示事务等待的情况，若T1等待T2，则T1与T2之间有一条从T1指向T2的有向边</li><li>并发控制子系统周期性地（比如每隔数秒）生成事务等待图，检测事务。<strong>如果发现图中存在回路，则表示系统中出现了死锁</strong></li></ul></li></ul></li></ul></li><li><p>封锁协议</p><img src="封锁协议.png" style="zoom:60%;" /><ul><li>1级封锁协议<ul><li>事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放</li><li>1级封锁协议可防止丢失修改</li><li>在1级封锁协议中，如果是读数据，不需要加锁的，所以它不能保证可重复读和不读“脏”数据</li></ul></li><li>2级封锁协议<ul><li>1级封锁协议+事务T在读取数据R前必须先加S锁，读完后即可释放S锁</li><li>在2级封锁协议中，由于读完数据后即可释放S锁，所以它不能保证可重复读</li></ul></li><li>3级封锁协议<ul><li>1级封锁协议+事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放</li><li>3级封锁协议可防止丢失修改、读脏数据和不可重复读</li></ul></li></ul></li></ul><h4 id="3-7-3-可串行性"><a href="#3-7-3-可串行性" class="headerlink" title="3.7.3 可串行性"></a>3.7.3 可串行性</h4><ul><li>可串行化(Serializable)调度：多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同</li><li>冲突可串行化调度<ul><li>冲突可串行化是可串行化调度的<strong>充分条件</strong></li><li>冲突操作指<strong>不同事务对同一数据的读写操作和写写操作</strong>，冲突操作中两个操作的次序发生改变将导致结果改变</li><li>某个调度在冲突操作的次序不改变的前提下，通过交换两个事务不冲突操作的次序，转变为可串行的调度，则该调度是冲突可串行化的</li></ul></li></ul><h4 id="3-7-4-两段锁协议"><a href="#3-7-4-两段锁协议" class="headerlink" title="3.7.4 两段锁协议"></a>3.7.4 两段锁协议</h4><ul><li>当一个事务满足以下条件时，是满足两段锁协议的<ul><li>在对任何数据进行读写操作前，首先申请并获得对该数据的封锁</li><li>在释放一个封锁后，事务不再申请和获得任何其他封锁</li><li>事务被划分为两个阶段<ul><li>扩展阶段：获得封锁且不释放任何锁</li><li>收缩阶段：释放封锁且不申请任何锁</li></ul></li></ul></li><li>若并发执行的所有事务均满足两段锁协议，则这些事务的任何调度策略都是可串行化的，这是可串行化的<strong>充分条件</strong></li><li>遵循两段锁协议的事务不要求事务必须一次将所有要使用的数据全部加锁，因此<strong>可能发生死锁</strong></li></ul><h3 id="3-8-数据库恢复技术"><a href="#3-8-数据库恢复技术" class="headerlink" title="3.8 数据库恢复技术"></a>3.8 数据库恢复技术</h3><h4 id="3-8-1-事务"><a href="#3-8-1-事务" class="headerlink" title="3.8.1 事务"></a>3.8.1 事务</h4><ul><li><p>事务概念</p><ul><li>事务(Transaction)：用户定义的具有交易特性的一个数据库操作序列</li><li>特性<ul><li>原子性：事务是数据库的逻辑工作单位，事务中各操作要么都做，要么都不做</li><li>一致性：数据库状态与外部状态一致</li><li>隔离性：一个事务的执行不能被其他事务干扰</li><li>持续性：一个事务一旦提交，它对数据库中数据的改变就应该是永久性的</li></ul></li></ul></li><li><p>定义事务</p><ul><li><p>显式定义</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#提交事务</span><br><span class="line"><span class="keyword">BEGIN</span> TRANSACTION</span><br><span class="line"><span class="keyword">SQL</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">COMMIT</span></span><br><span class="line">#回滚事务</span><br><span class="line"><span class="keyword">BEGIN</span> TRANSACTION</span><br><span class="line"><span class="keyword">SQL</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">ROLLBACK</span></span><br></pre></td></tr></table></figure></li><li><p>隐式定义：DBMS按缺省规定自动划分事务</p></li></ul></li></ul><h4 id="3-8-2-数据库恢复"><a href="#3-8-2-数据库恢复" class="headerlink" title="3.8.2 数据库恢复"></a>3.8.2 数据库恢复</h4><ul><li>故障种类<ul><li>事务故障：某个事务在运行过程中由于种种原因未运行至预期的终点便结束</li><li>系统故障：操作系统或DBMS代码错误等</li><li>介质故障：磁盘损坏等原因</li></ul></li><li>恢复的实现：建立冗余数据<ul><li>数据转储<ul><li>静态转储：在系统中无运行事务时进行转储，转储期间不允许对数据库进行任何存取修改活动</li><li>动态转储：转储与事务并发执行，但获得一致性副本较麻烦，因此需要将动态转储期间各事务对数据库的修改活动登记下来，建立日志文件</li><li>海量转储：定期或不定期将数据库全部数据转储，其转储量大，易造成重复转储</li><li>增量转储：每次转储上次转储后更新过的数据，其备份量小，但恢复过程较复杂</li></ul></li><li>登录日志文件<ul><li>用来记录事务对数据库的更新操作的文件</li><li>以记录为单位的日志文件内容<ul><li>各个事务的开始标记(BEGIN TRANSACTION)</li><li>各个事务的结束标记(COMMIT或ROLLBACK)</li><li>各个事务的所有更新操作</li><li>与事务有关的内部更新操作</li><li>每条日志记录的内容<ul><li>事务标识</li><li>操作类型（插入、删除或修改）</li><li>操作对象（记录ID）</li><li>更新前数据的旧值（对插入操作而言，此项为空值）</li><li>更新后数据的新值（对删除操作而言, 此项为空值）</li></ul></li></ul></li><li>以数据块为单位的日志文件<ul><li>事务标识号</li><li>该事务执行更新前的数据块</li><li>该事务执行更新后的数据块</li></ul></li><li>每个日志记录在日志中都有一个唯一的码，叫做日志序号（简称LSN）</li></ul></li></ul></li><li>恢复策略<ul><li>事务故障的恢复：由恢复子系统利用<strong>日志文件</strong>撤消此事务已对数据库进行的修改<ul><li>反向扫描文件日志，查找该事务的更新操作，并对该事务的更新操作执行逆操作</li><li>如此处理下去，直至读到此事务的开始标记，事务故障恢复即完成</li></ul></li><li>系统故障的恢复<ul><li>正向扫描日志文件，得到Undo队列和Redo队列</li><li><strong>Undo故障发生时未完成的事务</strong>：一些未完成事务对数据库的更新已写入数据库，反向扫描日志文件，对每个UNDO事务的更新操作执行逆操作</li><li><strong>Redo已完成的事务</strong>：一些已提交事务对数据库的更新还留在缓冲区没来得及写入数据库，正向扫描日志文件，对每个REDO事务重新执行登记的操作</li><li>通俗方式<ul><li>在系统发生故障之前已经提交的事务需要重做</li><li>在系统发生故障之前开始但没有提交的需要撤销</li><li>在系统发生故障之前已经回滚的事务不做操作，相当于没有进行</li><li>系统恢复后，回滚和撤销的事务相当于没有执行，只需要考虑重做的事务</li></ul></li></ul></li><li>介质故障的恢复<ul><li>重装数据库，使数据库恢复到一致性状态<ul><li>对于静态转储的数据库副本，装入后数据库即处于一致性状态</li><li>对于动态转储的数据库副本，还须同时装入转储时刻的日志文件副本，利用与恢复系统故障相同的方法恢复</li></ul></li><li>装入转储结束时刻的日志副本，重做已完成的事务<ul><li>首先扫描日志文件，找出故障发生时已提交的事务的标识，将其记入重做队列</li><li>然后正向扫描日志文件，对重做队列中的所有事务操作进行重做。即将日志记录中“更新后的值”写入数据库</li></ul></li></ul></li></ul></li></ul><h2 id="四、关系数据理论"><a href="#四、关系数据理论" class="headerlink" title="四、关系数据理论"></a>四、关系数据理论</h2><h3 id="4-1-规范化理论"><a href="#4-1-规范化理论" class="headerlink" title="4.1 规范化理论"></a>4.1 规范化理论</h3><ul><li>关系的规范化：按照一定的规范设计的关系模式，将结构复杂的关系分解成结构简单的关系，从而把不好的关系数据库模式转变成为好的关系数据库模式</li><li>简化的关系模式：$R(U,F)$，其中$U$为组成该关系的属性名集合，$F$为属性间数据的依赖关系集合</li></ul><h3 id="4-2-函数依赖（FD）"><a href="#4-2-函数依赖（FD）" class="headerlink" title="4.2 函数依赖（FD）"></a>4.2 函数依赖（FD）</h3><ul><li><p>设$R(U)$是属性集$U$上的关系模式，$X $, $Y\subseteq U$， $r$是$R(U) $上的任意一个关系，如果有对$\forall t,s\in r$，若$t[X] &#x3D; s[X]$，则$t[Y] &#x3D; s[Y]$，那么称<strong>X函数决定Y</strong>，或<strong>Y函数依赖于X</strong>，记作$X\rightarrow Y$，并称$X$为决定因素</p></li><li><p>函数依赖不是指关系模式R的某个或某些关系实例满足的约束条件，而是指<strong>R的所有关系实例均要满足的约束条件</strong></p></li><li><p>若$X\rightarrow Y$且$Y\rightarrow X$，则$X\leftrightarrow Y$</p></li><li><p>若$Y$不函数依赖于$X$，则$X\nrightarrow Y$</p></li><li><p>平凡函数依赖：如果$X\rightarrow Y$且$Y\subset X$，则称为平凡函数依赖</p></li><li><p>非平凡函数依赖：如果$X\rightarrow Y$且$Y\nsubseteq X$，则称为非平凡函数依赖</p></li><li><p>若不特别声明，我们讨论的都是非平凡的函数依赖</p></li><li><p><strong>部分函数依赖</strong>：如果$X\rightarrow Y$，且对于任意$X$的真子集$X^{‘}$，有$X^{‘}\nrightarrow Y$，则称$Y$对$X$完全函数依赖，记作$X{\stackrel{f}\rightarrow}Y$，否则称$Y$对$X$部分函数依赖，记作$X{\stackrel{p}\rightarrow}Y$</p><blockquote><p>只有当决定因素是组合属性时，讨论部分函数依赖才有意义</p><p>当决定因素是单属性时，只能是完全函数依赖</p><p>例如，在关系模式$S(SNO,SN,AGE,DEPT)$，决定因素为单属性$SNO$，有$SNO   (SN,AGE,DEPT)$，不存在部分函数依赖</p></blockquote></li><li><p>传递函数依赖：如果$X\rightarrow Y$，$Y\rightarrow Z$，$Y\nrightarrow X$，$Y\nsubseteq X$，则称$Z$对$X$传递函数依赖</p></li><li><p>候选码：设$K$为$R(U,F)$的属性或属性组合，若$K\stackrel{f}\rightarrow U$，则称$K$为$R$的候选码</p></li><li><p>主属性：任何一个候选码中的属性称作主属性</p></li><li><p>主码：从一个关系的多个候选码中选定一个作为主码</p></li><li><p>超码：某个属性组合，其存在一个子集是候选码</p></li></ul><h3 id="4-3-范式"><a href="#4-3-范式" class="headerlink" title="4.3 范式"></a>4.3 范式</h3><ul><li>$1NF$<ul><li>关系中每一分量在语义上不可再分</li><li>即不能以集合、数组、序列、结构体等作为属性值</li></ul></li><li>$2NF$<ul><li>若$R\in 1NF$，且每个非主属性完全依赖于码，则称$R\in 2NF$</li><li>该范式<strong>消除了非主属性对码的部分依赖</strong></li><li>采用投影分解法将一个$1NF$的关系分解为多个$2NF$的关系</li><li>将一个$1NF$关系分解为多个$2NF$的关系，并不能完全消除关系模式中的各种异常情况和数据冗余</li></ul></li><li>$3NF$<ul><li>关系模式$R(U,F)$中，若不存在这样的码$X$、属性组$Y$及非主属性$Z$（$Z\nsubseteq Y$），使得$X\rightarrow Y$，$Y\nrightarrow X$，$Y\rightarrow Z$成立，称$R\in 3NF$</li><li>每一个非主属性既不部分函数依赖于候选码也不传递函数依赖于候选码</li><li>该范式<strong>消除了非主属性对码的传递依赖</strong></li></ul></li><li>$BCNF$<ul><li>设$R\in 1NF$，若对于$R$的每个函数依赖$X\rightarrow Y$，若$Y$不属于$X$，则$X$必包含候选码，那么$R\in BCNF$</li><li>该范式<strong>消除了主属性对码的传递依赖或部分依赖</strong></li><li>如果$R\in 3NF$，且$R$只有一个候选码，则$R\in BCNF$</li></ul></li></ul><h3 id="4-4-函数依赖的公理系统"><a href="#4-4-函数依赖的公理系统" class="headerlink" title="4.4 函数依赖的公理系统"></a>4.4 函数依赖的公理系统</h3><ul><li>逻辑蕴涵：已知关系模式$R$，$U$是属性集全体，$F$是其函数依赖，$X$，$Y$是其属性子集，对于任何一个关系$r$，若函数依赖$X\rightarrow Y$都成立，则称$F$逻辑蕴涵$X\rightarrow Y$</li><li>依赖闭包：在关系模式$R$中，为$F$所逻辑蕴涵的函数依赖的全体叫做$F$的闭包，记作$F^{+}$</li><li><strong>$X$关于$F$的闭包$X_{F^+}$：$X_{F^+}&#x3D;{A|X\rightarrow A可由F根据Armstrong公理系统导出}$</strong></li><li>$Armstrong$公理系统<ul><li>自反律：若$Y\subseteq X\subseteq U$，则$X\rightarrow Y$为$F$所蕴含</li><li>增广律：若$X\rightarrow Y$为$F$所蕴含，且$Z\subseteq U$，则$XZ\rightarrow YZ$为$F$所蕴含</li><li>传递律：若$X\rightarrow Y$和$Y\rightarrow Z$为$F$所蕴含，则$X\rightarrow Z$为$F$所蕴含</li><li><strong>合并规则</strong>：由$X\rightarrow Y$，$X\rightarrow Z$，则$X\rightarrow YZ$</li><li><strong>伪传递规则</strong>：由$X\rightarrow Y$，$WY\rightarrow Z$，则$XW\rightarrow Z$</li><li><strong>分解规则</strong>：由$X\rightarrow Y$，$Z\subseteq Y$，则$X\rightarrow Z$</li><li>$X\rightarrow A_1A_2\cdots A_k$成立的充要条件是$X\rightarrow A_i$成立</li></ul></li><li>$X\rightarrow Y$能由$F$根据$Armstrong$导出的充要条件是$Y\subseteq X_{F^+}$<ul><li>判定$X\rightarrow Y$能否由$F$根据$Armstrong$导出转化为先求$X_{F^+}$，然后判断$Y$是否为其子集</li><li>如果$X_{F^+}&#x3D;U$，则$X$是$R$的候选码</li></ul></li><li><strong>$X_{F^+}$的计算</strong><ul><li>寻找$F$中决定因素为$X$或$X$子集的函数依赖，得到这些函数依赖的右部，与$X$合并得到新的$X$</li><li>继续以上步骤，直至合并前后的属性集相同或合并后的属性集为$U$</li></ul></li><li><strong>候选码的计算</strong><ul><li>基本定义<ul><li>左部属性：只出现在$F$左边的属性</li><li>右部属性：只出现在$F$右边的属性</li><li>双部属性：出现在$F$两边的属性</li><li>外部属性：不出现在$F$的属性</li></ul></li><li>基本规则<ul><li>左部属性一定出现在任何候选码中&#x2F;一定是主属性</li><li>右部属性一定不出现在任何候选码中&#x2F;一定是非主属性</li><li>外部属性一定出现在任何候选码中&#x2F;一定是主属性</li></ul></li><li>求解过程<ul><li>求<strong>已经确定的主属性集</strong>关于函数依赖的闭包</li><li>如果该闭包为属性全集$U$，则<strong>已经确定的主属性集</strong>为唯一候选码</li><li>如果该闭包不为属性全集$U$，则依次取左部属性和双部属性中的一个组成临时候选码，求其闭包，如果该闭包为属性全集$U$，则该临时候选码为候选码</li><li>如果第三步中仍未得到候选码，则依次取左部属性和双部属性中的<strong>2~n</strong>个组成临时候选码，求其闭包，如果该闭包为属性全集$U$，则该临时候选码为候选码</li></ul></li></ul></li><li>函数依赖的等价&#x2F;覆盖：如果$G^+&#x3D;F^+$，则$F$覆盖$G$</li><li>最小覆盖&#x2F;极小函数依赖集：满足如下条件的函数依赖集<ul><li>$F$中任一函数依赖的右部仅含有一个属性</li><li>$F$中不存在这样的函数依赖$X\rightarrow A$，使得$F$与$F-{X\rightarrow A}$等价，即$F$中的函数依赖不能被其他函数依赖导出</li><li>$F$中不存在这样的函数依赖$X\rightarrow A$，$X$有真子集$Z$使得$F$与$F-{X\rightarrow A}\cup{Z\rightarrow A}$等价，即$F$中各函数依赖左部均为最小属性集，均不存在冗余属性</li></ul></li><li><strong>最小覆盖的计算</strong><ul><li>将$F$中所有函数依赖的右边化为单一属性<ul><li>使用合并规则</li><li>逐一检查$F$中各函数依赖$F_i:X\rightarrow Y$，若$Y&#x3D;A_1A_2\cdots A_k,k\geq2$，则使用${X\rightarrow A_j|j&#x3D;1,2,\cdots,k}$代替$X\rightarrow Y$</li></ul></li><li>去掉$F$中所有冗余的函数依赖<ul><li>逐一检查$F$中各函数依赖$F_i:X\rightarrow Y$，设$G&#x3D;F-F_i$，若$Y\in X_{G^+}$，则去掉该函数依赖</li></ul></li><li>去掉$F$中所有函数依赖的左边的冗余属性<ul><li>逐一检查$F$中各函数依赖$F_i:X\rightarrow Y$，若$X&#x3D;B_1B_2\cdots B_m$，考察$B_i$，若$Y\in(X-B_i)_{F^+}$，则以$X-B_i$代替$X$</li></ul></li></ul></li></ul><h3 id="4-5-模式分解"><a href="#4-5-模式分解" class="headerlink" title="4.5 模式分解"></a>4.5 模式分解</h3><ul><li>模式分解：将关系模式$R&lt;U,V&gt;$分解为$\rho&#x3D;{R_1&lt;U_1,F_1&gt;,\cdots,R_n&lt;U_n,F_n&gt;}$，且$U&#x3D;U_1\cup\cdots\cup U_n$，没有$U_i\subseteq U_j,1\leq i,j\leq n$，$F_i$是$F$在$U_i$上的投影</li><li>正确的模式分解<ul><li>具有无损连接性：设$\rho&#x3D;{R_1&lt;U_1,F_1&gt;,\cdots,R_n&lt;U_n,F_n&gt;}$是$R&lt;U,V&gt;$的一个分解，若对$R$上的任何一个关系$r$均有$r&#x3D;r在\rho中个关系模式上投影的自然连接$，则称$\rho$具有无损连接性，简称$\rho$为无损分解</li><li>具有保持函数依赖性：设$\rho&#x3D;{R_1&lt;U_1,F_1&gt;,\cdots,R_n&lt;U_n,F_n&gt;}$是$R&lt;U,V&gt;$的一个分解，若$F$所逻辑蕴涵的函数依赖一定为分解后所有的关系模式中的函数依赖$F_i$所逻辑蕴涵，即$F^+&#x3D;(F_1\cup F_2\cup\cdots\cup F_n)^+$，则称$\rho$具有保持函数依赖性</li><li>如果一个分解具有无损连接性，则它能够保证不丢失信息</li><li>如果一个分解保持了函数依赖，则它可以减轻或解决各种异常情况</li></ul></li></ul><h2 id="五、查询优化"><a href="#五、查询优化" class="headerlink" title="五、查询优化"></a>五、查询优化</h2><h3 id="6-1-查询处理"><a href="#6-1-查询处理" class="headerlink" title="6.1 查询处理"></a>6.1 查询处理</h3><img src="查询计划举例.png" style="zoom:30%;" /><ul><li><p>查询处理流程</p><ul><li>操作算子以树的形式进行组织</li><li>数据流从叶子结点流向根节点</li><li>根节点的输出是查询的结构</li></ul></li><li><p>迭代模型</p><img src="迭代模型.png" style="zoom:30%;" /><ul><li>每个算子执行$Next$函数，调用得到一个下层提交的元组或一个空值标记$NULL,,, Maker$</li></ul></li><li><p>物化模型</p><img src="物化模型.png" style="zoom:30%;" /><ul><li>每个算子一次性获取所有输出，传递元组列表给父节点</li></ul></li><li><p>向量模型</p><img src="向量模型.png" style="zoom:30%;" /><ul><li>基本框架同迭代模型，但是每次提交一批元组（Batch）</li></ul></li></ul><h3 id="6-2-代数优化"><a href="#6-2-代数优化" class="headerlink" title="6.2 代数优化"></a>6.2 代数优化</h3><h4 id="6-2-1-代数优化的基本准则"><a href="#6-2-1-代数优化的基本准则" class="headerlink" title="6.2.1 代数优化的基本准则"></a>6.2.1 代数优化的基本准则</h4><ul><li>选择运算尽可能先做</li><li>在执行连接操作前对关系适当进行预处理</li><li>投影运算和选择运算同时做</li><li>某些选择运算与在其前面执行的笛卡尔积合并为连接运算</li></ul><h4 id="6-2-2-关系代数等价变换规则"><a href="#6-2-2-关系代数等价变换规则" class="headerlink" title="6.2.2 关系代数等价变换规则"></a>6.2.2 关系代数等价变换规则</h4><ul><li>连接、笛卡尔积交换律：$E_1\times E_2&#x3D;E_2\times E_1$、$E_1\Join E_2&#x3D;E_2\Join E_1$</li><li>连接、笛卡尔积结合律：$(E_1\times E_2)\times E_3&#x3D;E_1\times(E_2\times E_3)$、$(E_1\Join E_2)\Join E_3&#x3D;E_1\Join(E_2\Join E_3)$</li><li>投影的串接定律：$\prod_{A_1,A_2,\cdots,A_n}(\prod_{B_1,B_2,\cdots,B_m}(E))&#x3D;\prod_{A_1,A_2,\cdots,A_n}(E)$，其中${A_1,A_2,\cdots,A_n}$是${B_1,B_2,\cdots,B_m}$的子集</li><li>连接的串接定律：$\sigma_{F_1}(\sigma_{F_2}(E))&#x3D;\sigma_{F_1\land F_2}(E)$</li><li>选择与投影的交换律<ul><li>如果选择条件$F$只涉及$A_1,\cdots,A_n$，则$\sigma_F(\prod_{A_1,A_2,\cdots,A_n}(E))&#x3D;\prod_{A_1,A_2,\cdots,A_n}(\sigma_F(E))$</li><li>如果选择条件$F$含有不属于$A_1,\cdots,A_n$的属性$B_1,\cdots,B_n$，则$\sigma_F(\prod_{A_1,A_2,\cdots,A_n}(E))&#x3D;\prod_{A_1,A_2,\cdots,A_n}(\sigma_F(\prod_{A_1,A_2,\cdots,A_n,B_1,B_2,\cdots,B_m}(E)))$</li></ul></li><li>选择、笛卡尔积交换律<ul><li>如果选择条件$F$只涉及$E_1$，则$\sigma_F(E_1\times E_2)&#x3D;\sigma_F(E_1)\times E_2$</li><li>设$F&#x3D;F_1\land F_2$，如果选择条件$F_1$只涉及$E_1$且选择条件$F_2$只涉及$E_2$，则$\sigma_F(E_1\times E_2)&#x3D;\sigma_{F_1}(E_1)\times \sigma_{F_2}(E_2)$</li><li>设$F&#x3D;F_1\land F_2$，如果选择条件$F_1$只涉及$E_1$且选择条件$F_2$涉及$E_1$和$E_2$两者的属性，则$\sigma_F(E_1\times E_2)&#x3D;\sigma_{F_1}(E_1)\times \sigma_{F_2}(E_2)$</li></ul></li><li>选择对自然连接的分配律：$\sigma(E_1\times E_2)&#x3D;\sigma(E_1)\times\sigma(E_2)$</li><li>投影与笛卡尔积的交换：假设$A_1,A_2,\cdots,A_n$是，，$\prod_{A_1,A_2,\cdots,A_n,B_1,B_2,\cdots,B_m}(E_1\times E_2)&#x3D;\prod_{A_1,A_2,\cdots,A_n}(E_1)\times \prod_{B_1,B_2,\cdots,B_m}(E_2)$</li></ul><h4 id="6-2-3-代数优化的步骤"><a href="#6-2-3-代数优化的步骤" class="headerlink" title="6.2.3 代数优化的步骤"></a>6.2.3 代数优化的步骤</h4><ul><li>根据SQL语句画出语法树</li><li>将语法树转换为关系代数语法树</li><li>通过代数优化得到优化后的关系代数语法树</li></ul>]]></content>
      
      
      <categories>
          
          <category> 专业核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【笔记】计算机网络与通信笔记</title>
      <link href="/2023/02/22/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E9%80%9A%E4%BF%A1%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/02/22/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E9%80%9A%E4%BF%A1%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="考试重点"><a href="#考试重点" class="headerlink" title="考试重点"></a>考试重点</h2><ul><li>协议栈：五层协议的名称、功能、协议、分组名称、各种设备处理的协议</li><li>基础知识：时延的类型与计算</li><li>应用层：HTTP协议报文、HTTP协议非持续连接与持续连接、SMTP协议与衍生协议的功能</li><li>运输层：可靠数据传输（StopWait、GBN、SN、TCP）、TCP协议的拥塞控制、CRC校验</li><li>网络层数据层面：子网划分、CIDR、NAT、IP协议报文</li><li>网络层控制层面：路由转发、链路状态选择算法、距离向量选择算法</li><li>链路层：MAC地址、ARP协议、以太网协议、争用期、交换机</li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul><li>运输层：TCP建立连接的过程、TCP的流量控制、TCP Tahoe TCP Reno</li><li>网络层：DHCP、ICMP、路由器的三种交换结构、LS、OSPF、DV、RIP、BGP协议</li><li>网关路由器</li><li>链路层：码分多址</li></ul><h2 id="一、计算机网络与因特网"><a href="#一、计算机网络与因特网" class="headerlink" title="一、计算机网络与因特网"></a>一、计算机网络与因特网</h2><h3 id="1-1-什么是因特网"><a href="#1-1-什么是因特网" class="headerlink" title="1.1 什么是因特网"></a>1.1 什么是因特网</h3><h4 id="1-1-1-具体构成"><a href="#1-1-1-具体构成" class="headerlink" title="1.1.1 具体构成"></a>1.1.1 具体构成</h4><ul><li><p>硬件层面</p><ul><li><p>主机&#x2F;端系统：诸如桌面$PC$、$Linux$工作站、平板电脑等与因特网互联的设备</p><blockquote><p>端系统也称主机$(host)$，因为其能运行应用程序；主机又可以分为客户$(client)$和服务器$(server)$</p></blockquote></li><li><p>端系统通过<strong>通信链路</strong>和<strong>分组交换机</strong>连接到一起</p></li><li><p>通信链路：由不同类型的物理媒体组成，包括同轴电缆、铜线、光纤和无线电频谱</p></li><li><p>分组交换机：用于连接不同的通信链路传输数据，包括路由器和链路层交换机等</p></li><li><p>端系统通过<strong>因特网服务提供商</strong>$(ISP)$接入因特网</p></li></ul></li><li><p>软件层面</p><ul><li>**协议$(protocol)$**控制着因特网中信息的接受和发送，其主要协议统称为$TCP&#x2F;IP$</li><li>协议定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送和&#x2F;或接收报文所采取的动作</li></ul></li></ul><h3 id="1-2-网络边缘"><a href="#1-2-网络边缘" class="headerlink" title="1.2 网络边缘"></a>1.2 网络边缘</h3><h4 id="1-2-1-接入网"><a href="#1-2-1-接入网" class="headerlink" title="1.2.1 接入网"></a>1.2.1 接入网</h4><ul><li><p>基本概念</p><ul><li><p>接入网：将端系统物理连接到其<strong>边缘路由器</strong>的网络</p><blockquote><p>接入网的本质作用：通过各种方式使主机连接到路由器，以使得任意两个端系统间能够相互通信</p></blockquote></li><li><p>边缘路由器：端系统连接到其他任何远程端系统的路径上的<strong>第一台</strong>路由器</p></li></ul></li><li><p>接入方式</p><ul><li><p>点对点方式</p><ul><li><p>数据用户线$DSL$：通过本地电话公司获得互联网接入，本地电话公司即为其$ISP$</p><blockquote><p>不对称数字用户线$ADSL$通过在不同的频段进行编码使得电话线能够同时承载数据信号与电话信号。</p></blockquote></li><li><p>光纤到户$FTTH$：将光纤从本地中心局直接连接到房间，通过光猫（光调制解调器）转换光电信号，使用双绞线连接电脑</p></li><li><p>卫星：电脑连接卫星信号接收机，通过无线电波与卫星相连，卫星又通过无线电波与地面上另一接收机相连</p></li></ul></li><li><p>以太网方式</p><ul><li>有线以太网：端系统通过双绞线连到以太网，以太网连接至边缘路由器</li><li>$WiFi$：端系统连到$WiFi$，$WiFi$连接至边缘路由器</li></ul></li><li><p>广域无线接入方式</p><ul><li>由电信运营商提供，如$3G$、$4G$、$5G$</li></ul></li></ul></li></ul><h4 id="1-2-2-物理媒体"><a href="#1-2-2-物理媒体" class="headerlink" title="1.2.2 物理媒体"></a>1.2.2 物理媒体</h4><ul><li>导引型媒体<ul><li>双绞铜线：由两根并行铜线组成，如传统电话线</li><li>同轴电缆：由两根同心铜线组成，如电缆</li><li>光纤：能够引导光脉冲，误码率低</li></ul></li><li>非导引型媒体<ul><li>无线电波：通过电磁频谱传递信号</li></ul></li></ul><h3 id="1-3-网络核心"><a href="#1-3-网络核心" class="headerlink" title="1.3 网络核心"></a>1.3 网络核心</h3><h4 id="1-3-1-电路交换"><a href="#1-3-1-电路交换" class="headerlink" title="1.3.1 电路交换"></a>1.3.1 电路交换</h4><ul><li><p>特点（<a href="https://gaia.cs.umass.edu/kurose_ross/interactive/circuit_switching.php">在线交互程序</a>）</p><ul><li>数据交换前需建立一条从发送端到接收端的物理通路</li><li>在数据交换的全部时间，用户始终占用端到端的固定传输信道，且<strong>只能为其所用</strong></li><li>所有用户平分网络链路的传输容量，且<strong>传输速率恒定</strong></li><li>交换双方可以<strong>实时</strong>进行数据交换，不会存在延迟</li><li>适合传送<strong>大量数据</strong>，传送分组时间远大于连接建立时间</li></ul></li><li><p>复用方式</p><ul><li><p>频分复用$FDM$</p><ul><li>所有连接共用链路的频谱，每个连接专用一个频段，其宽度称为<strong>带宽</strong></li><li>每条连接连续地得到部分带宽</li></ul></li><li><p>时分复用$TDM$</p><ul><li>时间被划分为固定期间的帧，每个帧被划分为固定数量的时隙</li><li>链路为每个连接在每个帧中指令一个时隙，这些时隙由每个连接单独使用</li><li>每条连接周期性地得到全部带宽</li></ul></li><li><p>复用方式的对比</p><img src="1-2 频分复用与时分复用.png" style="zoom: 67%;" /></li><li><p>举例说明：</p><ul><li>问：设所有链路速率皆为$1.536Mbps$，每条链路使用有$24$个时隙的$TDM$，建立端到端的电路需要$500$毫秒，则计算通过电路交换网络将一个$640000$比特长的文件从主机$A$传送到主机$B$需要多长时间</li><li>答：$(640kb)&#x2F;(1.536Mbps&#x2F;24)+0.5&#x3D;10.5s$</li></ul></li><li><p>缺点：</p><ul><li>计算机之间的数据交换往往具有<strong>突发性</strong>和<strong>间歇性</strong>特征，而对电路交换而言，用户支付的费用则是按用户占用线路的时间来收费</li><li>只要在通话双方建立的通路中任何一点出了故障，就必须重新拨号建立新连接，这对紧急和重要通信很不利。</li></ul></li></ul></li></ul><h4 id="1-3-2-分组交换"><a href="#1-3-2-分组交换" class="headerlink" title="1.3.2 分组交换"></a>1.3.2 分组交换</h4><ul><li><p>特点</p><ul><li><p>将要发送的报文分解成若干个小部分，称为分组</p><blockquote><p>每个分组都通过通信链路和分组交换机传送，以等于该链路最大传输速率地速度通过通信链路</p><p>通过某链路发送一个$L$比特的分组，链路传输速率为$R,bit&#x2F;s$，则传输分组的时间为$L&#x2F;R$秒</p></blockquote></li><li><p>存储转发传输：交换机能够开始向输出链路传输该分组的第一个比特前，<strong>必须接收到整个分组</strong></p></li><li><p>每个分组传输的链路可能不同，且存在冗余路由</p><blockquote><p>在分组传输前<strong>不必预先确定分组的传输路径</strong>，而是在传输到某个分组交换机后根据转发表查找转发端口</p></blockquote></li><li><p>网络核心中每个交换结点均为共享结点</p></li><li><p>适合传送<strong>突发数据</strong></p></li></ul></li><li><p>电路类型</p><ul><li>数据报网络</li><li>虚电路网络（结合电路连接的优点）<ul><li>虚电路需要<strong>建立连接</strong>，即建立虚电路链路</li><li><strong>在建立连接时决定链路的路由</strong>，在整个连接过程中保持不变</li><li>在链路通过的每个节点，预留一定的资源</li><li>每个分组携带一个标识（虚电路号），根据该标识知道该从哪个虚电路传输数据</li><li>虚电路如果不再使用，需要<strong>释放相关的资源</strong></li></ul></li></ul></li><li><p>与电路交换比较（<a href="https://gaia.cs.umass.edu/kurose_ross/interactive/ps_versus_cs.php">在线交互程序</a>）</p><ul><li><p>在相同条件下，分组交换能够比电路交换支持更多的用户</p><blockquote><p>设一条$1Mbps$的链路，每个用户需要$100kbps$，电路交换模式下仅支持$10$个用户；设分组交换下$1$个用户活跃的概率为$0.1$，在$35$个用户条件下，$11$个及以上用户同时活动的概率为$0.0004$，即$10$个及$10$个以内用户同时活跃的概率为$0.9996$，基本上与电路交换性能相当</p></blockquote></li><li><p>当用户数较少时，分组交换能够获得比电路交换更好的性能</p><blockquote><p>同一时刻仅有一个用户传输$1M$的数据，电路交换需要$10s$，分组交换需要$1s$</p></blockquote></li><li><p>在数据量大时，分组交换的传输时延比电路交换大</p><blockquote><p>通过由$n$条速率均为$R$的链路组成的路径，从源到目的地发送一个分组的时延为$d_{端到端}&#x3D;N\frac{L}{R}$</p></blockquote></li></ul></li><li><p>缺点</p><ul><li>分组在各结点存储转发时因要排队<strong>会造成一定的时延</strong>，当网络通信量过大时，这种时延可能会很大。</li><li>各分组必须携带一定的<strong>控制信息（说明信息）</strong>，从而带来额外开销。</li></ul></li></ul><h4 id="1-3-3-ISP-网络模型"><a href="#1-3-3-ISP-网络模型" class="headerlink" title="1.3.3 $ISP$网络模型"></a>1.3.3 $ISP$网络模型</h4><ul><li><p>各种$ISP$互相连在一起</p></li><li><p>低级$ISP$可以连入高级$ISP$进行互通</p></li><li><p>同级$ISP$之间通过$IXP$和对等链路进行<strong>对等</strong>链接</p><img src="1-3 ISP模型.png" style="zoom: 33%;" /></li></ul><h3 id="1-4-分组交换网络的衡量"><a href="#1-4-分组交换网络的衡量" class="headerlink" title="1.4 分组交换网络的衡量"></a>1.4 分组交换网络的衡量</h3><h4 id="1-4-1-时延"><a href="#1-4-1-时延" class="headerlink" title="1.4.1 时延"></a>1.4.1 时延</h4><p>节点总时延主要包括节点处理时延、排队时延、传输时延、传播时延</p><ul><li>节点处理时延$(d_{proc})$<ul><li>检查分组首部并决定该分组导向何处所需的时间</li><li>检查比特级别的差错所需的时间</li></ul></li><li><strong>排队时延</strong>$(d_{queue})$<ul><li>在队列中，分组在链路上等待传输的时间，时延长度取决于<strong>先到达的正在排队的分组数量</strong></li></ul></li><li>传输时延$(d_{trans})$<ul><li>将分组的所有比特推向输出链路所需的时间（<a href="https://gaia.cs.umass.edu/kurose_ross/interactive/one-hop-delay.php">在线交互程序</a>）</li><li>等于分组的长度除以<strong>链路传输速率</strong>，即$L&#x2F;R$，其中$R$的单位为$bps、kbps、Mbps$等</li></ul></li><li>传播时延$(d_{prop})$<ul><li>从输出链路的起点到目的地传播所需的时间，数据以链路的传播速率传播，取决于链路的物理媒体</li><li>等于两台路由器间的距离除以<strong>链路传播速率</strong>，即$d&#x2F;s$</li></ul></li><li>关于传输时延和传播时延（<a href="https://gaia.cs.umass.edu/kurose_ross/interactive/caravan.php">在线交互程序</a>，<a href="https://gaia.cs.umass.edu/kurose_ross/interactive/end-end-delay.php">在线交互程序</a>）</li></ul><p>总传输时延$d_{nodal}&#x3D;d_{proc}+d_{queue}+d_{trans}+d_{prop}$</p><h4 id="1-4-2-丢包"><a href="#1-4-2-丢包" class="headerlink" title="1.4.2 丢包"></a>1.4.2 丢包</h4><ul><li><p>排队时延分析（<a href="https://gaia.cs.umass.edu/kurose_ross/interactive/qdelay.php">在线交互程序</a>）</p><ul><li><p>设链路传输速率为$R,bps$，分组大小为$L,bit&#x2F;pkt$，分组到达队列的平均速率$a,pkt&#x2F;s$</p></li><li><p>则比特到达队列的平均速率为$La,bps$，流量强度为$La&#x2F;R$</p></li><li><p>$La&#x2F;R\sim0$：平均排队时延很小，甚至为$0$</p><p>$La&#x2F;R &lt; 1$：时延较小，且会随时间推延而变小</p><p>$La&#x2F;R &#x3D; 1$：时延不会变化，具体数值取决于当时队列长度</p><p>$La&#x2F;R &gt; 1$： 比特到达队列的平均速率远超过从队列传输出去的速率，队列将无限增加，排队时延趋于$\infty$</p></li></ul></li><li><p>丢包</p><ul><li>当队列已满时，分组将会被路由器丢弃，分组即会丢失</li><li>丢失的分组已经传输到网络核心，但是绝不会从网络发送到目的地</li></ul></li><li><p>在$Windows$操作系统使用$tracert$命令、在$Linux$和$Mac$操作系统使用$traceroute$命令以测试端到端时延</p></li></ul><h4 id="1-4-3-吞吐量"><a href="#1-4-3-吞吐量" class="headerlink" title="1.4.3 吞吐量"></a>1.4.3 吞吐量</h4><ul><li>$P2P$系统<ul><li>服务器$\Longrightarrow$路由器$\Longrightarrow$客户端<ul><li>使用$R_s$表示服务器与路由器之间的链路速率，$R_c$表示路由器与客户端之间的链路速率</li><li>服务器不能以快于$R_s$的速率向链路发送比特，路由器也不能以大于$R_c$的速率发送比特</li><li>当$R_s&gt;R_c$时，路由器端将会出现比特等待队列，当$R_s&lt;R_c$时，数据将流畅地传输到客户端</li><li>其吞吐量被定义为$min{R_c,R_s}$</li></ul></li><li>服务器$\Longrightarrow$路由器$1$$\Longrightarrow$路由器$2$$,\cdots,$$\Longrightarrow$路由器$N$$\Longrightarrow$客户端<ul><li>吞吐量为$min{R_1,R_2,\cdots,R_N}$</li></ul></li></ul></li><li>当网络核心的链路速率远大于接入网时，吞吐量的主要限制因素便为<strong>接入网</strong></li><li>瓶颈链路：在端到端路径上限制了端到端平均吞吐量的链路（<a href="https://gaia.cs.umass.edu/kurose_ross/interactive/end-end-throughput-simple.php">在线交互程序</a>）</li></ul><h3 id="1-5-协议层次及其服务模型"><a href="#1-5-协议层次及其服务模型" class="headerlink" title="1.5 协议层次及其服务模型"></a>1.5 协议层次及其服务模型</h3><h4 id="1-5-1-协议分层"><a href="#1-5-1-协议分层" class="headerlink" title="1.5.1 协议分层"></a>1.5.1 协议分层</h4><ul><li><p>基本概念</p><ul><li><p><strong>实体</strong>是任何可以发送和接收信息的硬件和软件进程。通常是一个特定的软件模块</p></li><li><p>不同机器上包含对应层的实体称为<strong>对等体</strong>，如客户端的运输层对应服务端的运输层</p></li><li><p><strong>服务</strong>指为保证上层对等体之间能互相通信，下层向上层提供的功能</p></li><li><p><strong>接口</strong>位于每对相邻层之间，定义了下层向上层提供的原语操作和服务</p></li><li><p>**协议数据单元$(PDU)$**是对等层次上传送数据的单位</p></li><li><p>**服务数据单元$(SDU)$**是层与层之间交换数据的单位</p></li><li><p><strong>网络体系结构</strong>是层和协议的集合</p></li><li><p><strong>协议栈</strong>指一个特定的系统所使用的一系列协议（每层一组协议）</p></li></ul></li><li><p>因特网的五层结构（<a href="https://gaia.cs.umass.edu/kurose_ross/interactive/layers.php">在线交互程序</a>）</p><table><thead><tr><th align="center">层次</th><th align="center">功能</th><th align="center">协议</th><th align="center">分组名称</th></tr></thead><tbody><tr><td align="center">应用层</td><td align="center">直接为用户的网络应用程序提供服务</td><td align="center">$HTTP$、$SMTP$、$FTP$、$DNS$</td><td align="center">报文</td></tr><tr><td align="center">表示层</td><td align="center"><strong>在$OSI$模型中</strong>，统一表示数据的含义</td><td align="center">$-$</td><td align="center">$-$</td></tr><tr><td align="center">会话层</td><td align="center"><strong>在$OSI$模型中</strong>，数据交换的定界和同步</td><td align="center">$-$</td><td align="center">$-$</td></tr><tr><td align="center">运输层</td><td align="center">在不同主机的进程间数据传送</td><td align="center">$TCP$、$UDP$</td><td align="center">报文段</td></tr><tr><td align="center">网络层</td><td align="center">在不同主机间数据传送；选择合适的路由传输运输层分组</td><td align="center">网际协议$IP$，路由协议</td><td align="center">数据报</td></tr><tr><td align="center">链路层</td><td align="center">网络相邻结点间数据传送</td><td align="center">$PPP$、以太网</td><td align="center">帧</td></tr><tr><td align="center">物理层</td><td align="center">在线路上传输比特流</td><td align="center">$-$</td><td align="center">$-$</td></tr></tbody></table></li></ul><h4 id="1-5-2-网络分层模型"><a href="#1-5-2-网络分层模型" class="headerlink" title="1.5.2 网络分层模型"></a>1.5.2 网络分层模型</h4><img src="1-4 层次结构的数据流动.png" style="zoom:33%;" /><h2 id="二、应用层"><a href="#二、应用层" class="headerlink" title="二、应用层"></a>二、应用层</h2><h3 id="2-1-应用层协议原理"><a href="#2-1-应用层协议原理" class="headerlink" title="2.1 应用层协议原理"></a>2.1 应用层协议原理</h3><h4 id="2-1-1-进程通信"><a href="#2-1-1-进程通信" class="headerlink" title="2.1.1 进程通信"></a>2.1.1 进程通信</h4><ul><li><p>客户与服务器进程</p><ul><li><p>网络应用程序运行后，就变成了网络应用进程</p></li><li><p>两个在不同端系统的进程，通过跨越计算机网络交换报文而相互通信</p></li><li><p>网络应用程序由成对进程组成，在一对进程的通信会话场景中，发起通信的进程称为<strong>客户</strong>，等待联系的进程称为<strong>服务器</strong></p></li></ul></li><li><p>进程与计算机网络的接口</p><ul><li>进程通过一个称为**套接字$(Socket)$**的软件接口向网络发送报文和从网络接收报文</li><li>套接字是同一台主机内应用层与运输层的接口，也成为应用程序和网络之间的<strong>应用程序编程窗口</strong></li></ul></li><li><p>进程寻址</p><ul><li>为了与目的主机上进程的通信，需要定义<strong>目的主机的地址</strong>和<strong>目的主机中指定接收进程的标识符</strong></li><li>目的主机地址由$32$位的$IP$地址标识</li><li>目的进程地址由$16$位目的地端口号$Port,,Number$标识，如$Web$服务器的端口号为$80$，$SMTP$的端口号为$25$</li><li>套接字长度为$48$位</li></ul></li></ul><h4 id="2-1-2-运输服务简介"><a href="#2-1-2-运输服务简介" class="headerlink" title="2.1.2 运输服务简介"></a>2.1.2 运输服务简介</h4><ul><li><p>$TCP$服务</p><ul><li><strong>面向连接</strong>：在报文流动前，$TCP$让客户和服务器互相交换运输层控制信息以为分组运输做好准备（握手），此时，一个$TCP$连接在两个进程的套接字直接建立</li><li><strong>可靠性</strong>：无差错、无字节丢失与冗余、顺序地传输分组</li><li><strong>拥塞控制机制</strong>：当网络拥塞时，抑制发送进程</li><li>不提供加密机制</li></ul></li><li><p>$UDP$服务</p><ul><li>没有握手过程</li><li>不可靠数据传送服务</li><li>没有拥塞控制机制</li><li>不提供加密机制</li></ul></li><li><p>$SSL$安全套接字层</p><ul><li>提供加密的$TCP$连接</li><li>提供数据完整性和端点鉴别</li></ul></li><li><p>应用层协议与支撑的运输层协议</p><table><thead><tr><th align="center">应用</th><th align="center">应用层协议</th><th align="center">支撑的运输层协议</th></tr></thead><tbody><tr><td align="center">电子邮件</td><td align="center">$SMTP$</td><td align="center">$TCP$</td></tr><tr><td align="center">远程终端访问</td><td align="center">$Telnet$</td><td align="center">$TCP$</td></tr><tr><td align="center">$Web$、流式多媒体</td><td align="center">$HTTP$</td><td align="center">$TCP$</td></tr><tr><td align="center">文件传输</td><td align="center">$FTP$</td><td align="center">$TCP$</td></tr><tr><td align="center">因特网电话</td><td align="center">$SIP$、$RTP$</td><td align="center">$UDP$或$TCP$</td></tr></tbody></table></li></ul><h3 id="2-2-Web-和-HTTP"><a href="#2-2-Web-和-HTTP" class="headerlink" title="2.2 $Web$和$HTTP$"></a>2.2 $Web$和$HTTP$</h3><h4 id="2-2-1-HTTP-概述"><a href="#2-2-1-HTTP-概述" class="headerlink" title="2.2.1 $HTTP$概述"></a>2.2.1 $HTTP$概述</h4><ul><li><p>相关概念</p><ul><li><p>$HTTP$全称为超文本传输协议$(HyperText,,,Transfer,,,Protocol)$</p></li><li><p>$Web$页面由<strong>对象</strong>组成，如$HTML$文件，$JPEG$图像</p></li><li><p>通过$URL$地址引用对象，$URL$地址由<strong>存放对象的服务器地址</strong>和<strong>对象的路径</strong>组成</p><blockquote><p> 如对于$URL$地址$<a href="http://cloudchewie.com/index.html$%EF%BC%9A">http://cloudchewie.com/index.html$：</a></p><p>$cloudchewie.com$为主机名，$&#x2F;index.html$为对象路径</p></blockquote></li><li><p>$Web,,Browser$实现了$HTTP$的客户端，$Web,,Server$实现了$HTTP$的服务端，用于存储$Web$对象，每个对象由$URL$路径访问，因此$Web$是典型的$C&#x2F;S$模式</p></li><li><p>$HTTP$负责定义客户向服务器请求$Web$页面的方式以及服务器向客户返回$Web$页面的方式，其传递的报文称为**$HTTP报文$**</p></li><li><p>客户向其套接字接口发送$HTTP$请求报文并从其套接字接口接收$HTTP$响应报文；当客户发送报文后，该报文即脱离客户控制而进入$TCP$控制，从而使得应用层协议$HTTP$无需关心报文丢失和运输层的实现细节</p></li><li><p>$HTTP$服务器不保存关于客户的任何信息，是一个<strong>无状态协议</strong></p></li></ul></li><li><p>非持续连接</p><ul><li><p>每个$TCP$连接只传输一个请求报文和一个响应报文</p></li><li><p>当客户接收$HTTP$响应报文后，$TCP$连接关闭</p></li><li><p>如果需要继续发送请求，需要建立全新的$TCP$连接</p></li><li><p>可以使用<strong>并行的连接</strong>改善缩短响应时间</p><blockquote><p>$TCP$服务是建立在连接之上的，每次建立连接前，都需要进行三次握手过程，如下图所示：</p><img src="2-2 HTTP模型.png" style="zoom:30%;" /><ol><li>客户端向服务器发送一个小的$TCP$报文段</li><li>服务器用一个小的$TCP$报文段进行确认和响应</li><li>客户向服务器返回确认并发送$HTTP$请求报文</li><li>在这之后，服务器开始发送文件到客户</li></ol><p>其中，环节$1-2$占用了一个往返时间$RTT$，环节$3-4$占用了一个往返时间$RTT$并且耗费了传输文件的时间</p><p><strong>因此，在非持续连接的$HTTP$下，每传送一个对象，就需要经受两个$RTT$的交付时延</strong></p></blockquote></li></ul></li><li><p>持续连接</p><ul><li>服务器发送$HTTP$响应报文后保持$TCP$连接，使得客户的后续请求继续使用该连接进行传送</li><li>当该连接经过一定时间间隔（可配置的超时间隔）仍未使用，其服务器就将关闭该连接</li></ul></li></ul><h4 id="2-2-2-HTTP-报文"><a href="#2-2-2-HTTP-报文" class="headerlink" title="2.2.2 $HTTP$报文"></a>2.2.2 $HTTP$报文</h4><ul><li><p>$HTTP$请求报文（<a href="https://gaia.cs.umass.edu/kurose_ross/interactive/http-get.php">在线交互程序</a>）</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#典型的HTTP请求报文</span><br><span class="line">GET /index.html HTTP/1.1\r\n</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www-net.cs.umass.edu\r\n</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0\r\n</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml\r\n</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en-us,en;q=0.5\r\n</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip,deflate\r\n</span><br><span class="line"><span class="attribute">Accept-Charset</span><span class="punctuation">: </span>ISO-8859-1,utf-8;q=0.7\r\n</span><br><span class="line"><span class="attribute">Keep-Alive</span><span class="punctuation">: </span>115\r\n</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure><ul><li><p>请求报文的第一行称为<strong>请求行</strong>，包括方法字段、$URL$字段、$HTTP$版本字段</p><table><thead><tr><th align="center">方法字段</th><th align="center">主要作用</th></tr></thead><tbody><tr><td align="center">$GET$</td><td align="center">向服务器请求指定$URL$的对象</td></tr><tr><td align="center">$POST$</td><td align="center">用于向服务器提交表单数据也可以同时请求一个$Web$页面</td></tr><tr><td align="center">$DELETE$</td><td align="center">返回响应报文，不包含请求的对象</td></tr><tr><td align="center">$PUT$</td><td align="center">上传的文件放在实体主体字段中，目标路径由$URL$字段标明</td></tr><tr><td align="center">$HEAD$</td><td align="center">删除$URL$字段中指定的文件</td></tr></tbody></table></li><li><p>其余行称为<strong>首部行</strong></p><ul><li>$Host$指明了对象所在的主机</li><li>$Connection$指明非持续连接$(Close)$和持续连接$(keep-alive)$</li><li>$Keep-Alive$指明持续连接的超时间隔</li><li>$User-agent$指明用户浏览器类型，有助于服务器根据不同的用户代理发送相同对象的不同版本</li><li>$Accept-*$指用户想要得到特定语言、编码格式、字符集的该对象</li></ul></li><li><p>结尾单独一行回车、换行表示报文首部结束</p></li><li><p><strong>实体体</strong>，在首部行之后的请求体</p><ul><li>当发送$GET$请求时，实体体为空；</li><li>当用户填写表单并发送$POST$请求时，实体体即为用户填写的表单；</li><li>当用户填写表单时，也可以使用$GET$方法，如<code>/learning/search?key=banana&amp;lang=zh</code></li></ul></li><li><p>$HTTP$请求报文的通用格式</p><img src="2-3 HTTP请求报文通用格式.png" style="zoom:33%;" /></li></ul></li><li><p>$HTTP$响应报文（<a href="https://gaia.cs.umass.edu/kurose_ross/interactive/http-response.php">在线交互程序</a>）</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#典型的HTTP响应报文</span><br><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK\r\n</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Sun, 26 Sep 2010 20:09:20 GMT\r\n</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Apache/2.0.52 (CentOS)\r\n</span><br><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Tue, 30 Oct 2007 17:00:02 GMT\r\n</span><br><span class="line"><span class="attribute">ETag</span><span class="punctuation">: </span>&quot;17dc6-a5c-bf716880&quot;\r\n</span><br><span class="line"><span class="attribute">Accept-Ranges</span><span class="punctuation">: </span>bytes\r\n</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>2652\r\n</span><br><span class="line"><span class="attribute">Keep-Alive</span><span class="punctuation">: </span>timeout=10, max=100\r\n</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Keep-Alive\r\n</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html; charset=ISO-8859-1\r\n</span><br><span class="line">\r\n</span><br><span class="line">data data data data data ... </span><br></pre></td></tr></table></figure><ul><li><p>响应报文的第一行称为<strong>初始状态行</strong>，包括协议版本字段、状态码、状态信息</p><table><thead><tr><th align="center">状态码</th><th align="center">状态信息</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">$200$</td><td align="center">$OK$</td><td align="center">请求成功</td></tr><tr><td align="center">$301$</td><td align="center">$Moved,,,Permanently$</td><td align="center">请求的对象被永久转移，新的$URL$定义在$Location$首部行</td></tr><tr><td align="center">$400$</td><td align="center">$Bad,,,Request$</td><td align="center">通用差错代码，请求不能被服务器理解</td></tr><tr><td align="center">$404$</td><td align="center">$Not,,,Found$</td><td align="center">被请求的对象不在服务器</td></tr><tr><td align="center">$500$</td><td align="center">$HTTP,,,Version,,,Not,,,Supported$</td><td align="center">服务器不支持请求报文中的$HTTP$协议版本</td></tr></tbody></table></li><li><p>其余行称为首部行</p><ul><li>$Date$指示服务器发送响应报文的日期时间</li><li>$Server$指示服务器类型，类似于请求报文中的$User-agent$</li><li>$Last,,Modified$指示对象创建或最后修改的日期时间</li><li>$Content-Length$指示被发送对象的字节数</li><li>$Content-Type$指示实体体中对象为$HTML$文本</li></ul></li><li><p>实体体包含被请求的对象</p></li><li><p>$HTTP$响应报文的通用格式</p></li></ul><img src="2-4 HTTP响应报文通用格式.png" style="zoom:33%;" /></li></ul><h4 id="2-2-3-Cookie"><a href="#2-2-3-Cookie" class="headerlink" title="2.2.3 $Cookie$"></a>2.2.3 $Cookie$</h4><ul><li>$Cookie$的意义<ul><li>限制用户的访问</li><li>将内容与用户身份相关联</li><li>在无状态的$HTTP$上建立用户会话层</li></ul></li><li>$Cookie$的组成<ul><li>$HTTP$响应报文中的$Cookie$首部行</li><li>$HTTP$请求报文中的$Cookie$首部行</li><li>端系统中保留$Cookie$文件</li><li>$Web$服务器的$Cookie$数据库</li></ul></li><li>$Cookie$的使用<ul><li>客户向服务器发送<u>普通请求报文</u></li><li>服务器为客户创建$ID$如<code>U202073245</code>并放置在响应报文的首部行</li><li>客户存储$Cookie$</li><li>客户将$Cookie$放置在请求报文的首部行</li><li>服务器根据**$Cookie$采取指定动作**，并返回普通响应报文</li></ul></li></ul><h3 id="2-3-电子邮件"><a href="#2-3-电子邮件" class="headerlink" title="2.3 电子邮件"></a>2.3 电子邮件</h3><h4 id="2-3-1-电子邮件系统的构成"><a href="#2-3-1-电子邮件系统的构成" class="headerlink" title="2.3.1 电子邮件系统的构成"></a>2.3.1 电子邮件系统的构成</h4><ul><li>用户代理<ul><li>用户可以撰写编辑邮件、查看邮件</li><li>如网易邮箱大师、$FoxMail$</li></ul></li><li>邮件服务器<ul><li>存储用户邮件的服务器</li><li>在报文队列中维护需要发送的邮件报文</li></ul></li><li>简单邮件传输协议$SMTP$<ul><li>将邮件从发送方的客户端发送到发送方的邮件服务器</li><li>将邮件从发送方的邮件服务器发送到接收方的邮件服务器</li></ul></li></ul><h4 id="2-3-2-SMTP-协议"><a href="#2-3-2-SMTP-协议" class="headerlink" title="2.3.2 $SMTP$协议"></a>2.3.2 $SMTP$协议</h4><ul><li><p>基本介绍（<a href="https://gaia.cs.umass.edu/kurose_ross/interactive/smtp.php">在线交互程序</a>）</p><ul><li>使用$TCP$运输协议进行可靠的邮件传送，端口号为$25$</li><li>不使用中间邮件服务器发送邮件，而是<strong>直接在发送方服务器和接收方服务器间进行传输</strong></li><li>使用持续连接</li><li>要求报文（首部和信体）全部使用$ 7-bit,,ASCII$码</li><li>$SMTP$服务器用$CRLF.CRLF $表示邮件报文的结束</li></ul><img src="2-5 SMTP流程.png" style="zoom:67%;" /></li><li><p>报文格式</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">From</span><span class="punctuation">: </span>alice@qq.com</span><br><span class="line"><span class="attribute">To</span><span class="punctuation">: </span>Bob@google.com</span><br><span class="line"><span class="attribute">Subject</span><span class="punctuation">: </span>Searching for the meaning of life.</span><br></pre></td></tr></table></figure></li><li><p>与$HTTP$协议的对比</p><table><thead><tr><th align="center"></th><th align="center">$HTTP$</th><th align="center">$SMTP$</th></tr></thead><tbody><tr><td align="center">协议类型</td><td align="center">拉协议</td><td align="center">推协议</td></tr><tr><td align="center">报文编码格式</td><td align="center">不限制</td><td align="center">$ 7-bit,,ASCII$</td></tr><tr><td align="center">多对象</td><td align="center">每个对象分装在各自的响应报文中</td><td align="center">多个对象在多分部的报文中</td></tr></tbody></table></li><li><p>使用$telnet$指令访问$QQ$邮箱</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">telnet smtp.qq.com 25</span><br><span class="line">auth login</span><br><span class="line">base64-mail</span><br><span class="line">base64-authentication-code</span><br><span class="line">helo qq.com</span><br><span class="line">mail from:&lt;xxx@xx.xx&gt;</span><br><span class="line">rcpt to:&lt;xxx@xx.xx&gt;</span><br><span class="line">data</span><br><span class="line">Hello World!</span><br><span class="line">Hello World!</span><br><span class="line">.</span><br><span class="line">quit</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-3-3-POP3-协议"><a href="#2-3-3-POP3-协议" class="headerlink" title="2.3.3 $POP3$协议"></a>2.3.3 $POP3$协议</h4><ul><li><p>运行在端口$110$的邮件访问协议</p></li><li><p>运行方式</p><ul><li><p>特许阶段：用户代理发送用户名和口令以鉴别用户</p><blockquote><p>主要命令：$user,<username>$和$pass,<password>$</p><p>服务器的响应回答有$+OK$、$-ERR$</p></blockquote></li><li><p>事务处理阶段：用户代理取回报文，同时可以对报文做删除标记的更改，获取邮件统计信息</p><blockquote><p>$list$——列出报文号码</p><p>$retr$——用报文号码取回报文</p><p>$dele$——用报文号码删除邮件</p></blockquote></li><li><p>更新阶段</p><blockquote><p>$quit$——结束$POP3$会话，服务器删除被标记为删除的邮件</p></blockquote></li></ul></li><li><p>使用$telnet$指令访问$QQ$邮箱</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">telnet pop.qq.com 110</span><br><span class="line">user QQ-ID</span><br><span class="line">pass authentication-code</span><br><span class="line">list</span><br><span class="line">retr 1</span><br><span class="line">dele 1</span><br><span class="line">quit</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-3-4-IMAP-协议"><a href="#2-3-4-IMAP-协议" class="headerlink" title="2.3.4 $IMAP$协议"></a>2.3.4 $IMAP$协议</h4><ul><li><p>允许用户在服务器上组织自己的<strong>邮件目录</strong></p></li><li><p>维护$IMAP$会话的用户信息：目录名以及报文$ID$与目录名之间的映射关系</p></li><li><p>使用$telnet$指令访问$QQ$邮箱</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">telnet imap.qq.com 143</span><br><span class="line">a01 login QQ-ID authentication-code</span><br><span class="line">a02 list &quot;&quot; *</span><br><span class="line">a03 select inbox</span><br><span class="line">a04 create folder</span><br><span class="line">a05 delete folder</span><br><span class="line">a06 rename oldfolder new folder</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-4-DNS"><a href="#2-4-DNS" class="headerlink" title="2.4 $DNS$"></a>2.4 $DNS$</h3><h4 id="2-4-1-DNS-服务"><a href="#2-4-1-DNS-服务" class="headerlink" title="2.4.1 $DNS$服务"></a>2.4.1 $DNS$服务</h4><ul><li>$DNS$简况（<a href="https://gaia.cs.umass.edu/kurose_ross/interactive/dns.php">在线交互程序</a>）<ul><li>$DNS$能够将主机名解析为主机的$IP$地址</li><li>$DNS$是一个分布式数据库，由很多$DNS$服务器按照层次结构组织</li><li>$DNS$运行在端到端系统上，且使用$UDP$协议（$53$号端口）进行报文传输</li></ul></li><li>$DNS$解析过程<ul><li>用户请求$URL$<code>http://cloudchewie.com/index.html</code></li><li>浏览器抽取出主机名<code>cloudchewie.com</code>并发送给$DNS$客户端</li><li>$DNS$客户端向$DNS$服务器发送查询请求报文</li><li>$DNS$服务器返回包含主机名对应$IP$地址的响应报文</li><li>$DNS$客户端将$IP$地址传送给浏览器</li><li>浏览器向$IP$地址所在$Web$服务器发起$TCP$连接</li></ul></li><li>其他服务<ul><li>主机别名：获取主机别名对应的主机规范名</li><li>邮件服务器别名：获取邮件服务器主机别名对应的主机规范名</li><li>负载分配：将一个$IP$地址<strong>集合</strong>与<strong>同一个规范主机名</strong>相联系</li></ul></li></ul><h4 id="2-4-2-DNS-工作机理"><a href="#2-4-2-DNS-工作机理" class="headerlink" title="2.4.2 $DNS$工作机理"></a>2.4.2 $DNS$工作机理</h4><ul><li><p>采用单台$DNS$服务器</p><ul><li>单点故障：一旦崩溃，因特网瘫痪</li><li>通信容量：该台服务器不得不处理所有$HTTP$请求报文和电子邮件报文</li><li>时延严重：集中式数据库将造成严重的拥塞与时延</li><li>难以维护：不得不持续更新以适应数据更改</li></ul></li><li><p>采用分布式层次化数据库</p><img src="2-6 DNS实现.png" style="zoom:30%;" /><ul><li>根服务器提供$TLD$服务器的$IP$地址</li><li>$TLD$服务器提供权威服务器的$IP$地址，负责所有顶级域名和所有国家顶级域</li><li>权威服务器提供域名到$IP$地址的映射服务</li><li>本地$DNS$服务器（默认$DNS$服务器）<ul><li>当一台主机需要做一个域名查询的时候，查询请求首先被发送到本地域名服务器</li></ul></li></ul></li><li><p>递归查询与迭代查询（<a href="https://gaia.cs.umass.edu/kurose_ross/interactive/dns_query.php">在线交互程序</a>）</p></li><li><p>$DNS$缓存（<a href="https://gaia.cs.umass.edu/kurose_ross/interactive/DNS_HTTP_delay.php">在线交互程序</a>）</p><ul><li>一旦 (任何) 域名服务器得知了某个映射, 就将其缓存</li><li>在一定的时间间隔后缓存的条目将会过期（自动消除）</li><li>$TLD$服务器的地址通常被缓存在本地$DNS$服务器中，以减少根服务器负载</li></ul></li></ul><h4 id="2-4-3-DNS-记录"><a href="#2-4-3-DNS-记录" class="headerlink" title="2.4.3 $DNS$记录"></a>2.4.3 $DNS$记录</h4><p>格式为四元组$(Name,Value,Type,TTL)$，其中$TTL$表示记录的生存时间</p><table><thead><tr><th align="center">$Type$</th><th align="center">$Name$</th><th align="center">$Value$</th></tr></thead><tbody><tr><td align="center">$A$</td><td align="center">主机名</td><td align="center">$IP$地址</td></tr><tr><td align="center">$CNAME$</td><td align="center">主机别名</td><td align="center">规范主机名</td></tr><tr><td align="center">$NS$</td><td align="center">域</td><td align="center">该域权威域名服务器的<strong>主机名</strong></td></tr><tr><td align="center">$MX$</td><td align="center">邮件服务器的主机别名</td><td align="center">邮件服务器的规范主机名</td></tr></tbody></table><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用nslookup进行DNS解析</span></span><br><span class="line"><span class="comment">#进入交互模式</span></span><br><span class="line">nslookup</span><br><span class="line">server www.net.cn</span><br><span class="line">server dns.hust.edu.cn</span><br><span class="line"><span class="built_in">set</span> ty=A</span><br><span class="line">cloudchewie.com</span><br><span class="line">hust.edu.cn</span><br><span class="line"><span class="built_in">set</span> ty=ns</span><br><span class="line">cloudchewie.com</span><br><span class="line"><span class="built_in">set</span> ty=cname</span><br><span class="line">cloudchewie.com</span><br><span class="line"><span class="built_in">set</span> ty=mx</span><br><span class="line">hust.edu.com</span><br></pre></td></tr></table></figure><h2 id="三、运输层"><a href="#三、运输层" class="headerlink" title="三、运输层"></a>三、运输层</h2><h3 id="3-1-运输层服务"><a href="#3-1-运输层服务" class="headerlink" title="3.1 运输层服务"></a>3.1 运输层服务</h3><h4 id="3-1-1-基本概念"><a href="#3-1-1-基本概念" class="headerlink" title="3.1.1 基本概念"></a>3.1.1 基本概念</h4><ul><li>运输层为不同主机上运行的应用进程提供逻辑通信信道$(logical,,,communication)$</li><li>发送方把应用数据划分为<strong>报文段</strong>，交给网络层；接收方把报文段重组成应用数据，交付给应用层</li><li>网络层协议<ul><li>网际协议$IP$是<strong>不可靠服务</strong>，它将<strong>尽力而为</strong>地在不同通信主机间交付报文段</li><li>但是它并不确保报文段的交付，不保证报文段按序交付，不保证报文段中数据完整性</li></ul></li><li>运输层是<strong>应用进程</strong>之间的逻辑通信，网络层是<strong>不同主机</strong>之间的逻辑通信</li><li>运输层将<strong>两个端系统间</strong>$IP$的交付服务扩展为在端系统上的<strong>两个进程之间</strong>的交付服务</li></ul><h4 id="3-1-2-基本模型"><a href="#3-1-2-基本模型" class="headerlink" title="3.1.2 基本模型"></a>3.1.2 基本模型</h4><ul><li>假设家庭$A$的$6$个孩子要与家庭$B$的$6$个孩子相互写信</li><li>家庭$A$中的$Amy$负责收集所有信件并投递到邮局，并且负责将家庭$B$寄来的所有信件送到每个人手中</li><li>家庭$B$中的$Bob$负责收集所有信件并投递到邮局，并且负责将家庭$A$寄来的所有信件送到每个人手中<ul><li>进程$&#x3D; $孩子们</li><li>应用层报文$ &#x3D; $信封中的信笺</li><li>主机$ &#x3D; $家庭</li><li>运输层协议$ &#x3D; $$Amy$和$Bob$</li><li>网络层协议$ &#x3D; $邮局提供的服务</li></ul></li><li>$Amy$和$Bob$只在各自家里进行收发工作<ul><li>运输层协议只工作在端系统中</li></ul></li><li>假如$Amy$和$Bob$外出度假，分别替换成年龄较小的$Lisa$和$John$，他们可能会由于粗心大意丢失信件<ul><li>不同运输层协议提供的服务模型不一样，如$UDP$和$TCP$</li></ul></li><li>邮局不承诺信件送达的时间<ul><li>运输层协议能够提供的服务<strong>受到底层网络协议的服务模型的限制</strong></li></ul></li><li>邮局不承诺信件一定安全可靠的送达，可能在路上丢失，但$Amy$和$Bob$可在较长时间内没有受到对方的回信时，再次誊写信件并寄出<ul><li>在网络层不提供某些服务的情况下，运输层自己提供</li></ul></li></ul><h3 id="3-2-多路分解和多路复用"><a href="#3-2-多路分解和多路复用" class="headerlink" title="3.2 多路分解和多路复用"></a>3.2 多路分解和多路复用</h3><h4 id="3-2-1-基本概念"><a href="#3-2-1-基本概念" class="headerlink" title="3.2.1 基本概念"></a>3.2.1 基本概念</h4><ul><li><p>多路分解：将运输层报文段中的数据交付到正确的套接字的工作</p></li><li><p>多路复用：在源主机从不同套接字收集数据块，并为每个数据块封装首部信息（用于多路分解）生成报文段，然后将报文段传送到网络层</p></li></ul><h4 id="3-2-2-要求"><a href="#3-2-2-要求" class="headerlink" title="3.2.2 要求"></a>3.2.2 要求</h4><ul><li>套接字有唯一标识符</li><li>每个报文段<strong>有特殊字段指示该报文段要交付到的套接字</strong><ul><li>包括<strong>源端口号字段</strong>和<strong>目的端口号字段</strong>，各占$16,,bit$</li><li>其中$0\sim1023$范围的端口号称为周知端口号，保留给诸如$HTTP$、$SMTP$等周知应用层协议</li></ul></li></ul><h4 id="3-2-3-无连接的多路分解与多路复用"><a href="#3-2-3-无连接的多路分解与多路复用" class="headerlink" title="3.2.3 无连接的多路分解与多路复用"></a>3.2.3 无连接的多路分解与多路复用</h4><ul><li>一个$UDP$套接字是<strong>由一个<u>二元组</u>全面标识的</strong>，具体为<strong>（源端口号，目的端口号）</strong></li><li>如果两个报文段具有不同的$IP$地址或源端口号，但是具有相同的目的$IP$地址和目的端口号，那么这两个报文段将<strong>通过相同的目的套接字被定向到相同的目的进程</strong></li><li>具体过程<ul><li>创建套接字：运输层自动为其分配一个端口号$(1024\sim65535)$，或者指定一个端口号</li><li>假设主机$A$中的一个进程具有$UDP$端口$19157$，欲发送一个报文给位于主机$B$中的另一进程，其具有$UDP$端口$46428$</li><li>主机$A$中的运输层封装报文，添加源端口号$19157$，目的端口号$46428$以及其他两个字段得到报文段</li><li>运输层将报文段传递到网络层，网络层封装$IP$数据包并尽力而为地传送到接收主机</li><li>如果报文段到达主机$B$，主机$B$中的运输层即检查目的端口号$46428$，并将报文段交付给端口号为$46428$的套接字</li><li>当主机$B$需要回发报文段给$A$时，即需要<strong>将来自$A$的报文段中的源端口号作为目的端口号</strong>发送报文段</li></ul></li></ul><h4 id="3-2-4-面向连接的多路分解与多路复用"><a href="#3-2-4-面向连接的多路分解与多路复用" class="headerlink" title="3.2.4 面向连接的多路分解与多路复用"></a>3.2.4 面向连接的多路分解与多路复用</h4><ul><li><p>一个$TCP$是<strong>由一个<u>四元组</u>全面标识的</strong>，具体为<strong>（源$IP$地址，源端口号，目的$IP$地址，目的端口号）</strong></p></li><li><p>与$UDP$协议不同，如果两个报文段具有不同的$IP$地址或源端口号，而且具有相同的目的$IP$地址和目的端口号，那么这两个报文段将<strong>通过不同的目的套接字被定向到不同的目的进程</strong></p></li><li><p>具体过程</p><ul><li>假设主机$A$中的一个进程具有$TCP$端口$19157$，欲发送一个报文给位于主机$B$中的另一进程，其具有$TCP$端口$46428$</li><li>同时主机$C$中的一个进程也具有$TCP$端口$19157$，也要发送报文给主机$B$中具有$TCP$端口$46428$的进程</li><li>主机$B$<strong>依然能够正确分解具有两个相同源端口号和目的端口号的连接</strong>，因为二者的$IP$地址不同，决定着其套接字不同</li></ul></li><li><p>$Web$服务器与$TCP$</p><ul><li><p>在$Web$服务器中，当客户发送请求时，所有报文段的目的端口号都将为$80$，这时服务器根据源$IP$地址和源端口号来区分来自不同客户的报文段</p></li><li><p>在当今的高性能服务器中，通常只使用一个进程，而是通过为不同的套接字创建<strong>新的线程（轻量级子进程）</strong>提供服务</p><blockquote><p>非持久$HTTP$对每一个请求都建立不同的套接字，会影响性能</p></blockquote></li></ul></li></ul><h3 id="3-3-UDP-协议"><a href="#3-3-UDP-协议" class="headerlink" title="3.3 $UDP$协议"></a>3.3 $UDP$协议</h3><h4 id="3-3-1-UDP-报文段格式"><a href="#3-3-1-UDP-报文段格式" class="headerlink" title="3.3.1 $UDP$报文段格式"></a>3.3.1 $UDP$报文段格式</h4><img src="3-2 UDP报文段格式.png" style="zoom:33%;" /><ul><li><strong>长度字段</strong>指示了包括首部在内的报文段中<strong>字节</strong>数</li><li><strong>校验和</strong>用于接收方校验报文段是否发生差错</li></ul><h4 id="3-3-2-UDP-校验和"><a href="#3-3-2-UDP-校验和" class="headerlink" title="3.3.2 $UDP$校验和"></a>3.3.2 $UDP$校验和</h4><ul><li><p>发送方</p><ul><li><p>把报文段看作是**$16$比特字的序列**</p></li><li><p>对报文段的所有$16$比特字的和进行<strong>反码</strong>运算，加法有溢出时，需要将进位加到末尾</p></li><li><p>将计算校验和的结果写入$UDP$校验和字段中</p></li></ul></li><li><p>接收方</p><ul><li>将<strong>包括校验和在内</strong>的所有$16$比特字加在一起</li><li>如果没有差错，结果将为$1111,1111,1111,1111$</li></ul></li><li><p>无法纠正错误</p></li></ul><h4 id="3-3-2-UDP-与-TCP-对比"><a href="#3-3-2-UDP-与-TCP-对比" class="headerlink" title="3.3.2 $UDP$与$TCP$对比"></a>3.3.2 $UDP$与$TCP$对比</h4><table><thead><tr><th align="center">$UDP$</th><th align="center">$TCP$</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">无需建立连接</td><td align="center">需要建立连接（握手）</td><td align="center">建立连接会增加时延</td></tr><tr><td align="center">无需维护连接状态</td><td align="center">需要维护连接状态</td><td align="center"></td></tr><tr><td align="center">首部$8,,Byte$</td><td align="center">首部$20,,Byte$</td><td align="center">$UDP$段首部开销较小</td></tr><tr><td align="center">无拥塞控制，可按需随时发送</td><td align="center">有拥塞控制</td><td align="center">大量使用$UDP$会导致路由器中堆积分组，挤占$TCP$会话</td></tr><tr><td align="center">适用于$DNS$服务、因特网电话</td><td align="center">适用于$Web$服务、电子邮件</td><td align="center"></td></tr></tbody></table><h3 id="3-4-可靠数据传输"><a href="#3-4-可靠数据传输" class="headerlink" title="3.4 可靠数据传输"></a>3.4 可靠数据传输</h3><h4 id="3-4-1-可靠数据传输概述"><a href="#3-4-1-可靠数据传输概述" class="headerlink" title="3.4.1 可靠数据传输概述"></a>3.4.1 可靠数据传输概述</h4><ul><li><p>可靠数据传输：数据<strong>不会丢失</strong>且数据<strong>不会出错</strong></p></li><li><p><strong>网络层的$IP$协议是不可靠信道</strong>，因此为了实现可靠数据传输，<strong>需要在<u>运输层</u>做出保证可靠数据传输的工作</strong></p></li><li><p>可靠数据传输协议模型</p><img src="3-3 RDT模型.png" style="zoom:30%;" /></li><li><p>使用有限状态机$FSM$描述发送方和接收方</p><img src="3-4 FSM模型.png" style="zoom:35%;" /><ul><li>在模型中，存在多个状态</li><li>事件引起状态的变化</li><li>状态变化过程中又会存在一系列动作的发生，以完成状态的转换</li></ul></li></ul><h4 id="3-4-2-可靠信道上的可靠传输"><a href="#3-4-2-可靠信道上的可靠传输" class="headerlink" title="3.4.2 可靠信道上的可靠传输"></a>3.4.2 可靠信道上的可靠传输</h4><ul><li><p>信道模型：不会发生比特传输错误，不会造成分组丢失</p></li><li><p>有限状态机$FSM$</p><img src="3-5 RDT1.0.png" style="zoom:50%;" /><ul><li>发送方——发送分组：发送报文段，继续等待上层调用发送分组</li></ul></li><li><p>接收方——接收分组：分解得到数据</p></li></ul><h4 id="3-4-3-简单停等协议"><a href="#3-4-3-简单停等协议" class="headerlink" title="3.4.3 简单停等协议"></a>3.4.3 简单停等协议</h4><ul><li><p>信道模型：分组比特可能受损，但分组将按序接收，不会丢失</p></li><li><p>停止等待协议：每次发送分组后，发送方需要等待接收方的反馈</p></li><li><p>设想方案</p><ul><li>第一步：判断分组受损——<strong>差错检测</strong></li><li>第二步：通知发送方分组是否受损——<strong>接收方反馈$(ACK与NAK)$</strong></li><li>第三步：得知分组受损$(NAK)$后，发送方的处理手段——<strong>出错重传</strong></li></ul></li><li><p>有限状态机$FSM$</p><img src="3-6 RDT2.0.png" style="zoom:70%;" /><ul><li>发送方<ul><li>发送分组：生成校验码$checksum$，用于进行差错检测，发送报文段，跳转到等待状态</li><li>反馈$ACK$：清除缓冲区中的报文段，跳转到等待上层调用发送分组的状态</li><li>反馈$NAK$：重新发送报文段（保存在缓冲区中），继续等待反馈</li></ul></li><li>接收方<ul><li>接收到的分组出错$(corrupt)$：生成$NAK$报文段，发送给发送方</li><li>接收到的分组正确$(notcorrupt)$：分解得到数据，生成$ACK$报文段，发送给发送方</li></ul></li></ul></li><li><p>新的问题：$ACK$和$NAK$分组也可能受损</p><ul><li>受损的分组视为$ACK$不合适</li><li>受损的分组视为$NAK$可能导致接收方重复收到分组——<strong>对分组进行编号，便于接收方识别是新分组还是旧分组</strong></li></ul></li><li><p>改进后的有限状态机$FSM$</p><img src="C:/Users/ruida/AppData/Roaming/Typora/typora-user-images/image-20221014150425598.png" alt="image-20221014150425598" style="zoom:70%;" /><ul><li><p>取消$NAK$</p><ul><li>取消$NAK$，接收方对最后一个正确收到的分组发送$ACK$</li><li>同时，$ACK$中必须指出被确认分组的序号，以便于接收方标识正确收到了哪一个分组</li><li>$Double,,ACK&#x3D;NAK$</li></ul></li><li><p>取消$NAK$后的有限状态机$FSM$</p><img src="3-8 RDT2.2.png" style="zoom:70%;" /></li></ul></li></ul><h4 id="3-4-4-实用停等协议"><a href="#3-4-4-实用停等协议" class="headerlink" title="3.4.4 实用停等协议"></a>3.4.4 实用停等协议</h4><ul><li><p>信道模型：分组比特可能受损，还可能会丢包</p></li><li><p>如何检测丢包：耐心的等待——<strong>超时重传</strong></p></li><li><p>有限状态机$FSM$</p><img src="3-9 RDT3.0.png" style="zoom:70%;" /></li><li><p>性能低下</p><ul><li><strong>信道利用率：传输时间&#x2F;总时间（从发送方开始传输到发送方接收到反馈所用的时间）</strong></li><li>假设某条$1Gbps$的链路，存在$15ms$的端到端时延，则传送$1KB$大小的分组所用的时间为$T_{trans}+RTT&#x3D;\frac{1KB}{1Gbps}+15ms\times2&#x3D;30.008ms$，也即链路速度被限制为$33KB&#x2F;sec$的吞吐量</li><li>网络协议大大限制了物理资源的利用率，实际上用于传输分组的时间只占$\frac{0.008}{30.008}&#x3D;0.00027$</li></ul></li></ul><h4 id="3-4-5-滑动窗口协议"><a href="#3-4-5-滑动窗口协议" class="headerlink" title="3.4.5 滑动窗口协议"></a>3.4.5 滑动窗口协议</h4><ul><li><p>解决方案：允许发送方发送多个分组后再等待确认</p><ul><li>必须增大序号范围</li><li>发送方和接收方需要对分组进行缓存</li></ul></li><li><p>流水线技术工作原理</p><ul><li><p>用$k$位进行序号编码</p></li><li><p>扩大发送方乃至接收方的缓冲区大小——<strong>窗口</strong></p><img src="3-10 缓冲区示意图.png" style="zoom:67%;" /></li><li><p>当丢失一个分组后，如何进行重传</p><table><thead><tr><th align="center"></th><th align="center">$GBN(Go,,Back,,N)$协议</th><th align="center">选择重传$(SR)$协议</th></tr></thead><tbody><tr><td align="center">确认方式</td><td align="center">累计确认</td><td align="center">单个确认</td></tr><tr><td align="center">定时器</td><td align="center">对所有已发送但未确认的分组统一设置定时器</td><td align="center">对所有已发送但未确认的分组分别设置定时器</td></tr><tr><td align="center">超时$(n)$</td><td align="center">重传分组$n$和窗口中所有序号大于$n$的分组</td><td align="center">仅重传分组$n$</td></tr><tr><td align="center">失序分组</td><td align="center">丢弃（不缓存），接收方缓冲区大小为$1$个分组</td><td align="center">缓存，接收方缓冲区大小与发送方一致</td></tr><tr><td align="center">失序分组处理</td><td align="center">重发按序到达的最高序号分组的$ACK$</td><td align="center">对失序分组进行选择性确认</td></tr><tr><td align="center">要求</td><td align="center">$W_s\le2^k-1,W_r&#x3D;1$</td><td align="center">$W_s,W_r\le2^{k-1}$</td></tr></tbody></table></li></ul></li><li><p>分组序号长度与窗口大小的关系</p><ul><li>假设分组序号为$k$位，发送窗口大小为$W_s$，接收窗口大小为$W_r$，发送窗口当前序号为$i,\cdots,i+W_{s-1}$</li><li>极端情况下，发送的所有分组均正常接收，但是$ACK$均丢失，则<ul><li>发送窗口当前序号为$i,\cdots,i+W_{s-1}$</li><li>接收窗口当前序号为$i+W_s,\cdots,(i+W_s+W_{r-1}),,mod,,2^k$</li><li>两个窗口序号不重复，且均在$[0,2^k-1]$内</li></ul></li><li>要求$W_s+W_r\le2^k$</li></ul></li></ul><h3 id="3-5-TCP-协议"><a href="#3-5-TCP-协议" class="headerlink" title="3.5 $TCP$协议"></a>3.5 $TCP$协议</h3><h4 id="3-5-1-TCP-工作流程"><a href="#3-5-1-TCP-工作流程" class="headerlink" title="3.5.1 $TCP$工作流程"></a>3.5.1 $TCP$工作流程</h4><ul><li>建立连接——三次握手<ul><li>客户发送一个特殊的$TCP$报文段</li><li>服务器也发送一个特殊的$TCP$报文段作为响应</li><li>客户再发送一个特殊的报文段作为响应，可以承载有效负荷</li></ul></li><li>发送数据<ul><li>客户进程从套接字传递出数据流，经过该门后即进入$TCP$控制</li><li>$TCP$将数据流引导至该连接的<strong>发送缓存</strong>中</li><li>$TCP$每次取出一块数据放入报文段中进行运输，每次取出的数据数量受限于<strong>最大报文段长度</strong>$MSS$，而该值受限于<strong>最大链路层帧长度</strong>$MTU$（能从源到目的地的所有链路上发送的最大链路层帧）</li><li>$MSS$指报文段中应用层数据的最大长度，而不包含$TCP$首部</li></ul></li><li>$TCP$是<strong>全双工</strong>的</li></ul><h4 id="3-5-2-TCP-报文"><a href="#3-5-2-TCP-报文" class="headerlink" title="3.5.2 $TCP$报文"></a>3.5.2 $TCP$报文</h4><img src="3-11 TCP报文首部结构.png" style="zoom: 33%;" /><ul><li><p>序号：<strong>报文段的首个字节在整个字节流中的的序号</strong>，是离散型编号</p><blockquote><p>假设数据流包含$500000$字节，$MSS$为$1000$字节，那么将构建$500$个报文段，其序号依次为$0$、$1000$、$2000$等等</p></blockquote></li><li><p>确认号（期待号）：期待得到的下一个字节的序号，当$ACK$字段为$1$时，确认号才有效</p><blockquote><p>如确认号为$n+1$时表示接收方接收到第$n$号，期望得到$n+1$号分组，这称为<strong>累计确认</strong></p></blockquote></li><li><p>首部长度：$TCP$最长$60$个字节，以$4$个字节为单位进行递进，即与图示行数相同，取值为$[5,15]$</p></li><li><p>窗口：用于$TCP$流量控制</p></li><li><p>检验和：差错检测</p></li><li><p>紧急指针：当$URG$字段为$1$时，表示需要传送紧急数据；紧急指针指示了紧急数据的结尾</p><blockquote><p>当$PSH$字段为$1$时，整个数据部分都为紧急数据</p></blockquote></li></ul><h4 id="3-5-3-TCP-机制"><a href="#3-5-3-TCP-机制" class="headerlink" title="3.5.3 $TCP$机制"></a>3.5.3 $TCP$机制</h4><ul><li><p>快速重传</p><ul><li>原因：超时周期往往太长，增加重发丢失分组的延时</li><li>通过重复的$ACK$检测丢失报文段：如果发送收到一个数据的$3$个<strong>冗余</strong>$ACK$，即确认数据之后的报文段丢失，以在超时到来之前重传报文段</li><li>每次$TCP$重传都会将下一次超时间隔设置为先前值的两倍</li></ul></li><li><p>流量控制</p><ul><li><p>可变滑动窗口：接收方将缓冲区的空闲空间大小写入报文段返回给发送方，发送方根据空闲空间大小调整发送窗口大小</p></li><li><p>当发送方接收到空闲空间大小为$0$时，为避免进入假死状态（发送方不发送报文段，接收方不发送反馈），发送方会持续发送小的报文段试探接收方</p></li><li><p>当接收方重新获得空间空间后，小报文段将会被接收方响应处理并反馈空闲空间大小给发送方</p></li></ul></li><li><p>拥塞控制</p><ul><li><p>拥塞：包括<strong>丢包</strong> (路由器缓冲区溢出）和<strong>时延长</strong> (在路由器缓冲区排队）</p><ul><li>当路由器缓存无限大且不会重传时，随着发送方速率的增大，接收方速率也会增大；但当接收方速率饱和时，吞吐量也随之固定。而此时，也就意味着在路由器缓冲区排队的分组越来越多，造成越来越大的排队时延</li><li>当路由器缓存有限且会对丢失的分组重传时，对延迟到达（而非丢失）的分组的重传使得发送方速率比理想情况下更大于接收方速率；发送方在遇到大时延时所进行的不必要重传会引起路由器转发不必要的分组拷贝而占用其链路带宽</li><li>当路由器缓存有限且会进行超时重传时，由于超时重传，当分组被丢弃时，该分组曾用到的所有<strong>上游</strong>传输容量被浪费</li></ul></li><li><p>端到端拥塞控制</p><ul><li>每个发送方自动感知网络拥塞的程度，发送方根据感知的结果限制外发的流量</li><li>如何限制外发流量：控制拥塞窗口长度</li><li>如何感知拥塞程度：超时或者$3$个冗余$ACK$</li><li>如何调节发送速率：加性增，乘性减（出现丢包事件后将当前$ CongWin $大小减半，可以大大减少注入到网络中的分组数；当没有丢包事件发生，每个$RTT$之后将$CongWin$增大$1$个$MSS$，使拥塞窗口缓慢增大，防止网络过早拥塞）</li></ul></li><li><p>$Reno$算法</p><ul><li>慢启动：$ CongWin &#x3D; 1 MSS$，小于阈值$ssthresh$时指数增加</li><li>拥塞避免：达到$ssthresh$后，加性增</li><li>收到$3$个冗余$ACK$：$ssthresh&#x3D;CongWin&#x2F;2$，$CongWin&#x3D;ssthresh+3MSS$，加性增</li><li>超时：$ssthresh&#x3D;CongWin&#x2F;2$，$CongWin&#x3D;1MSS$，指数增加到阈值后加性增</li></ul></li></ul></li></ul><h2 id="四、网络层"><a href="#四、网络层" class="headerlink" title="四、网络层"></a>四、网络层</h2><h3 id="4-1-网络层概述"><a href="#4-1-网络层概述" class="headerlink" title="4.1 网络层概述"></a>4.1 网络层概述</h3><ul><li>网络层：实现<strong>主机和主机</strong>之间的通信<ul><li>数据平面：如何转发<ul><li><strong>转发</strong>是指将分组从一个输入链路接口转移到适当的输出链路接口的路由器本地动作</li><li>转发的时间尺度很短$(ns)$，因此采用硬件实现</li><li>假设某个驾驶员从武昌到汉口经过许多立交桥，<strong>转发类比于经过某个立交桥的过程</strong></li><li>分组交换机上的网络层根据转发表以及分组首部信息，将分组向适当链路进行转发</li></ul></li><li>控制平面：如何选路<ul><li><strong>路由选择</strong>是指确定分组从源到目的地所采取的端到端路径的网络范围处理过程</li><li>路由选择的时间尺度较长$(s)$，因此采用软件实现</li><li>假设某个驾驶员要从武昌到汉口，<strong>路由选择类比于规划从武昌到汉口的行程</strong></li><li>在全局范围为主机之间的通信进行选路，选路结果反映为分组交换机上的转发表</li></ul></li></ul></li></ul><h3 id="4-2-IP-协议"><a href="#4-2-IP-协议" class="headerlink" title="4.2 $IP$协议"></a>4.2 $IP$协议</h3><h4 id="4-2-1-IPv4-数据报格式"><a href="#4-2-1-IPv4-数据报格式" class="headerlink" title="4.2.1 $IPv4$数据报格式"></a>4.2.1 $IPv4$数据报格式</h4><img src="4-6 IPv4数据报格式.png" style="zoom:33%;" /><ul><li><p>版本：$4,bit$，规定数据报的$IP$协议版本</p></li><li><p>首部长度：由于首部中含有可选字段，因此需要使用首部长度确定载荷实际开始的地方</p></li><li><p>服务类型：$8,bit$，代表报文处理方式，每一位分别代表最小延时、最大吞吐量、最高可靠性、最小成本，<strong>只选一个</strong></p></li><li><p>数据报长度：<strong>首部加上载荷的总长度</strong>，以字节计，理论上数据报最大长度为$65535$字节，但以太网链路报文只允许$1500$字节</p></li><li><p>标识、标志、片偏移：与$IP$分片有关，但$IPv6$不允许在路由器上分组分片</p><ul><li>链路层帧大小有限，超过时应该进行分片处理</li><li>将一个大数据报拆分为几个小数据报，传输后在目的主机进行重组</li><li>标识：$16,bit$，网络层服务的上层传输层的同一次报文（可能超过$1500$字节），使用相同标记</li><li>标志：$3bit$，$1$位保留，$2$位表示是否能分片，$3$位（$MF$）表示分片是否结束（$1$为未结束，$0$为结束）</li><li>片偏移：每个分片在整个报文（分组）中的位置（<strong>以$8$字节为度量单位</strong>）</li></ul></li><li><p>生存时间：确保数据报不会永远在网络中循环，每当一台路由器处理数据包时，该字段值减$1$，减为$0$时必须丢弃该数据报</p></li><li><p>协议：当数据报到达最终目的地时才有用，指示了载荷要交付给哪个特定的运输层协议，如$6$标识$TCP$，$17$标识$UDP$</p><blockquote><p>数据报中的协议号将网络层与运输层绑定在一起，报文段中的端口号将运输层和应用层绑定在一起</p></blockquote></li><li><p>首部校验和：按<strong>首部</strong>的每两个字节进行校验和计算，每台路由器都要重新计算首部校验和并放置在首部校验和位中</p></li><li><p>源和目的地址</p></li><li><p>如果不包含可选字段，$IP$数据段的首部将包含$20$个字节</p><blockquote><p>首部长度不定（$20-60$字节），中间节点（路由器）需要消耗相当资源用于分组处理</p></blockquote></li></ul><h4 id="4-2-2-IP-地址"><a href="#4-2-2-IP-地址" class="headerlink" title="4.2.2 $IP$地址"></a>4.2.2 $IP$地址</h4><ul><li><p>$IP$地址的定义</p><ul><li>一台主机通常只有一条链路连接到网络；当主机中的$IP$想发送数据报时，通过该链路发送</li><li>主机与物理链路之间的边界叫做<strong>接口</strong></li><li>路由器负责从链路上接收数据报并从其他链路转发出去，其与任意一条与其连接的链路之间的边界也叫做<strong>接口</strong></li><li>每条主机和路由器都能发送和接收数据报，因此$IP$协议要求每台主机和路由器接口都有自己的$IP$地址</li><li><strong>一个$IP$地址和一个接口相关联，而不是与包含该接口的主机或路由器相关联</strong></li></ul></li><li><p>$IPv4$编址</p><ul><li>每个$IP$地址长度为$32$比特，因此共有$2^{32}$个可能的$IP$地址</li><li>通常按照点分十进制记法书写，即地址中的每个字节用十进制表示，各字节间以句点隔开，如$193.32.216.9$</li><li>地址分类</li></ul><img src="4-8 IPv4地址分类.png" style="zoom:33%;" /><ul><li>大约有$40$亿$IPv4$地址，需要分类以便于寻址和层次化构造网络</li><li>在同一个局域网上的主机或路由器的$IP $地址中的网络号必须一样</li><li>路由器具有两个及以上的$ IP $地址，其每一个接口都有一个不同网络号的$ IP $地址</li><li>$A$类地址以$0-127$开头，$B$类地址以$128-191$开头，$C$类地址以$192-224$开头</li></ul></li><li><p>特殊$IP$地址</p><ul><li>全$0$主机号的$IP$地址表示网络本身，如$129.152.0.0$是网络号为$129.152$的$B$类网络</li><li>全$1$主机号的$IP$地址表示广播地址，如$129.152.255.255$是网络号为$129.152$的$B$类网络的广播地址</li><li>十进制$127$开头的地址是回环地址，用于测试自身$TCP$或$IP$软件是否正常</li></ul></li></ul><h4 id="4-2-3-子网划分"><a href="#4-2-3-子网划分" class="headerlink" title="4.2.3 子网划分"></a>4.2.3 子网划分</h4><ul><li><p>子网的定义</p><ul><li>划分子网以方便地址划分、分块管理，需要<strong>从主机号中借用一部分比特作为子网号</strong></li><li><strong>网络号</strong>唯一指定主机所在网络，该网络包含若干子网</li><li><strong>子网号</strong>唯一指定主机所在子网</li><li><strong>主机号</strong>唯一指定子网内某台主机</li></ul></li><li><p>子网掩码</p><img src="4-9 子网掩码.png" style="zoom:33%;" /><ul><li><p>将网络号和子网号相应的位置全置$1$，主机号相应的位置全置$0$，得到子网掩码</p></li><li><p>$将IP$地址和子网掩码相与得到网络地址</p></li><li><p>$A$、$B$、$C$类地址具有默认子网掩码</p><table><thead><tr><th align="center">地址分类</th><th align="center">默认掩码</th><th align="center">网络号比特</th><th align="center">主机号比特</th><th align="center">子网可容纳主机数</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">255.0.0.0</td><td align="center">8</td><td align="center">24</td><td align="center">2^24-2</td></tr><tr><td align="center">B</td><td align="center">255.255.0.0</td><td align="center">16</td><td align="center">16</td><td align="center">2^16-2</td></tr><tr><td align="center">C</td><td align="center">255.255.255.0</td><td align="center">24</td><td align="center">8</td><td align="center">2^8-2</td></tr></tbody></table></li></ul></li><li><p>子网寻址：先检查目的$IP$地址的网络号，然后检查目的$IP$地址的子网号</p><img src="4-10 子网寻址1.png" style="zoom:33%;" /><ul><li><p>当主机$1$访问主机$2$时，先检查主机$2$是否在本网络上：将目的主机地址$128.30.33.138$与本网络子网掩码$255.255.255.128$相与得到$128.30.33.128$不等于子网$1$的网络地址$128.30.33.0$，说明主机$2$不在主机$1$的子网中</p></li><li><p>依次查询路由器$R_1$的路由转发表</p><img src="4-11 子网寻址2.png" style="zoom:33%;" /><ul><li>对于第一条记录，目的主机地址与子网掩码相与得到$128.30.33.128$不等于$128.30.33.0$</li><li>对于第二条记录，目的主机地址与子网掩码相与得到$128.30.33.128$等于该记录的目的网络地址，因此要访问目的主机时需要访问目的网络地址，也即经过路由器$R_1$的接口$1$进行转发</li></ul></li></ul></li><li><p>子网划分</p><ol><li>确定子网个数</li><li>确定每个子网内的最大主机数</li><li>确定从主机号字段中借用的比特数，用于创建子网号字段</li><li>确定主机号字段中保留的比特数</li><li>确定原始网络号字段和主机号字段的比特数</li><li>检查主机号字段长度大于第3步和第4步中确定的比特数</li><li>设置子网号字段的最佳长度</li><li>创建子网掩码</li><li>确定有效的子网号</li><li>确定每个子网的$IP$地址范围</li></ol></li></ul><h4 id="4-2-4-无类域间路由-CIDR"><a href="#4-2-4-无类域间路由-CIDR" class="headerlink" title="4.2.4 无类域间路由$CIDR$"></a>4.2.4 无类域间路由$CIDR$</h4><ul><li><p>编码格式</p><ul><li>$IP$地址表示为{网络前缀，主机号}</li><li>斜线记法：$192.168.0.1&#x2F;25$表示左边$25$位为网络前缀，对应子网掩码表示中的$192.168.0.1&#x2F;255.255.255.128$</li><li>简写记法：$10.0.0.0&#x2F;10$简写为$10&#x2F;10$</li></ul></li><li><p>示例</p><img src="4-12 CIDR编址.png" style="zoom:33%;" /><ul><li>假设某个地址块为$XX.XX.XX.XX&#x2F;n$，即该地址块的左边$n$位为网络前缀，则剩余$32-n$位用来具体表示主机号，其地址数为$2^{32-n}$</li><li>这个$ ISP $共有$ 64 $个$ C $类网络。如果不采用$ CIDR $技术，则在与该$ ISP $的路由器交换路由信息的每一个路由器的路由表中，就需要有$ 64 $个项目。但采用地址聚合后，只需用路由聚合后的$ 1 $个项目$ 206.0.64.0&#x2F;18 $就能找到该$ ISP$。</li></ul></li><li><p>寻址方式</p><ul><li><p>使用$CIDR$编址后，路由转发表变为如下格式</p><img src="4-13 CIDR路由转发表.png" style="zoom:33%;" /></li><li><p>最长前缀匹配</p><ul><li>使用$ CIDR $时，路由表中的每个项目由<strong>网络前缀</strong>和<strong>下一跳地址</strong>组成</li><li>在查找路由表时可能会得到不止一个匹配结果，此时从匹配结果中选择具有最长网络前缀的路由</li><li>网络前缀越长，其地址块就越小，因而路由就越具体</li></ul><blockquote><p>如对于实例中，假设目的地址为$206.0.71.142$，其匹配大学的地址块前缀$206.0.68.0&#x2F;22$，也匹配四系的地址块前缀$206.0.71.128&#x2F;25$，根据最长前缀匹配规则，需要匹配四系的地址块</p></blockquote></li><li><p>示例（B、A、E、F、C、D）</p><img src="4-14 CIDR路由转发示例.png" style="zoom:33%;" /></li></ul></li></ul><h4 id="4-2-5-网络地址转换-NAT"><a href="#4-2-5-网络地址转换-NAT" class="headerlink" title="4.2.5 网络地址转换$NAT$"></a>4.2.5 网络地址转换$NAT$</h4><ul><li><p>实现原理</p><img src="4-15 NAT转换.png" style="zoom:30%;" /><ul><li><p>发送数据报：将每个向外发送报文的源$IP$地址与端口号<strong>映射</strong>为$NAT,,IP$地址以及新端口号；</p></li><li><p>同时远程客户机或者服务器将以$NAT,,IP$地址以及新端口号做为目的地址进行响应</p></li><li><p>$NAT$路由器将每一个地址转换对记录在$NAT$转换表中</p><blockquote><p> 转换表的表项为：(源$IP$地址,端口号)$\rightarrow$($NAT$的$IP$地址,新端口号)</p></blockquote></li><li><p>接收数据报：根据$NAT$转换表将每个向内发送报文的$NAT,,IP$地址和端口号替换为相应的源$IP$地址以及端口号</p></li><li><p>内网主机对外网不可见；$ISP$变更后内网地址无需变化</p></li></ul></li><li><p>使用$NAT$的变化</p><table><thead><tr><th align="center">不使用$NAT$</th><th align="center">使用$NAT$</th></tr></thead><tbody><tr><td align="center">主机&#x3D;$IP$</td><td align="center">主机&#x3D;$IP$+端口</td></tr><tr><td align="center">统一全球地址</td><td align="center">全球地址+本地地址</td></tr><tr><td align="center">主机访问双向公平</td><td align="center">外网主机无法主动访问内网主机</td></tr></tbody></table></li></ul><h4 id="4-2-6-IPv6-数据报格式"><a href="#4-2-6-IPv6-数据报格式" class="headerlink" title="4.2.6 $IPv6$数据报格式"></a>4.2.6 $IPv6$数据报格式</h4><img src="4-7 IPv6数据报格式.png" style="zoom:33%;" /><ul><li><p>由于$IPv4$地址池即将用尽，因此为了适应对大$IP$地址空间的需求，开发了新的$IP$协议——$IPv6$协议</p></li><li><p>$IP$地址长度被扩大为$128$比特，首部长度为固定为$40$字节</p></li><li><p>版本：标识$IP$版本号，该字段值为$6$时即表示$IPv6$协议</p><blockquote><p>注意：该字段值置为$4$并不能创建合法的$IPv4$数据报</p></blockquote></li><li><p>流量类型：同$IPv4$中的$TOS$字段</p></li><li><p>流标签：用于标识一条数据报的流</p></li><li><p>有效载荷长度：无符号整数，指示数据的字节数</p></li><li><p>下一个首部：标识需要交给哪个运输层协议，如$UDP$或$TCP$</p></li><li><p>跳限制：同$IPv4$中的生存时间</p></li><li><p>不存在分片与重组：中间结点不再负责分片和重组，由端结点负责</p><blockquote><p>即不允许在中间路由器上进行分片与重组，只能在源和目的地执行；当路由器接收到的$IPv6$数据报太大时，会丢弃数据报并发回<u>分组太大</u>的$ICMP$差错报文</p></blockquote></li><li><p>不存在首部校验和：中间节点无需计算</p></li><li><p>不存在选项字段：首部长度固定，加速中间节点转发速度</p></li><li><p>从$IPv4$到$IPv6$</p><ul><li><p>双栈技术</p><ul><li>新加入的设备支持$IPv4&#x2F;IPv6$双协议栈</li><li>一段链路上，如果源和目标均支持$IPv6$，则使用$IPv6$进行通信</li><li>如果任一方不支持$IPv6$，则使用$IPv4$进行通信</li><li>转换开销较大，可能会出现信息的丢失</li></ul></li><li><p>隧道技术</p><ul><li>将$IPv6$的数据报封装在$IPv4$的数据报中，即建立隧道传输$IPv6$数据报</li></ul></li></ul></li></ul><h3 id="4-3-路由器的工作原理"><a href="#4-3-路由器的工作原理" class="headerlink" title="4.3 路由器的工作原理"></a>4.3 路由器的工作原理</h3><h4 id="4-3-1-路由器结构"><a href="#4-3-1-路由器结构" class="headerlink" title="4.3.1 路由器结构"></a>4.3.1 路由器结构</h4><ul><li><p>路由器基本结构</p><img src="4-2 路由器体系结构.png" style="zoom:50%;" /><ul><li><p>输入端口：执行物理层的线路连接功能；执行数据链路层功能；执行网络层查找功能决定输出端口</p></li><li><p>交换结构：根据输入端口查找得到的输出端口，将数据转发到对应的输出端口</p></li><li><p>输出端口：存储从交换结构接收的分组，并执行对应的链路层和物理层功能</p></li><li><p>路由选择处理器：执行<strong>控制平面</strong>功能</p></li></ul></li><li><p>转发方式：如何选择输出端口</p><ul><li>基于目的地转发：根据输入分组的最终目的地转发，类比于在立交桥中根据目的地决定出口</li><li>通用转发：除了目的地，还根据其他因素进行转发</li></ul></li></ul><h4 id="4-3-2-输入端口"><a href="#4-3-2-输入端口" class="headerlink" title="4.3.2 输入端口"></a>4.3.2 输入端口</h4><img src="4-3 路由器输入端口.png" style="zoom:50%;" /><ul><li><p>基于目的地转发</p><ul><li><p>对于$32$位的$IP$地址，在转发表中可以维护每个目的地址的表项，但需要维护的表项数十分庞大</p></li><li><p>实际上，可以通过将目的地址进行分组管理，通过<strong>前缀匹配</strong>的方式进行转发</p></li><li><p>当有多个匹配项时，采用<strong>最长前缀匹配</strong>规则：寻找表中最长的匹配项</p><blockquote><p>例如有如下仅包含$4$个表项的转发表</p><table><thead><tr><th align="center">前缀匹配</th><th align="center">输出接口</th></tr></thead><tbody><tr><td align="center">$1100,1000,0001,0111,0001,0$</td><td align="center">$0$</td></tr><tr><td align="center">$1100,1000,0001,0111,0001,1000$</td><td align="center">$1$</td></tr><tr><td align="center">$1100,1000,0001,0111,0001,1$</td><td align="center">$2$</td></tr><tr><td align="center">其他</td><td align="center">$3$</td></tr></tbody></table><p>对于目的地址是$1100,1000,0001,0111,0001,0110,1010,0001$的分组，其匹配转发表中的第一项，因此将被转发到输出接口$0$；对于目的地址是$1100,1000,0001,0111,0001,1000,1010,0001$的分组，其匹配转发表中的第二项和第三项，但根据最长前缀匹配规则，将被转发到输出接口$1$</p></blockquote></li></ul></li></ul><h4 id="4-3-3-交换结构"><a href="#4-3-3-交换结构" class="headerlink" title="4.3.3 交换结构"></a>4.3.3 交换结构</h4><ul><li><p>内存交换</p><img src="4-4 内存交换.png" style="zoom:33%;" /><ul><li>输入和输出端口间的交换是在<strong>路由处理器</strong>的直接控制下完成</li><li>分组被拷贝到系统内存中，在$CPU$的控制下转发至输出端口</li><li>转发速度受限于内存带宽（每个分组走两次总线）</li></ul></li><li><p>总线交换</p><ul><li>输入报文经共享总线将分组直接转发到输出端口</li><li>总线交换速度受限于总线带宽</li></ul></li><li><p>内联网络交换</p><img src="4-5 内联网络交换.png" style="zoom:33%;" /><ul><li>克服总线带宽限制</li></ul></li></ul><h4 id="4-3-4-输出端口"><a href="#4-3-4-输出端口" class="headerlink" title="4.3.4 输出端口"></a>4.3.4 输出端口</h4><ul><li><p>排队现象的产生</p><ul><li>设输入线路和输出线路的传输速率相同，均为$R_{line},,pkt&#x2F;s$，有$N$个输入输出端口，交换结构传送速率为$R_{switch}$</li><li>当$R_{switch}\gg R_{line}$时，可以使得输入的分组<strong>无时延</strong>地通过交换结构</li></ul></li><li><p>输入排队</p><ul><li>当$R_{switch}$不满足$R_{switch}\gg R_{line}$时，将使得输入端口出现分组排队</li><li>线头阻塞：输入队列中排队分组被位于线头的另一个分组阻塞，须等待交换结构发送<ul><li>当两个不同输入端口的分组均要发往同一个输出端口时，其中一个分组必须等待交换结构转发完毕另一个分组</li></ul></li></ul></li><li><p>输出排队</p><ul><li><p>当$R_{switch}$超过$R_{line}$时，需要对分组进行缓存</p></li><li><p>输出端口缓冲区溢出会导致分组的排队和丢失</p></li><li><p>缓冲区大小：对于有$N$条$TCP$连接经过的链路而言，缓存数量为$B&#x3D;RTT\frac{R}{\sqrt{N}}$</p><blockquote><p>其中$R$为链路容量，$RTT$为平均往返延迟</p></blockquote></li></ul></li></ul><h4 id="※4-4-7-ICMP-协议"><a href="#※4-4-7-ICMP-协议" class="headerlink" title="※4.4.7 $ICMP$协议"></a>※4.4.7 $ICMP$协议</h4><ul><li>用途</li><li>分类</li><li>报文格式</li><li>应用<ul><li>$Ping$命令</li><li>$Tracert$命令</li></ul></li></ul><h3 id="4-5-路由协议"><a href="#4-5-路由协议" class="headerlink" title="4.5 路由协议"></a>4.5 路由协议</h3><h4 id="4-5-1-概述"><a href="#4-5-1-概述" class="headerlink" title="4.5.1 概述"></a>4.5.1 概述</h4><ul><li><p>什么是路由</p><ul><li>路由是从源主机到目的主机的路径</li><li>路由是在路由器上执行的过程，包括接收路由协议、对路由进行选路</li><li>路由是在两个路由器间传递消息的路由协议</li><li>路由是在路由协议的处理下得到的路由表</li></ul></li><li><p>什么是好的路由</p><ul><li>好的路径：无环路，可收敛，费用低</li><li>好的路由协议：开销低（内存、带宽占用），安全性高</li><li>好的路由表：保存局部路由，共同构成完成路由</li></ul></li><li><p>什么是路由器</p><ul><li><p>默认路由器：一台主机连接到的路由器</p></li><li><p>源路由器：源主机的默认路由器</p></li><li><p>目的路由器：目标主机的默认路由器</p></li><li><p>给定一组路由器以及连接路由器的链路，从中找到一条从源路由器到目标路由器的好路径</p><blockquote><p>例外：$A$和$B$之间的路径费用很低，但是二者处于两个组织之间，而这两个组织作出的路由策略不允许相互通行</p></blockquote></li></ul></li><li><p>路由抽象模型</p><img src="4-16 路由抽象图模型.png" style="zoom:100%;" /><ul><li><p>该模型表示为图$G(N,M)$</p></li><li><p>其中路由器集$N&#x3D;{u,v,w,x,y,z}$，链路集$M&#x3D;{(u,v),(u,x), (v,x), (v,w), (x,w), (x,y), (w,y), (w,z), (y,z)}$</p></li><li><p>$c(x,x’)$为节点$X$和$X’$间边的费用，例如图中$c(w,z)&#x3D;5$</p></li></ul><blockquote><p> 费用可以是经济的，但也有可能和链路的带宽以及链路拥塞状况有关</p></blockquote><ul><li><p>路径费用$ (x_1, x_2, x_3,\cdots, x_p) &#x3D; c(x_1,x_2) + c(x_2,x_3) + \cdots + c(x_{p-1},x_p) $</p></li><li><p>选路算路就是选取路径费用最低的路径</p></li></ul></li><li><p>选路算法分类</p><ul><li><p>按照性能目标分类</p><ul><li><p>链路状态算法——基于路径成本最优</p><ul><li>所有路由器都知道整个网络拓扑图以及链路的费用信息</li></ul></li><li><p>距离向量算法——基于路径距离最短</p><ul><li>每个路由器仅有与其相连链路的费用信息，通过迭代计算过程与相邻节点交换信息</li><li>路由信息可以更快地变化，可以响应拓扑或链路费用的变化</li></ul></li></ul></li><li><p>按照负载是否敏感分类</p><ul><li>负载敏感算法：链路费用会动态地变化以反映出链路的当前状况</li><li>负载迟钝算法：链路费用不明显地反映链路的当前状况</li></ul></li></ul></li></ul><h4 id="4-5-2-链路状态选择算法-LS-与-OSPF"><a href="#4-5-2-链路状态选择算法-LS-与-OSPF" class="headerlink" title="4.5.2 链路状态选择算法$LS$与$OSPF$"></a>4.5.2 链路状态选择算法$LS$与$OSPF$</h4><ul><li><p>迪杰斯特拉算法</p><ul><li>算法概述<ul><li>给定带权图$G&#x3D;&lt;V,E,W&gt;$（所有边的权重为正值）和源路由器$s$，找到源路由器$s$到所有其他路由器$t$的最小成本$\delta(s,t)$和最小成本路径$&lt;s,\dots,t&gt;$</li><li>算法从结点集$V-S$中选择当前最小成本路径估计最小的路由器$u$，将$u$从$Q$中删除，并加入到$S$中，$u.d$就是源路由器$s$到$u$的最短路径的长度。这里$Q$是一个最小优先队列，保存结点集$V-S$</li><li>以每个结点为源路由器，由上述算法得到的最小生成树即可得到<strong>源路由器到其他路由器的转发表</strong></li></ul></li><li>前提：所有节点都知道网络拓扑和链路费用<ul><li>所有节点具有该网络的同一个完整的视图</li><li>通过链路状态广播获得信息</li></ul></li><li>目标：产生某节点的转发表<ul><li>计算从某节点到网络中所有其它节点的最低费用，并产生转发表</li></ul></li><li>算法复杂度为$O(n^2)$</li><li>算法的问题<ul><li>当模型采用负载流量作为路径成本，即模型为负载敏感型网络时，会产生振荡问题</li><li>解决方案<ul><li>不以负载流量作为成本——无法解决高拥塞问题</li><li>所有的路由器不同时运行$LS$算法</li></ul></li></ul></li></ul></li><li><p>$OSPF$协议</p><ul><li><p>即$Open,, Shortest,, Path,, First$协议，公开发表的最短路径优先协议</p></li><li><p>协议交互范围：工作在本自治系统域内，采用<strong>泛洪法</strong>发送消息</p></li><li><p>协议交互消息内容：<strong>与本路由器相邻的所有路由器的链路状态</strong></p></li><li><p>协议交互时机：<strong>仅当链路状态发生变化时</strong>，采用泛洪法向所有路由器发送信息</p></li><li><p>当链路状态发生变化时，每个路由器都向本$AS$中的所有路由器发送与本路由器相邻的所有路由器的链路状态，信息发送完毕后，所有路由器上都将有全网一致的拓扑结构图</p><blockquote><p>即使链路状态未发生变化，每$30$分钟广播一次链路状态</p><p>链路状态以$OSPF$通告的形式封装在报文中，由$IP$分组承载（协议号：$89$）</p><p>$OSPF$路由器之间的交换经过$MD5$鉴别，以确认$OSPF$通告的真实性，防止伪造和篡改</p></blockquote></li></ul></li></ul><h4 id="4-5-3-距离向量选择算法-DV-与-RIP"><a href="#4-5-3-距离向量选择算法-DV-与-RIP" class="headerlink" title="4.5.3 距离向量选择算法$DV$与$RIP$"></a>4.5.3 距离向量选择算法$DV$与$RIP$</h4><ul><li>距离向量选择：$d_x(y)&#x3D;min_v{c(x,v)+d_v(y)}$</li><li>$RIP$路由表更新算法<ul><li>路由器$X$得到相邻路由器$Y$的路由表，从而得知$Y$到网络$Z$的最短距离为$N$</li><li>如果路由器$X$没有到网络$Z$的路由条目，则添加一条经由路由器$Y$到网络$Z$距离$N+1$的路由条目</li><li>如果路由器$X$已有到网络$Z$的路由条目，其距离为$M$，如果$M&gt;N+1$，则更新该条目为经由路由器$Y$到网络$Z$距离$N+1$，否则不更新</li></ul></li><li>当链路状态改变时<ul><li>在$ t0 $时刻，$y $检测到链路费用变化，更新距离向量，同时将这个变化通知给它的邻居</li><li>在$ t1$时刻，$ z $收到来自$ y $的更新报文并更新距离向量表，计算出到$x$的新的最低费用，并向邻居发送它的新距离向量</li><li>在$ t2$时刻，$y $收到自$z$的更新并更新其距离向量表，$Y$的最低费用未变，因此$y$不发送任何报文给$z$</li></ul></li><li>协议参数<ul><li>链路费用：相邻两点链路费用为$1$跳，最大费用限制为$15$</li><li>通告周期：选路更新通告周期为$30$秒</li><li>邻居离线：邻居离线判定周期为$180$秒</li><li>协议端口：基于$UDP$，端口为$520$</li></ul></li></ul><h4 id="4-5-5-域间-BGP-4-协议"><a href="#4-5-5-域间-BGP-4-协议" class="headerlink" title="4.5.5 域间$BGP-4$协议"></a>4.5.5 域间$BGP-4$协议</h4><ul><li>层次路由<ul><li>因特网规模过大，导致路由器无法存储每台主机的选路信息，路由表更新的报文广播将导致无剩余带宽供发送数据使用</li><li>将路由器聚合到一个区域，即自治系统$AS$，在不同$AS$内的路由器可以运行不同的自治系统内部选路协议</li></ul></li><li>转发选路算法<ul><li>转发表是由$AS$内部选路算法和$AS$间选路算法共同决定的</li><li>$AS$内部选路算法为内部目的地址设置转发表信息</li><li>$AS$内部选路算法和$AS$间选路算法共同为外部目的地址设置转发表信息</li><li>假设从源到目标仅有一条路可选<ul><li>假设$AS1$从$AS$间选路协议知道子网$ x $经过网关路由器$1c$至$AS3$可达，但是通过$AS2$不可达</li><li>$AS1$向它的所有路由器广播该可达信息</li><li>路由器$1d $知道，它的接口$ I  $在到路由器$1c$的最低费用路径上</li><li>从而路由器$1d$将表项$ (x,I)$放入其转发表</li></ul></li><li>假设从源到目标有多条路径可选<ul><li>现在假设$AS1$知道子网$ x $可以通过$ AS3 $和$ AS2$到达</li><li>为了配置转发表, 路由器$ 1d $必须决定通过哪个网关路由器转发报文（$1b$或$1c$）</li><li>热土豆选路: 将报文发送到最近的路由器</li></ul></li></ul></li><li>$BGP-4$发言人<ul><li>每一个$AS$要选择一个路由器作为该$AS$的**$BGP$ 发言人**</li><li>两个$ BGP $发言人通过一个共享网络连接在一起</li><li>$BGP$发言人通过$BGP$通告广播该自治系统$AS$能够到达哪些网络<ul><li>通过将多个路由前缀聚合为单一前缀并转发之达到路由通告的目的</li><li>发言人得知某些通告信息后，向该$AS$内的路由器广播，路由器为之创建新的表项</li><li>路由通告中包含前缀（能够到达的网络前缀）、路径（到达前缀地址经过的路径）、下一跳（到达前缀地址需要经过的下一跳地址）</li></ul></li></ul></li></ul><h2 id="五、链路层"><a href="#五、链路层" class="headerlink" title="五、链路层"></a>五、链路层</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><h4 id="5-1-1-术语"><a href="#5-1-1-术语" class="headerlink" title="5.1.1 术语"></a>5.1.1 术语</h4><ul><li><p>主要讨论传播时延：从输出链路的起点到目的地传播所需的时间</p></li><li><p>节点：主机和路由器</p></li><li><p>链路：沿着通信路径连接相邻节点的通信信道</p></li><li><p>帧：数据链路层的分组单元</p><blockquote><p>链路层负责将数据报封装成<strong>帧</strong>通过链路从一个节点传输到<strong>物理上相邻</strong>的下一个节点</p></blockquote></li></ul><h4 id="5-1-2-链路层基本模型"><a href="#5-1-2-链路层基本模型" class="headerlink" title="5.1.2 链路层基本模型"></a>5.1.2 链路层基本模型</h4><img src="5-1 链路层模型.png" style="zoom:45%;" /><ul><li><p>数据报在不同链路上可能<strong>由不同的链路层协议</strong>进行处理</p><blockquote><p>第一段链路上由$PPP$处理，最后一段链路上由以太网处理，中间链路上由广域链路层协议处理</p></blockquote></li><li><p>不同的链路层协议可能提供不同的服务</p></li><li><p>链路层提供的服务</p><ul><li>成帧、链路访问：将数据加上头部和尾部，封装成数据帧，其中帧头部用$MAC$地址标识源和目的地</li><li>可靠传递：用于误码率高的链路，如无线链路</li><li>流量控制：在相邻的收发节点间限制流量</li><li>差错检测：接收方检测到错误存在后，给发送方发送信号要求重传或丢弃该数据帧</li><li>差错纠正：接收方检测和纠正帧中错误，不用重传</li><li>半双工和全双工：半双工时，链路两端的节点都能传输分组，但不能同时传输</li></ul></li><li><p>链路层的实现</p><ul><li>链路层在“适配器”（网卡$NIC$）或者芯片上实现</li></ul></li></ul><h4 id="5-1-3-差错检测和纠正"><a href="#5-1-3-差错检测和纠正" class="headerlink" title="5.1.3 差错检测和纠正"></a>5.1.3 差错检测和纠正</h4><ul><li>单比特奇偶校验：检测单个比特错误</li><li>二维奇偶校验：检测和纠正单个比特错误</li><li>因特网检查和：用于$TCP$、$UDP$和$IPv4$协议中</li><li>$CRC$冗余校验：广泛应用于以太网、$802.11,,WiFi$、$ATM$</li></ul><h3 id="5-2-多路访问链路和协议"><a href="#5-2-多路访问链路和协议" class="headerlink" title="5.2 多路访问链路和协议"></a>5.2 多路访问链路和协议</h3><h4 id="5-2-1-链路概述"><a href="#5-2-1-链路概述" class="headerlink" title="5.2.1 链路概述"></a>5.2.1 链路概述</h4><ul><li><p>链路类型</p><ul><li>点到点链路：$PPP$&#x2F;以太网交换机和主机之间的点到点链路</li><li>广播链路(共享线路或介质)：传统以太网&#x2F;$802.11$无线$LAN$</li></ul></li><li><p>链路特点</p><ul><li><p>单个共享广播信道</p></li><li><p>两个或多个节点同时传输时，会相互干扰</p><blockquote><p>碰撞：一个节点同时收到两个或多个信号</p></blockquote></li></ul></li></ul><h4 id="5-2-2-信道划分协议"><a href="#5-2-2-信道划分协议" class="headerlink" title="5.2.2 信道划分协议"></a>5.2.2 信道划分协议</h4><ul><li><p>协议概述</p><ul><li>信道划分协议：将信道划分成小的“片”（时隙、频率、编码）分配给节点使用</li></ul></li><li><p>$TDMA(Time,,Division,,Multiple,,Access)$</p><ul><li>循环访问信道</li><li>每个节点在每次循环中得到固定长度的时隙（时隙长度＝传输单个分组时间）</li><li>没有数据发送的时隙空闲</li></ul></li><li><p>$FDMA(Frequence,,Division,,Multiple,,Access)$</p><ul><li>信道按频谱分成若干频段</li><li>每个节点分配固定频段</li><li>在频段不用时该部分信道被闲置和浪费</li></ul></li><li><p>$CDMA(Code,,Division,,Multiple,,Access)$</p><ul><li>每个用户使用自己的码片序列对数据编码</li><li>当需要发送比特$1$时，发送$mbit$码片序列</li><li>当需要发送比特$0$时，发送$mbit$码片序列的二进制反码</li></ul></li></ul><h4 id="5-2-3-随机访问协议"><a href="#5-2-3-随机访问协议" class="headerlink" title="5.2.3 随机访问协议"></a>5.2.3 随机访问协议</h4><ul><li>协议概述<ul><li>当节点有数据发送时，以信道全部速率$R$传输，没有主节点起协调作用，因此两个或多个节点发送时会发生<strong>碰撞</strong></li><li>如何检测碰撞</li><li>如何从碰撞中恢复，如延时后重传</li></ul></li><li>$ALOHA(Additive,,Link,, On-Line,, HAwaii,, system)$</li><li>时隙$ALOHA$</li><li>载波监听$CSMA$</li><li>带冲突检测的载波侦听$CSMA&#x2F;CD$</li></ul><h4 id="5-2-4-轮流协议"><a href="#5-2-4-轮流协议" class="headerlink" title="5.2.4 轮流协议"></a>5.2.4 轮流协议</h4><ul><li><p>协议概述</p><ul><li>信道划分协议在<strong>低负荷</strong>时效率低——即使只有一个活动节点，也只能分配到$\frac{1}{N}$的带宽</li><li>随机访问协议在<strong>高负荷</strong>时效率低——碰撞的开销增加</li></ul></li><li><p>轮询协议</p></li><li><p>令牌传递协议</p></li></ul><h3 id="5-3-交换局域网"><a href="#5-3-交换局域网" class="headerlink" title="5.3 交换局域网"></a>5.3 交换局域网</h3><h4 id="5-3-1-MAC-地址"><a href="#5-3-1-MAC-地址" class="headerlink" title="5.3.1 $MAC$地址"></a>5.3.1 $MAC$地址</h4><ul><li>又称为$LAN$地址、物理地址</li><li>$48$比特，前$24$比特由$IEEE$分配管理——$OUI$号，后$24$比特由厂商自行分配</li><li>通常采用<strong>十六进制</strong>表示法，如$5C-66-AB-90-75-B1$</li><li>在数据链路层标识<strong>每块网络适配器</strong>，使得能够在广播信道上寻址目标节点</li><li>$MAC$地址烧入网络适配器的$ROM$中，<strong>不可更改</strong></li><li>$MAC$地址类似于身份证号，不会随着网络迁移而改变；$IP$类似于邮件通信地址，需要根据网络配置策略更改</li><li>和网络层地址类似，主机和路由器上的每个接口（适配器）也都有链路层地址，但是链路层交换机的接口没有链路层地址</li><li>链路层交换机的作用是在主机和路由器之间承载数据报，并<strong>透明</strong>地执行该任务</li></ul><h4 id="5-3-2-地址解析协议-ARP"><a href="#5-3-2-地址解析协议-ARP" class="headerlink" title="5.3.2 地址解析协议$ARP$"></a>5.3.2 地址解析协议$ARP$</h4><ul><li><p>协议概述</p><ul><li>根据目标的$IP$地址获取其$MAC$地址</li><li>每台主机或路由器上存在$ARP$表，包含从$IP$地址到$MAC$地址的映射关系，具体存储为$&lt;IP,MAC,TTL&gt;$</li><li>$ARP$协议工作在网络层和链路层之间</li></ul></li><li><p>同一局域网内工作流程</p><ul><li><p>建立$ARP$请求包</p><img src="5-2 局域网内ARP请求包.png" style="zoom:47%;" /></li><li><p>广播$ARP$请求包</p></li><li><p>建立$ARP$应答包</p><img src="5-3 局域网内ARP应答包.png" style="zoom:50%;" /><ul><li><p>局域网内的所有适配器都把帧中的$ARP$分组向上传递给$ARP$模块</p></li><li><p>与目的$IP$地址匹配的适配器构建应答包</p></li><li><p>向源发送应答包</p></li><li><p>源更新$ARP$表</p></li></ul></li></ul></li><li><p>局域网间工作流程</p><img src="5-5 局域网间ARP.png" style="zoom:200%;" /><ul><li>发送方主机首先获取两个局域网间路由器的端口的$MAC$地址（ARP）</li><li>发送方向路由器发送帧</li><li>路由器根据路由转发表转发数据报到输出接口</li><li>输出接口将数据报发送给其适配器</li><li>适配器封装称新的帧，发送至另一个子网，此时的$MAC$地址即为目的主机地址</li></ul></li></ul><h3 id="5-4-以太网"><a href="#5-4-以太网" class="headerlink" title="5.4 以太网"></a>5.4 以太网</h3><h4 id="5-4-1-以太网帧结构"><a href="#5-4-1-以太网帧结构" class="headerlink" title="5.4.1 以太网帧结构"></a>5.4.1 以太网帧结构</h4><img src="5-4 以太网帧结构.png" style="zoom:50%;" /><ul><li><p>数据最长$1500$个字节</p></li><li><p>前同步码：总共$8$字节</p><ul><li><p>前$7$字节用于唤醒接收适配器，并同步时钟</p></li><li><p>前$7 $字节为$ 10101010 $，最后一个字节为$10101011$</p></li></ul></li><li><p>地址：$6$字节，若适配器收到以太网帧，目的地址为自己的$MAC$地址或广播地址（如$ARP$包），就将帧中的数据传给网络层，否则丢弃该帧</p></li><li><p>类型：上层协议类型（大多为$IP$协议，也支持其它协议，如$AppleTalk$）</p></li><li><p>$CRC$：由接收方检查,若检测到错误，就将该帧丢弃</p></li><li><p>以太网提供的服务</p><ul><li>无连接的服务：在发送适配器和接收适配器之间不需要握手</li><li>不可靠的服务：接收适配器<strong>不发送确认帧或否认帧</strong>给发送方</li></ul></li></ul><h4 id="5-4-2-CSMA-x2F-CD"><a href="#5-4-2-CSMA-x2F-CD" class="headerlink" title="5.4.2 $CSMA&#x2F;CD$"></a>5.4.2 $CSMA&#x2F;CD$</h4><ul><li><p>特点</p><ul><li>没有时隙</li><li>当适配器侦听到其它适配器在传输，则它不传输帧，即<strong>载波侦听</strong></li><li>正在传输的适配器若检测到其它适配器也在传输，则它中止自己的传输，即<strong>碰撞检测</strong></li><li>在重新传输之前，适配器要等待一段随机时间，即<strong>随机回退</strong></li></ul></li><li><p>术语</p><ul><li><p>拥塞信号：长度为$48$比特，用来确保所有传输者都能检测到碰撞而传输的信号</p></li><li><p>比特时间：传输$1$比特所需时间</p><blockquote><p> 在$10Mbps$的以太网中，当$K&#x3D;1023$时，等待时间大约为$50ms$</p></blockquote></li></ul></li><li><p>算法</p><ul><li><p>适配器收到来自网络层的数据报，创建帧</p></li><li><p>若适配器检测到信道空闲，则开始传输帧；若检测到信道忙，就开始等待，直到信道空闲再开始传输该帧</p></li><li><p>若适配器传输了整个帧而没有检测到其它适配器的传输，则该适配器完成该帧的传输</p></li><li><p>若适配器在传输时检测到其它适配器也在传输，则停止传输，发送拥塞信号</p></li><li><p>中止传输后，适配器进入指数回退阶段，在经历第$m$次碰撞后，适配器随机从${0,1,2,\cdots,2^m-1}$中选择$K$值。适配器在等待$ K*512$比特时间后，返回第$2$步</p></li></ul></li><li><p><strong>指数回退算法</strong></p><ul><li>目的：适配器重传时试图估计正确的负载<ul><li>重载：随机等待的时间可能会更长</li></ul></li><li>第一次碰撞后：从$ {0,1}$中选择$K$；延迟是$ K*512 $比特传输时间</li><li>第二次碰撞后：从$ {0,1,2, 3}$中选择$K$</li><li>第十次碰撞后：从$ {0,1,2,3,4,…,1023}$中选择$K$</li></ul></li><li><p><strong>只能进行半双工通信</strong></p></li></ul><h4 id="5-4-3-争用期"><a href="#5-4-3-争用期" class="headerlink" title="5.4.3 争用期"></a>5.4.3 争用期</h4><ul><li>什么是争用期<ul><li>$A$向$B$发送数据，$\tau$后到达$B$（端到端传播时延，记为$τ$）</li><li>若$B$在$A$的数据到达之前，发送自己的数据（这时$B$检测信道是空闲的，因为它没收到任何数据），则必然会与$A$的数据在信道中发生碰撞</li><li>$A$在发送后多久才能知道发生碰撞？要等到$B$的数据到达$A$，而$A$还未结束发送</li><li>假设一个极端情况，当图中所示的时间差$\delta$（$\delta$为$B$发送数据时刻与$A$数据到达$B$的时刻的时间差）趋向于$0$，则$A$检测到发生碰撞的时间$2\tau-\delta&#x3D; 2\tau$</li><li>当超过这个时间都未检测到碰撞，则$A$发送出的数据就一定不会产生碰撞了。</li><li>以太网中端到端的往返时间$2\tau$称为争用期，也叫碰撞时间</li><li>只有经过争用期这段时间还未检测到碰撞，才能肯定这次发送不会发生碰撞，这时就可以放心把这一帧发送完毕。</li></ul></li><li>传统以太网（$10Mbps$）规定争用期为$51.2μs$，最短有效帧长为$64$字节</li><li>最短有效帧长&#x3D;2τ*链路传输速率</li><li>当传送前$64$个字节内没有发生碰撞时，就一直占用信道直到传输完毕所有字节（此时有其他数据来到时必须等待）</li><li>如果发生碰撞，则一定是在发送的前$64$字节之内</li><li>任何小于$64$字节的帧都是由于冲突而异常中止的无效帧</li></ul><h4 id="5-4-4-以太网交换机"><a href="#5-4-4-以太网交换机" class="headerlink" title="5.4.4 以太网交换机"></a>5.4.4 以太网交换机</h4><ul><li><p>链路层设备，负责存储转发以太网帧</p></li><li><p>主机不知道交换机的存在</p></li><li><p>检查帧头部，根据目的$MAC$地址转发</p></li><li><p>交换机的工作原理</p><ul><li>交换机不转发同一网段内通信的帧</li><li>当收到帧的目的地$MAC$地址属于另一个网段，则通过交换表决定向何端口转发</li><li>类比于物流中转站，从不同的物流点接受包裹（帧），当物流中转站发现包裹没有问题（帧无差错）时，保留包裹（缓存帧），否则丢弃包裹但不会要求商家重发包裹（<strong>不会要求帧重发</strong>），而由运输层处理丢包问题。物流中转站根据包裹发往的地址决定转到什么物流（交换机转发），并且不会修改包裹的寄件人地址（交换机不修改帧的源地址）</li></ul></li><li><p>交换机转发和过滤</p><ul><li>过滤：决定一个帧应该转发到某个接口还是丢弃帧</li><li>转发：决定一个帧应该被导向到哪个接口，并将其移动到那些接口</li><li>转发和过滤借助<strong>交换机表</strong>完成，其表项为&lt;$MAC$地址，通向该地址的交换机接口，表项放在表中的时间&gt;</li></ul></li><li><p>交换机自学习</p><ul><li>交换机表初始为空</li><li>对于在每个接口接收到的每个入帧，存储一个表项</li><li>根据表项存储时间和老化期清除表项</li></ul></li><li><p>与路由器对比</p></li></ul><table><thead><tr><th align="center"></th><th align="center">路由器</th><th align="center">以太网交换机</th><th align="center">集线器</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">网络层设备</td><td align="center">链路层设备</td><td align="center">链路层设备</td></tr><tr><td align="center">维护</td><td align="center">维护路由表</td><td align="center">维护交换表</td><td align="center"></td></tr><tr><td align="center">算法</td><td align="center">路由算法</td><td align="center">MAC地址过滤、学习算法</td><td align="center"></td></tr><tr><td align="center">是否需配置</td><td align="center">需要配置</td><td align="center">即插即用</td><td align="center">即插即用</td></tr></tbody></table><h2 id="六、无线网络"><a href="#六、无线网络" class="headerlink" title="六、无线网络"></a>六、无线网络</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><ul><li>特性<ul><li>无线特性：基于无线链路</li><li>移动特性：用户的网络接入点变化</li></ul></li><li>包含固定基础设施的网络组成<ul><li>无线主机——手机</li><li>无线链路——大气层<ul><li>信号强度递减</li><li>会受到来自其他源的干扰</li><li>多径传播</li><li>比特差错率高于有线网络<ul><li>采用$CRC$进行校验</li><li>采用$ARQ$协议重传</li></ul></li></ul></li><li>基站——连接无线网络，负责转发覆盖范围内的主机的分组，起到链路层中继作用<ul><li>关联：主机在某个基站的覆盖范围内</li><li>切换：主机从某个基站切换到另一个基站</li></ul></li><li>基础设施——预先建立的固定基站</li></ul></li><li>$Ad,,hoc$网络<ul><li>不包含固定基础设施的自组网络——无基站</li><li>每个移动主机兼具主机和基站的作用</li><li>节点(移动主机)仅仅能够在其覆盖范围内向其他节点传送数据</li><li>节点之间相互通信组成的临时网络：在它们内部进行选路和地址分配</li></ul></li><li>无线链路的质量<ul><li>信噪比$SNR(SIGNAL-NOISE,,RATIO)$：信号强度与噪声强度的比值</li><li>比特差错率$BER(Bit,,Error,,Rate)$</li><li>调制方案相同，$SNR$越高，$BER$越低；$SNR$相同 ，比特传输率高的调制方案的$BER$高</li></ul></li></ul><h3 id="6-2-WiFi-概述"><a href="#6-2-WiFi-概述" class="headerlink" title="6.2 $WiFi$概述"></a>6.2 $WiFi$概述</h3><ul><li>执行$802.11$协议的无线$LAN$</li><li>$802.11$协议是一个协议簇，使用$CSMA&#x2F;CA$协议进行多路访问<ul><li>$802.11a$的频率范围为$5.1\sim5.8GHz$</li><li>$802.11ac$的频率范围为$5.1\sim5.8GHz$，支持单流和多流通信</li><li>$802.11b$的频率范围为$2.4\sim2.485GHz$，不需要许可证</li><li>$802.11g$的频率范围为$2.4\sim2.485GHz$</li><li>$802.11n$的频率范围为$2.4\sim2.485GHz$和$5.1\sim5.8GHz$，支持单流和多流通信</li></ul></li><li>$802.11b$的信道划分<ul><li>将$85MHz$划分为$11$个部分重叠的信道，仅当两个信道间隔$4$个及以上的信道时没有重叠，可以同时工作，如$1、6、11$</li><li>每个无线访问接入点$AP$周期性发送信标帧，包含自己的$SSID$和$MAC$</li><li>主机扫描$11$个信道获取所有可用的$AP$的信标帧</li><li>主机连接到某个$AP$，加入其子网，并通过$dhcp$获取$IP$地址（需要身份鉴别）</li></ul></li><li>发送流程<ul><li>监听到信道闲置$DIFS$秒后才开始传输帧，并且不进行冲突检测</li><li>监听到信道忙后，则定时避退，定时到且信道闲置就发送数据</li><li>接收方收到帧后，等待$SIFS$秒发送$ACK$</li><li>发送方收到确认后，继续发送数据；没有收到确认则重新发送</li></ul></li><li>冲突避免<ul><li>发送方在发送帧之前，使用$CSMA$协议发送短的请求$RTS$帧给$AP$（$RTS$也可能冲突）预约信道</li><li>$AP$回应允许发送$CTS$帧表示预约成功</li><li>其他发送方也能接收到$RTS$帧，收到后推迟自己的发送</li><li>如果$RTS$发生冲突，则两个发送方进行随即回退，总有一方先发送第二个$RTS$帧</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 专业核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【教程】Windows下安装WSL 2</title>
      <link href="/2022/08/19/%E3%80%90%E6%95%99%E7%A8%8B%E3%80%91Windows%E4%B8%8B%E5%AE%89%E8%A3%85WSL%202/"/>
      <url>/2022/08/19/%E3%80%90%E6%95%99%E7%A8%8B%E3%80%91Windows%E4%B8%8B%E5%AE%89%E8%A3%85WSL%202/</url>
      
        <content type="html"><![CDATA[<h2 id="系统版本要求"><a href="#系统版本要求" class="headerlink" title="系统版本要求"></a>系统版本要求</h2><a class="tag-Link" target="_blank" href=" https://learn.microsoft.com/zh-cn/windows/wsl/">    <div class="tag-link-tips">引用站外地址</div>    <div class="tag-link-bottom">        <div class="tag-link-left" style="background-image: url( https://www.microsoft.com/favicon.ico);"></div>        <div class="tag-link-right">            <div class="tag-link-title">WSL官方文档</div>            <div class="tag-link-sitename"> WSL</div>        </div>        <i class="fa-solid fa-angle-right"></i>    </div>    </a><p>必须运行 Windows 10 版本 2004 及更高版本（内部版本 19041 及更高版本）或 Windows 11</p><blockquote><p>按住<strong>Windows徽标键+R</strong>，键入<strong>winver</strong>来查看电脑版本</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>通过在<strong>管理员模式下</strong>PowerShell 或 Windows 命令提示符中输入以下命令，然后重新启动计算机来安装运行WSL</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">--install</span></span><br></pre></td></tr></table></figure><p>此命令将启用所需的可选组件，下载最新的Linux内核，<strong>将WSL 2设置为默认值</strong>，并为您安装Linux发行版（默认情况下为<strong>Ubuntu</strong>）。</p><p>首次启动新安装的 Linux 发行版时，将打开一个控制台窗口，系统将要求您等待文件解压缩并存储在您的计算机上。</p><h2 id="更改发行版"><a href="#更改发行版" class="headerlink" title="更改发行版"></a>更改发行版</h2><p>通过在<strong>管理员模式下</strong>PowerShell 或 Windows 命令提示符中输入以下命令查看可安装的有效分发</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">-l</span> <span class="literal">-o</span></span><br><span class="line">wsl <span class="literal">--list</span> <span class="literal">--online</span></span><br></pre></td></tr></table></figure><p>通过在<strong>管理员模式下</strong>PowerShell 或 Windows 命令提示符中输入以下命令安装新分发</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">--install</span> <span class="literal">-d</span> &lt;Distribution Name&gt;</span><br></pre></td></tr></table></figure><p>通过在<strong>管理员模式下</strong>PowerShell 或 Windows 命令提示符中输入以下命令用新分发替换旧分发</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">--install</span> <span class="literal">-d</span> &lt;Distribution Name&gt; &lt;Distribution Name&gt;</span><br></pre></td></tr></table></figure><h2 id="查看已安装发行版"><a href="#查看已安装发行版" class="headerlink" title="查看已安装发行版"></a>查看已安装发行版</h2><p>通过在<strong>管理员模式下</strong>PowerShell 或 Windows 命令提示符中输入以下命令查看已安装分发的状态和版本</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">-l</span> <span class="literal">-v</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【笔记】算法设计与分析笔记</title>
      <link href="/2022/08/19/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/08/19/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="一、算法基础"><a href="#一、算法基础" class="headerlink" title="一、算法基础"></a>一、算法基础</h2><h3 id="1-循环不变量的证明"><a href="#1-循环不变量的证明" class="headerlink" title="1.循环不变量的证明"></a>1.循环不变量的证明</h3><ul><li>初始化：证明循环不变量在循环开始前为真；</li><li>保持：证明每次循环之后循环不变式仍为真；</li><li>终止：循环可以有限次终止。</li></ul><h3 id="2-时间复杂度的分析"><a href="#2-时间复杂度的分析" class="headerlink" title="2.时间复杂度的分析"></a>2.时间复杂度的分析</h3><ul><li><p>整个算法的执行时间是执行所有语句的时间之和；</p></li><li><p>算法的执行时间可能依赖于给定的输入，即使规模相同；</p></li><li><p>分析执行时间时可以分析算法的最坏执行情况、最好执行情况、平均执行情况。</p></li></ul><h3 id="3-算法的五个特性"><a href="#3-算法的五个特性" class="headerlink" title="3.算法的五个特性"></a>3.算法的五个特性</h3><ul><li><p>确定性</p></li><li><p>能行性</p></li><li><p>输入</p></li><li><p>输出</p></li><li><p>有穷性</p><div class="note info flat"><p>仅仅不满足有穷性规则的算法称为计算过程，如操作系统</p></div></li></ul><h2 id="二、算法渐近"><a href="#二、算法渐近" class="headerlink" title="二、算法渐近"></a>二、算法渐近</h2><h3 id="1-限界函数"><a href="#1-限界函数" class="headerlink" title="1.限界函数"></a>1.限界函数</h3><h4 id="1-上界函数"><a href="#1-上界函数" class="headerlink" title="(1)上界函数"></a>(1)上界函数</h4><p>上界函数描述了<strong>算法最坏情况下的时间复杂度</strong>，记为$f(n)\inΟ(g(n))$或$f(n)&#x3D;Ο(g(n))$</p><img src="Chp2-上界函数.png" style="zoom: 45%;" /><h4 id="2-下界函数"><a href="#2-下界函数" class="headerlink" title="(2)下界函数"></a>(2)下界函数</h4><p>下界函数描述了<strong>渐进下界</strong>，记为$f(n)\in\Omega(g(n))$或$f(n)&#x3D;\Omega(g(n))$</p><img src="Chp2-下界函数.png" style="zoom: 50%;" /><h4 id="3-渐近紧确界函数"><a href="#3-渐近紧确界函数" class="headerlink" title="(3)渐近紧确界函数"></a>(3)渐近紧确界函数</h4><p>渐近紧确界函数代表<strong>算法在最好和最坏情况下的计算时间就一个常数因子范围内而相同</strong>，<strong>既有$ f(n) &#x3D; \Omega(g(n))$，又有$f(n) &#x3D; Ο(g(n))$</strong></p><img src="Chp2-渐近紧确界.png" style="zoom: 58%;" /><h4 id="4-记号说明"><a href="#4-记号说明" class="headerlink" title="(4)记号说明"></a>(4)记号说明</h4><ul><li>这里的”$&#x3D;$”不是通常相等的含义，<strong>代表属于</strong></li><li>$\Theta(1)$表示具有<strong>常量计算时间</strong>的复杂度，即算法的执行时间为一个固定量，与问题的规模$n$无关</li></ul><h4 id="5-非渐近紧确的上下界"><a href="#5-非渐近紧确的上下界" class="headerlink" title="(5)非渐近紧确的上下界"></a>(5)非渐近紧确的上下界</h4><ul><li><strong>$o$记号</strong></li></ul><p>对任意正常数$c$，存在常数$n_0＞0$，使对所有的$n\geq n_0$，有$\lvert f(n)\rvert\leq c\lvert g(n)\rvert$，则记作：$f(n)&#x3D;o(g(n))$</p><ul><li><strong>$\omega$记号</strong></li></ul><p>对任意正常数$c$，存在常数$n_0＞0$，使对所有的$n\geq n_0$，有$\lvert f(n)\rvert\geq c\lvert g(n)\rvert$，则记作：$f(n)&#x3D;\omega(g(n))$</p><h3 id="2-估算复杂性定理"><a href="#2-估算复杂性定理" class="headerlink" title="2.估算复杂性定理"></a>2.估算复杂性定理</h3><ul><li>多项式定理：关于$n$的$m$次多项式与最高阶$n^m$同阶</li><li>$n^x(\log n)^y&lt;n^{x+\varepsilon}$</li><li>$(\log n)^x&lt;n$</li><li>$n^x&lt;2^n$</li></ul><h3 id="3-上界函数定理"><a href="#3-上界函数定理" class="headerlink" title="3.上界函数定理"></a>3.上界函数定理</h3><ul><li>正线性性：$d(n)&#x3D;O(f(n))$，则$ad(n)&#x3D;O(f(n))$，其中$a&gt;0$</li><li>加法律：$d(n)&#x3D;O(f(n))$，$e(n)&#x3D;O(g(n))$，则$d(n)+e(n)&#x3D;O(f(n)+g(n))$</li><li>乘法律：$d(n)&#x3D;O(f(n))$，$e(n)&#x3D;O(g(n))$，则$d(n)e(n)&#x3D;O(f(n)g(n))$</li><li>指数性质：$n^x&#x3D;O(a^n)$，其中$x&gt;0$，$a&gt;1$</li><li>对数性质1：$\log n^x&#x3D;O(\log n)$，其中$x&gt;0$</li><li>对数性质2：$(\log n)^x&#x3D;O(n^y)$，其中$x&gt;0$，$y&gt;0$</li></ul><h2 id="三、分治思想"><a href="#三、分治思想" class="headerlink" title="三、分治思想"></a>三、分治思想</h2><h3 id="1-分治原理"><a href="#1-分治原理" class="headerlink" title="1.分治原理"></a>1.分治原理</h3><p><strong>分治原理的基本思想：当问题规模比较大而无法直接求解时，将原始问题分解为几个规模较小、但类似于原始问题的子问题，然后递归地求解这些子问题，最后合并子问题的解以得到原始问题的解。</strong></p><ul><li><strong>基本策略：分解原问题，解决子问题，合并问题解</strong>。</li><li><strong>问题形式：跨越子数组的问题类型、合并子问题解的问题类型。</strong></li><li>计算复杂度：<a href="#2.%E9%80%92%E5%BD%92%E5%BC%8F%E6%B1%82%E8%A7%A3">递归式求解</a></li><li>实例：<a href="#3.%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">归并排序</a>——$T(n)&#x3D;2T(n&#x2F;2)+cn$</li><li>实例：<a href="#4.%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98">最大子数组问题</a>——$T(n)&#x3D;2T(n&#x2F;2)+\Theta(n)$</li><li>实例：<a href="#6.%E6%9C%80%E8%BF%91%E7%82%B9%E5%AF%B9%E9%97%AE%E9%A2%98">最近点对问题</a>——$T(n)&#x3D;2T(n&#x2F;2)+O(n)$</li><li>实例：<a href="#7.%E9%80%86%E5%BA%8F%E5%AF%B9%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98">逆序对计数问题</a>——$T(n)&#x3D;2T(n&#x2F;2)+O(n)$</li><li>实例：<a href="#8.%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">随机化快速排序的期望</a>——$T(n)&#x3D;O(n\log n)$</li></ul><h3 id="2-递归式求解"><a href="#2-递归式求解" class="headerlink" title="2.递归式求解"></a>2.递归式求解</h3><h4 id="1-基本形式"><a href="#1-基本形式" class="headerlink" title="(1)基本形式"></a>(1)基本形式</h4><ul><li><p>求解递归式的目的是<strong>将递归式转换为渐近限界函数表示‌</strong>；</p></li><li><p>一般关系为$T(n) &#x3D;T(n_1)+T(n_2)+f(n)$，其中$f(n)$表示<strong>除递归以外的代价</strong>。</p></li></ul><h4 id="2-预处理"><a href="#2-预处理" class="headerlink" title="(2)预处理"></a>(2)预处理</h4><ul><li><p><strong>减去一个低阶项</strong>以便于代换法中的归纳证明，如$cn-d$</p><blockquote><p>减去低阶项往往能够使数学证明顺利进行：</p><img src="Chp3-减去低阶项.png" style="zoom:67%;" /></blockquote></li><li><p>对<strong>取整符号</strong>进行简化</p><blockquote><p>如$T(n)&#x3D;T(\lfloor n&#x2F;2\rfloor)+T(\lceil n&#x2F;2\rceil)+f(n)$，往往忽略上下取整函数，写作以下简单形式：$T(n)&#x3D;2T(n&#x2F;2)+f(n)$</p></blockquote></li><li><p>对<strong>对数或指数</strong>做代数转换</p><blockquote><p>改变变量来简化递归式：</p><img src="Chp3-对指数变量代换.png" style="zoom:67%;" /></blockquote></li><li><p>对<strong>限界函数项</strong>进行展开，便于化简</p><blockquote><p>对于$T(n)&#x3D;3T(\lfloor n&#x2F;4\rfloor)+\Theta(n^2)$，简化为$T(n)&#x3D;3T(n&#x2F;4)+cn^2$。</p></blockquote></li></ul><h4 id="3-求解方法"><a href="#3-求解方法" class="headerlink" title="(3)求解方法"></a>(3)求解方法</h4><h5 id="①代入法"><a href="#①代入法" class="headerlink" title="①代入法"></a>①代入法</h5><ul><li><p>利用熟悉或类似的递归式<strong>猜测解的形式</strong></p></li><li><p>用<strong>数学归纳法</strong>证明猜测的正确性，得出合适的$c$值以满足条件</p></li><li><p>讨论<strong>边界条件的正确性</strong></p><blockquote><p>代入法实例如下：</p><img src="Chp3-代入法实例.png" style="zoom:60%;" /></blockquote></li></ul><h5 id="②递归树"><a href="#②递归树" class="headerlink" title="②递归树"></a>②递归树</h5><ul><li><p>在内部节点中表达除递归以外的代价</p><blockquote><p>对于$T(n)&#x3D;aT(n&#x2F;b)+f(n)$，一般假设$n&#x3D;b^k$，$k&#x3D;\log_bn$简化计算</p></blockquote></li><li><p>列出递归树直至叶子节点，得到递归树高度</p><blockquote><p>递归至叶子节点后，递归树的层数一般为$\log_bn+1$</p><p>举例如下：</p><img src="Chp3-递归树-1.png" style="zoom:67%;" /></blockquote></li><li><p>计算内部某层节点的总代价、叶子节点总代价、树的总代价</p><blockquote><p>通过计算前几层节点的总代价，得到内部某层节点的总代价的<strong>通式</strong>；</p><p>计算叶子节点的数目，假设为$num$，则叶子节点的总代价为$\Theta(num)$；</p><p>根据等比数列求和公式得到总代价。</p><p>计算如下：</p><img src="Chp3-递归树-2.png" style="zoom:67%;" /></blockquote></li><li><p>根据树的总代价猜测渐近限界函数</p><blockquote><p>猜测如下：</p><img src="Chp3-递归树-3.png" style="zoom:67%;" /></blockquote></li><li><p><strong>利用代换法证明</strong>猜测</p><blockquote><p>证明如下：</p><img src="Chp3-递归树-4.png" style="zoom:67%;" /></blockquote></li></ul><h5 id="③主方法"><a href="#③主方法" class="headerlink" title="③主方法"></a>③主方法</h5><p>设$a≥1$，$b&gt;1$，设$f(n)$为渐近正的函数，$T(n)$是定义在非负整数上的递归式：$T(n)&#x3D;aT(n&#x2F;b)+f(n)$，其中$n&#x2F;b$指$\lfloor n&#x2F;b \rfloor$或$\lceil n&#x2F;b \rceil$，则可使用以下定理求解递归式：</p><ul><li><p>若对于某常数$\varepsilon&gt;0$，有$f(n)&#x3D;O(n^{\log_ba-\varepsilon})$，则$T(n)&#x3D;\Theta(n^{\log_ba})$</p><blockquote><p>该情况中$n^{\log_ba}$比较大，$f(n)$需<strong>多项式地小于</strong>$n^{\log_ba}$，即对某个常量$\varepsilon&gt;0$，$f(n)$必须渐近地小于$n^{\log_ba}$，两者相差了一个$n^\varepsilon$因子，如$T(n)&#x3D;2T(n&#x2F;2)+n\log n$和$T(n)&#x3D;4T(n&#x2F;2)+n^2\log n$不满足条件</p></blockquote></li><li><p>若$f(n)&#x3D;\Theta(n^{\log_ba})$，则$T(n)&#x3D;\Theta(n^{\log_ba}\log n)$</p><blockquote><p>该情况中两个函数一样大，乘以对数因子$\log n$</p></blockquote></li><li><p>若对于某常数$\varepsilon&gt;0$，有$f(n)&#x3D;\Omega(n^{\log_ba+\varepsilon})$，且对常数**$c&lt;1$**与足够大的$n$，有$af(n&#x2F;b)\leq cf(n)$，则$T(n)&#x3D;\Theta(f(n))$</p><blockquote><p>该情况中$f(n)$比较大，$f(n)$需<strong>多项式地大于</strong>$n^{\log_ba}$，并需要满足一个规则性条件$af(n&#x2F;b)\leq cf(n)$，注意其中$c&lt; 1$</p></blockquote></li></ul><h3 id="3-归并排序"><a href="#3-归并排序" class="headerlink" title="3.归并排序"></a>3.归并排序</h3><h4 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="(1)问题描述"></a>(1)问题描述</h4><p>已知包含$n$个数字的序列$A[1,\dots,n]$，对其进行升序排序。</p><h4 id="2-问题分析"><a href="#2-问题分析" class="headerlink" title="(2)问题分析"></a>(2)问题分析</h4><ul><li>将数组$A$排序问题分解为$A[1,\dots,\lfloor\frac{n}{2}\rfloor]$和$A[\lfloor\frac{n}{2}\rfloor+1,\dots,n]$排序问题；</li><li>递归解决子问题得到两个有序的子数组；</li><li>然后再将两个子数组合并，合并的代价即为<strong>除递归以外的代价</strong>；</li><li>当数组被分解为长度为1时天然有序，从而产生局部有序性，进而进行两两合并操作。</li></ul><h4 id="3-分治策略"><a href="#3-分治策略" class="headerlink" title="(3)分治策略"></a>(3)分治策略</h4><ul><li><p>算法伪代码：</p><blockquote><p>$MERGE-SORT(A,left,right)$</p><img src="Chp3-MERGE-SORT.png" style="zoom:67%;" /><p>$MERGE(A,left,mid,right)$</p><img src="Chp3-MERGE.png" style="zoom:67%;" /></blockquote></li><li><p>时间复杂度</p><ul><li>递归式为$T(n)&#x3D;2T(n&#x2F;2)+O(n)$，其中$O(n)$为$MERGE$操作的时间代价；</li><li>时间复杂度为$O(n\log n)$。</li></ul></li></ul><h3 id="4-最大子数组问题"><a href="#4-最大子数组问题" class="headerlink" title="4.最大子数组问题"></a>4.最大子数组问题</h3><h4 id="1-问题描述-1"><a href="#1-问题描述-1" class="headerlink" title="(1)问题描述"></a>(1)问题描述</h4><ul><li>寻找和最大的非空连续子数组</li><li>给定一个数组$X[1..n]$，对于任意一对数组下标为$l,r(l\leq r)$的非空子数组，其和记为$S(l,r)&#x3D;\sum\limits_{i&#x3D;l}^{r}X[i]$，求$S(l,r)$的最大值，记为$S_{max}$。</li></ul><h4 id="2-暴力求解"><a href="#2-暴力求解" class="headerlink" title="(2)暴力求解"></a>(2)暴力求解</h4><ul><li>枚举$n+C_n^2$种下标$l,r$组合，求出最大子数组之和；</li><li>处理每对下标组合最少的时间代价为常量；</li><li>时间复杂度为$\Omega(n^2)$。</li></ul><h4 id="3-分治策略-1"><a href="#3-分治策略-1" class="headerlink" title="(3)分治策略"></a>(3)分治策略</h4><ul><li><p>将子数组$A[low…high]$划分为两个规模尽量相等的子子数组；</p></li><li><p>分别求解$A[low…mid]$和$A[mid+1…high]$的最大子数组；</p></li><li><p>基于上述划分，存在三种连续子数组情况：$mid$左侧、跨越$mid$、$mid$右侧；</p></li><li><p>对于跨越$mid$的情况，从$mid$出发，分别向左和向右找出最大子区间并合并，这个步骤的代价即为<strong>除递归以外的代价</strong>，其时间复杂度为$\Theta(n^2)$；</p><blockquote><p> 算法$FIND-MAX-CROSSING-SUBARRAY$如下：</p><img src="img\Chp3-FIND-MAX-CROSSING-SUBARRAY.png" style="zoom: 50%;" /></blockquote></li><li><p>对于其他两种情况，递归调用<strong>FIND-MAXIMUM-SUBARRAY</strong>即可；</p></li><li><p>求最大子数组问题的分治算法</p><blockquote><p><strong>FIND-MAXIMUM-SUBARRAY</strong>如下图：</p><img src="img\Chp3-FIND-MAXIMUM-SUBARRAY.png" style="zoom: 50%;" /></blockquote></li><li><p>时间复杂度</p><ul><li>当$n&#x3D;1$时，$T(n)&#x3D;\Theta(1)$；</li><li>当$n&gt;1$时，$T(n)&#x3D;2T(n&#x2F;2)+\Theta(n)$；</li><li>时间复杂度为$T(n)&#x3D;\Theta(n\lg n)$。</li></ul></li></ul><h4 id="※-4-非递归的线性算法"><a href="#※-4-非递归的线性算法" class="headerlink" title="※(4)非递归的线性算法"></a>※(4)非递归的线性算法</h4><h3 id="※5-Strassen-矩阵乘法"><a href="#※5-Strassen-矩阵乘法" class="headerlink" title="※5.$Strassen$矩阵乘法"></a>※5.$Strassen$矩阵乘法</h3><h3 id="6-最近点对问题"><a href="#6-最近点对问题" class="headerlink" title="6.最近点对问题"></a>6.最近点对问题</h3><h4 id="1-问题描述-2"><a href="#1-问题描述-2" class="headerlink" title="(1)问题描述"></a>(1)问题描述</h4><ul><li>已知平面上分布着点集$P$中的$n$个点$p_1,p_2,\dots,p_n$，点$i$的坐标记为$(x_i,y_i)$，$1\leq i\leq n$。</li><li>找出一对距离最近的点(允许两个点处于同一个位置)</li></ul><h4 id="2-暴力搜索"><a href="#2-暴力搜索" class="headerlink" title="(2)暴力搜索"></a>(2)暴力搜索</h4><ul><li>对每对点都计算距离，然后比较大小，找出其中的最小者</li><li>计算点之间的距离的时间复杂度为$O(n^2)$</li><li>比较得到最小距离的时间复杂度为$O(n^2)$</li></ul><h4 id="3-分治策略-2"><a href="#3-分治策略-2" class="headerlink" title="(3)分治策略"></a>(3)分治策略</h4><ul><li><p>排序：将所有点按照$x$坐标排序——$O(n\log n)$</p></li><li><p>划分：将点集分成左、右两半$P_L$和$P_R$</p><blockquote><p>定义$d_L$为$P_L$中最近点对距离，$d_R$为$P_R$中最近点对距离，$d_C$为跨越分割线的最近点对距离，这与最大子数组问题类似。</p></blockquote></li><li><p>改进：令$\delta&#x3D;min(d_L,d_R)$，则有$d_C&lt;\delta$，即$d_C$对应点对必然落在分割线两侧的$\delta$距离内，称之为$strip$，同时易得，$d_C$的两个点的$y$坐标相差也不会大于$\delta$，因此应该对点的$y$坐标也进行排序。</p></li><li><p>实现：假设搜索到$p_j$时，$p_j$与$p_i$的$y$坐标相差大于$\delta$，那么对于$p_i$而言更远的$p_j$就可以终止搜索，转而处理$p_i$后面的点$p_{i+1}$。</p><blockquote><p>改进后的算法伪代码：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for i=1 to numPointsInStrip do</span><br><span class="line">for j=i+1 to numPointsInStrip do</span><br><span class="line">if y-coordinates of p[i] and p[j] differ by more than δ</span><br><span class="line">break;</span><br><span class="line">else if dist(p[i],p[j])&lt;δ</span><br><span class="line">            δ=dist(p[i],p[j]);</span><br></pre></td></tr></table></figure></blockquote></li><li><p>时间复杂度</p><ul><li>在最坏的情况下，计算$d_C$的时间复杂度为$O(n)$，则最终递归式为$T(n)&#x3D;2T(n&#x2F;2)+O(n)$</li><li>※预排序</li><li>综上得到所有附加工作的总时间复杂度为$O(n)$，则$T(n)&#x3D;2T(n&#x2F;2)+cn&#x3D;O(n\log n)$</li></ul></li></ul><h3 id="7-逆序对计数问题"><a href="#7-逆序对计数问题" class="headerlink" title="7.逆序对计数问题"></a>7.逆序对计数问题</h3><h4 id="1-问题描述-3"><a href="#1-问题描述-3" class="headerlink" title="(1)问题描述"></a>(1)问题描述</h4><ul><li><p>在一个数组$A$中，称满足$i&lt;j$且$A[i]&gt;A[j]$的二元组$(A[i],A[j])$为逆序对</p><blockquote><p>在数组$A&#x3D;{4,6,8,3,5}$中，$(A[1],A[4])$即为一个逆序对</p></blockquote></li><li><p>现已知长度为$n$的数组$A[1..n]$，求其<strong>逆序对的总数</strong>$\sum\limits_{1\leq i\leq j\leq n}X_{i,j}$，其中当$A[i]&gt;A[j]$时$X_{i,j}$为1，否则为0。</p></li></ul><h4 id="2-暴力枚举"><a href="#2-暴力枚举" class="headerlink" title="(2)暴力枚举"></a>(2)暴力枚举</h4><ul><li>对于每个元素$A[i]$，枚举$j(j&gt;i)$，并统计逆序对数目；</li><li>时间复杂度为$O(n^2)$。</li></ul><h4 id="3-分治策略-3"><a href="#3-分治策略-3" class="headerlink" title="(3)分治策略"></a>(3)分治策略</h4><ul><li><p>将子数组$A[low\dots high]$划分为两个规模尽量相等的子子数组；</p></li><li><p>分别递归求解仅在$A[low\dots mid]$和$A[mid+1\dots high]$中的逆序对数目；</p></li><li><p>合并子问题的解时，求解<strong>跨越子数组</strong>的逆序对数目；</p></li><li><p>求解跨越子数组的逆序对数目</p><ul><li><p>直接求解：对于每个$A[j]\in A[mid+1\dots high]$，枚举$A[i]\in A[low\dots mid]$并统计逆序对数目——算法运行时间为$O(n^2)$，得到分治策略运行时间为$O(n^2)$；</p><blockquote><p>运行时间受制于跨越子数组的逆序对计数方法，数组的<strong>有序性</strong>通常有助于提高算法的运行时间。</p></blockquote></li><li><p>排序求解：分别对数组$A[low\dots mid]和$$A[mid+1\dots high]$进行排序，对于每个$A[j]\in A[mid+1\dots high]$，采用二分查找为其在$A[low\dots mid]$中定位，则$A[j]$在$A[low\dots mid]$定位点右侧的元素均可与$A[j]$构成逆序对——算法运行时间为$O(n\log n)$，得到分治策略运行时间为$O(n(\log n)^2)$；</p><blockquote><p>排序和二分查找均无再优化空间，但未将排序过程融入整个算法框架；</p><p><strong>排序未利用子数组有序性质</strong>——使用归并排序；</p><p>合并问题解的同时对数组进行排序，归并过程中可同时计算逆序对数目。</p></blockquote></li><li><p>归并求解：从左到右扫描$A[low\dots mid]和$$A[mid+1\dots high]$，如果$A[i]&gt;A[j]$，统计逆序对，$j$向右移；否则$i$向右移——算法运行时间为$O(n)$，得到分治策略运行时间为$O(n\log n)$。</p></li></ul></li><li><p><strong>分而治之+归并求解</strong></p><blockquote><p>MergeCount：</p><img src="Chp3-MERGECOUNT.png" style="zoom: 72%;" /><p>CountInver：</p><img src="Chp3-COUNTINVER.png" style="zoom: 55%;" /></blockquote></li><li><p>时间复杂度</p><ul><li>归并求解的算法运行时间为$o(n)$；</li><li>$T(n)&#x3D;2T(n&#x2F;2)+O(n)$；</li><li>时间复杂度为$T(n)&#x3D;O(n\lg n)$。</li></ul></li></ul><h3 id="8-快速排序"><a href="#8-快速排序" class="headerlink" title="8.快速排序"></a>8.快速排序</h3><h4 id="1-问题描述-4"><a href="#1-问题描述-4" class="headerlink" title="(1)问题描述"></a>(1)问题描述</h4><ul><li>选择排序和插入排序的时间复杂度均为$O(n^2)$；</li><li>归并排序简化分解，<strong>侧重合并</strong>，快速排序<strong>侧重分解</strong>，简化合并。</li></ul><h4 id="2-分治策略"><a href="#2-分治策略" class="headerlink" title="(2)分治策略"></a>(2)分治策略</h4><ul><li><p>选取固定位置主元$x$，如尾元素；</p></li><li><p>维护两个部分的右端点下标变量$x,y$；</p><img src="Chp3-快速排序示意图.png" style="zoom:50%;" /></li><li><p>考察数组元素$A[j]$，并<strong>只和主元比较</strong>：若$A[j]\leq x$，则交换$A[j]$和$A[i+1]$，$i$和$j$右移，否则$j$右移；</p></li><li><p>到达末尾后，把主元放在中间$(i+1)$处作为分界线；</p></li><li><p>以主元作为数组的划分，得到子数组分别进行PARTITION排序，排序后进行合并</p></li><li><p>伪代码如下：</p><blockquote><p>Partition：对每个子数组进行排序操作，返回主元位置$p$</p><img src="Chp3-PARTITION.png" style="zoom:50%;" /><p>QuickSort：利用Partition和分治策略进行快速排序</p><img src="Chp3-QUICKSORT.png" style="zoom:49%;" /></blockquote></li><li><p>时间复杂度</p><ul><li><p>选取固定位置主元时最好情况下为$O(n\log n)$，最坏情况下为$O(n^2)$</p></li><li><p>选取随机位置主元，可以避免最坏情况的发生</p><blockquote><p>Randomized-Partition：</p><img src="Chp3-RANDOMIZED-PARTITION.png" style="zoom:65%;" /><p>Randomized-QuickSort：</p><img src="Chp3-RANDOMIZED-QUICKSORT.png" style="zoom: 55%;" /></blockquote></li><li><p>随机化的快速排序的期望复杂度为$O(n\log n)$</p></li><li><p><strong>基于比较的排序，其时间复杂度的下界为$\Omega(n\log n)$。</strong></p></li></ul></li></ul><h3 id="9-次序选择问题"><a href="#9-次序选择问题" class="headerlink" title="9.次序选择问题"></a>9.次序选择问题</h3><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="(1)基本概念"></a>(1)基本概念</h4><ul><li><p>顺序统计量：在一个由$n$个元素组成的集合中，第$i$个顺序统计量$(order statistic)$是该集合中的<strong>第$i$小</strong>的元素</p></li><li><p>中位数（<strong>一般指下中位数</strong>）</p><ul><li>下中位数：$i&#x3D;n&#x2F;2$或$i&#x3D;\lfloor(n+1)&#x2F;2\rfloor$</li><li>上中位数：$i&#x3D;n&#x2F;2+1$或$i&#x3D;\lceil(n+1)&#x2F;2\rceil$</li></ul></li><li><p>选择问题：从$n$个元素的集合中选择第$i$个顺序统计量的问题形式化地归结为<strong>“选择问题”</strong></p><ul><li>输入：一个包含$n$个（互异的）数的集合$A$和一个整数$i$，$1\leq i\leq n$</li><li>输出：元素$x\in A$,且$A$中恰好有$i-1$个其他元素小于它</li></ul></li><li><p>采用排序求解的方式解决选择问题时，其时间复杂度为$O(n\log n)$，可以求得所有元素的次序，选择元素的时间复杂度为$O(1)$。</p></li></ul><h4 id="2-期望为线性时间的选择算法"><a href="#2-期望为线性时间的选择算法" class="headerlink" title="(2)期望为线性时间的选择算法"></a>(2)期望为线性时间的选择算法</h4><ul><li><p>受启发于快速排序的Partition过程：</p><blockquote><img src="Chp3-受启发于快速排序.png" style="zoom: 45%;" /></blockquote></li><li><p>选择算法：</p><img src="Chp3-RANDOMIZED-SELECT.png" style="zoom: 50%;" /><blockquote><p>第1行检查$A[p..r]$中只包括一个元素的情况；</p><p>其余情况调用第3行的RANDOMIZED-PARTITION，将数组$A[p..r]$划分为两个子数组$A[p..q-1]$和$A[q+1..r]$<strong>（可能为空）</strong>，使前者的每个元素都小于$A[q]$，后者的每个元素都大于$A[q]$，称$A[q]$为主元；</p><p>第4行计算处于划分的低区的元素个数加1；</p><p>第5行检查$A[q]$是否为第$i$小的元素；</p><p>如果不是，则确定第$i$小的元素是在哪个子数组并在其中递归查找，当$i&gt;k$时，要找的元素必定为$A[q+1..r]$中第$i-k$小的元素。</p></blockquote></li><li><p>最坏情况运行时间为$\Theta(n^2)$，期望运行时间为$\Theta(n)$</p></li></ul><h4 id="※-3-最坏情况为线性时间的选择算法"><a href="#※-3-最坏情况为线性时间的选择算法" class="headerlink" title="※(3)最坏情况为线性时间的选择算法"></a>※(3)最坏情况为线性时间的选择算法</h4><h2 id="四、动态规划"><a href="#四、动态规划" class="headerlink" title="四、动态规划"></a>四、动态规划</h2><h3 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1.基本原理"></a>1.基本原理</h3><h4 id="1-基本概念-1"><a href="#1-基本概念-1" class="headerlink" title="(1)基本概念"></a>(1)基本概念</h4><ul><li>最优化问题：这一类问题的可行解可能有很多个。每个解都有一个值，我们希望寻找具有最优值的解（最小值或最大值）；</li><li>最优解可能有多个；</li><li>根据描述约束条件和目标函数的数学模型的特性和问题的求解方法的不同，可分为：线性规划、整数规划、非线性规划、 动态规划等问题。</li></ul><h4 id="2-动态规划的步骤"><a href="#2-动态规划的步骤" class="headerlink" title="(2)动态规划的步骤"></a>(2)动态规划的步骤</h4><ol><li><p><strong>问题结构分析</strong>：刻画结构特征，<strong>给出问题的表示</strong>，并<strong>明确原始问题</strong>；</p></li><li><p><strong>递推关系建立</strong>：分析最优(子)结构特征，构造递推公式；</p><blockquote><p>问题的最优解由相关子问题最优解组合而成，子问题可以独立求解；</p><p>递推公式又称状态转移方程。</p></blockquote></li><li><p><strong>自底向上计算</strong>：确定计算顺序，计算最优解的值；</p><blockquote><p>子问题的无关性和重叠性</p><ul><li>两个子问题如果不共享资源，它们就是独立的，比如在分治算法中子问题相互独立；</li><li>重叠是指两个子问题实际上是同一个子问题，只是作为不同问题的子问题出现而已，如果暴力枚举，则会导致大量重叠子问题重复计算。</li></ul><p>重叠子问题的解决：动态规划<strong>付出额外空间保存结果</strong>，对每个子问题只求解一次。</p></blockquote></li><li><p><strong>最优方案追踪</strong>：利用辅助数组等记录决策过程，输出最优方案。</p></li></ol><h4 id="3-证明最优子结构性"><a href="#3-证明最优子结构性" class="headerlink" title="(3)证明最优子结构性"></a>(3)证明最优子结构性</h4><ul><li>证明问题满足最优性原理是实施动态规划的必要条件。</li><li>证明的通用模式<ol><li>证明问题最优解的第一个组成部分是做出一个选择，例如，选择钢条第一次切割位置，选择矩阵链的划分位置等。</li><li>利用<strong>“剪切一粘贴”</strong>技术证明<ul><li>作为原问题最优解的组成部分，每个子问题的解就是它本身的最优解。</li><li>利用反证法：假定子问题的解不是其自身的最优解，那么我们就可以从原问题的解中<strong>“剪切”</strong>掉这些非最优解，将最优解<strong>“粘贴”</strong>进去，从而得到原问题一个更优的解，<strong>这与最初的解是原问题最优解的前提假设矛盾</strong>。</li></ul></li></ol></li></ul><h4 id="4-备忘机制"><a href="#4-备忘机制" class="headerlink" title="(4)备忘机制"></a>(4)备忘机制</h4><p>为了避免对重叠子问题的重复计算，在递归过程中加入<strong>备忘</strong>机制。当第一次遇到子问题时，计算其解，并将结果存储在备忘表中；而其后遇到同一个子问题时，通过简单的查表即可返回其解，无需重复计算，节省了时间。</p><h4 id="5-重构最优解"><a href="#5-重构最优解" class="headerlink" title="(5)重构最优解"></a>(5)重构最优解</h4><p>通常定义一个表，<strong>记录每个子问题所做的决策</strong>。当求出最优解的值后，利用该表<strong>回溯</strong>即可得到最优方案。</p><h4 id="6-子问题图"><a href="#6-子问题图" class="headerlink" title="(6)子问题图"></a>(6)子问题图</h4><ul><li><strong>子问题图用于描述子问题与子问题之间的依赖关系</strong>。</li><li>子问题图是一个有向图，每个顶点唯一地对应一个子问题。</li><li>若求子问题$x$的最优解时直接用到子问题$y$的最优解，则在子问题图中就会有一条从子问题$x$的顶点到子问题$y$的顶点的有向边。</li><li>子问题图是<strong>自顶向下递归调用树的“简化版”</strong>。</li><li>在自底向上方法中，对于任何子问题，仅当它依赖的所有子问题都求解完成，才会求解它。</li><li>子问题的数目等于顶点数；</li><li>一个子问题的求解时间与子问题图中对应顶点的“出度”成正比；</li><li>一般情况下，<strong>动态规划算法的运行时间与顶点和边的数量至少呈线性关系</strong>。</li></ul><h3 id="2-01背包问题"><a href="#2-01背包问题" class="headerlink" title="2.01背包问题"></a>2.01背包问题</h3><h4 id="1-问题描述-5"><a href="#1-问题描述-5" class="headerlink" title="(1)问题描述"></a>(1)问题描述</h4><p>$n$个商品组成集合$O$，每个商品有两个属性$v_i$和$p_i$，分别表示体积和价格，背包容量为$C$</p><p>试求解一个商品子集$S\subseteq O$，使得$max\sum\limits_{i\in S}p_i$且$\sum\limits_{i\in S}v_i\leq C$。</p><h4 id="2-问题分析-1"><a href="#2-问题分析-1" class="headerlink" title="(2)问题分析"></a>(2)问题分析</h4><ul><li>可以选取以下策略：<ul><li>策略1：按商品价格由高到低排序，优先挑选价格高的商品</li><li>策略2：按商品体积由小到大排序，优先挑选体积小的商品</li><li>策略3：按商品价值与体积的比由高到低排序，优先挑选比值高的商品</li></ul></li><li>以上三种策略<strong>都不能达到最优解</strong></li></ul><h4 id="3-暴力枚举"><a href="#3-暴力枚举" class="headerlink" title="(3)暴力枚举"></a>(3)暴力枚举</h4><ul><li><p>枚举所有组合共$2^n-1$种情况，并检查体积约束</p></li><li><p>伪代码如下：</p><blockquote><p>$KnapsackSR(i,c)$：前$i$个商品中，容量为$c$时为最优解</p><img src="Chp4-KnapsackSR.png" style="zoom:40%;" /></blockquote></li><li><p>时间复杂度为$O(2^n)$</p></li></ul><h4 id="4-带备忘递归-自顶向下"><a href="#4-带备忘递归-自顶向下" class="headerlink" title="(4)带备忘递归(自顶向下)"></a>(4)带备忘递归(自顶向下)</h4><ul><li><p>记录子问题解，避免重复计算</p></li><li><p>伪代码如下：</p><blockquote><p>$KnapsackMR(i,c)$：带备忘的递归求解</p><img src="Chp4-KnapsackMR.png" style="zoom: 45%;" /><p>构造备忘录$P[i,c]$，表示在前$i$个商品中选择，背包容量为$c$时的最优解</p></blockquote></li></ul><h4 id="5-递推计算-自底向上"><a href="#5-递推计算-自底向上" class="headerlink" title="(5)递推计算(自底向上)"></a>(5)递推计算(自底向上)</h4><ul><li><p>递推公式：$P[i,c]&#x3D;max{P[i-1,c-v[i]]+p[i],P[i-1,c]}$；</p></li><li><p>使用$Rec[i,c]$记录决策过程，选择时为1，否则为0；</p></li><li><p>回溯解决方案时，倒序判断是否选择商品，根据选择结果，确定最优子问题；</p></li><li><p>伪代码如下：</p><blockquote><p>$KnapsackDP(n,p,v,C)$</p><img src="Chp4-KnapsackDP-1.png" style="zoom:50%;" /><p>对数组进行初始化，默认每个商品都不选择；</p><img src="Chp4-KnapsackDP-2.png" style="zoom:48%;" /><p>在$for$循环中依次计算子问题，对于每个子问题，如果商品体积$v[i]\leq c$且选择该商品后得到的总价格$(P[i-1,c-v[i]]+p[i])$高，则选择该商品并更新$P[i,c]$，否则不选择该商品；</p><img src="Chp4-KnapsackDP-3.png" style="zoom:47%;" /><p>倒序判断是否选择了该商品，如果选择了该商品，则回溯子问题。</p></blockquote></li><li><p>求解表格的算法复杂度为$O(n\cdot C)$。</p></li></ul><h3 id="※3-最大子数组问题"><a href="#※3-最大子数组问题" class="headerlink" title="※3.最大子数组问题"></a>※3.最大子数组问题</h3><p>使用分治算法解决最大子数组问题的时间复杂度为$O(n\log n)$，使用动态规划方法能达到时间复杂度仅为$O(n)$的算法。</p><h3 id="4-钢条切割问题"><a href="#4-钢条切割问题" class="headerlink" title="4.钢条切割问题"></a>4.钢条切割问题</h3><h4 id="1-问题描述-6"><a href="#1-问题描述-6" class="headerlink" title="(1)问题描述"></a>(1)问题描述</h4><ul><li><p>给定一段长度为$n$英寸的钢条和一个价格表$P$，切割工序本身没有成本支出，求切割钢条方案，使得销售收益 $r_n$ 最大。</p></li><li><p>假定出售一段长度为i英寸的钢条的价格为$p_i(i&#x3D;1,2,\dots)$，下面是价格表$P$：</p><img src="Chp4-价格表P.png" style="zoom: 50%;" /></li></ul><h4 id="2-问题分析-2"><a href="#2-问题分析-2" class="headerlink" title="(2)问题分析"></a>(2)问题分析</h4><ul><li>每一英寸都可切割，共有$n-1$个切割点，因此长度为$n$英寸的钢条共有$2^{n-1}$中不同的切割方案。</li><li>如果一个最优解将总长度为$n$的钢条切割为$k$段，每段的长度为$i_j(1\leq j\leq k)$，则有$n&#x3D;i_1+i_2+\dots+i_k$，得到的最大收益为$r_n&#x3D;p_{i_1}+p_{i_2}+\dots+p_{i_k}$</li><li>首次切割后，将两段钢条看成<strong>两个独立的钢条切割问题</strong>实例。若分别获得两段钢条的最优切割收益$r_j$和$r_{n-j}$，则原问题的解就可以通过<strong>组合这两个相关子问题的最优子解</strong>获得。</li><li>也即<strong>最优子结构性</strong>——如果$r_n&#x3D;r_i+r_{n-i}$是最优切割收益，则$r_i$、$r_{n-i}$是相应子问题的最优切割收益。</li></ul><h4 id="3-朴素递归"><a href="#3-朴素递归" class="headerlink" title="(3)朴素递归"></a>(3)朴素递归</h4><ul><li><p>$r_n&#x3D;\max\limits_{1\leq i\leq n}{(p_i+r_{n-i})}$</p><img src="Chp4-CUT-ROD.png" style="zoom: 33%;" /></li><li><p>运行效率很差，存在一些相同的子问题重复调用解决</p></li><li><p>$T(n)&#x3D;1+\sum\limits_{j&#x3D;0}^{n-1}T(j)$，也即$T(n)&#x3D;2^n$</p></li></ul><h4 id="4-带备忘递归-自顶向下-1"><a href="#4-带备忘递归-自顶向下-1" class="headerlink" title="(4)带备忘递归(自顶向下)"></a>(4)带备忘递归(自顶向下)</h4><ul><li><p>依旧按照<strong>递归</strong>的形式编写过程，但处理过程中会<strong>保存每个子问题的解</strong>。</p></li><li><p>具体实现如下：</p><blockquote><img src="Chp4-MEMOIZED-CUT-ROD.png" style="zoom: 50%;" /></blockquote><blockquote><img src="Chp4-MEMOIZED-CUT-ROD-AUX.png" style="zoom: 40%;" /></blockquote><blockquote><p>其中辅助数组$r[0\dots n]$用于保存子问题的结果。</p><p>​初始化为$-\infty$；</p><p>​当有新的结果时，$r[n]$保存结果$q$；</p><p>​当$r[n]\geq 0$时，直接引用其中已保存的值。</p></blockquote></li><li><p>运行时间为$\Theta(n^2)$</p></li></ul><h4 id="5-自底向上"><a href="#5-自底向上" class="headerlink" title="(5)自底向上"></a>(5)自底向上</h4><ul><li><p>将子问题按规模排序，按<strong>由小到大的顺序顺次求解</strong>，当求解某个子问题时，它所依赖的<strong>更小子问题都已求解完毕</strong>，结果已经保存，故可以直接引用并组合出它自身的解</p><img src="Chp4-BOTTOM-UP-CUT-ROD.png" style="zoom: 50%;" /></li><li><p>运行时间为$\Theta(n^2)$，相比自顶向下的方法具有更小的系数</p></li></ul><h4 id="6-自底向上-给出切割方案"><a href="#6-自底向上-给出切割方案" class="headerlink" title="(6)自底向上(给出切割方案)"></a>(6)自底向上(给出切割方案)</h4><img src="Chp4-EXTENDED-BOTTOM-UP-CUT-ROD.png" style="zoom: 50%;" /><img src="Chp4-PRINT-CUT-ROD-SOLUTION.png" style="zoom: 50%;" /><h3 id="5-矩阵链乘法问题"><a href="#5-矩阵链乘法问题" class="headerlink" title="5.矩阵链乘法问题"></a>5.矩阵链乘法问题</h3><h4 id="1-基本背景"><a href="#1-基本背景" class="headerlink" title="(1)基本背景"></a>(1)基本背景</h4><ul><li>已知$A$为$p\times r$的矩阵，$B$为$r\times q$的矩阵，则$A$与$B$的乘积是一个$p\times q$的矩阵，矩阵相乘需要进行**$pqr$**次标量乘法运算。</li><li>$n$个要连续相乘的矩阵构成一个矩阵链$&lt;A_1,A_2,\dots,A_n&gt;$，要计算这$n$个矩阵的连乘乘积：$A_1A_2\dots A_n$，称为矩阵链乘问题。<ul><li>矩阵链乘满足结合律，不满足交换律。</li><li>不同的加括号方式代表不同的<strong>计算模式</strong>，而不同的计算模式计算矩阵链乘积的<strong>代价不同</strong>。</li></ul></li></ul><h4 id="2-问题描述"><a href="#2-问题描述" class="headerlink" title="(2)问题描述"></a>(2)问题描述</h4><ul><li>给定$n$个矩阵的链，记为$&lt;A_1,A_2,\dots,A_n&gt;$，其中$i&#x3D;1,\dots,n$，矩阵$A_i$的维数为$p_{i-1}\times P_i$。</li><li>求<strong>“完全括号化方案”</strong>，使得计算乘积$A_1A_2\dots A_n$所需的标量乘法次数最小。</li><li>穷举所有方案的数量：当$n&#x3D;1$时，$P(n)&#x3D;1$，当$n\geq 2$时，$P(n)&#x3D;\sum\limits_{k&#x3D;1}^{n-1}P(k)P(n-k)$，证明得到时间复杂度为$P(n)&#x3D;\Omega(2^n)$</li></ul><h4 id="3-动态规划"><a href="#3-动态规划" class="headerlink" title="(3)动态规划"></a>(3)动态规划</h4><ul><li><p>最优括号化方案的结构特征——寻找最优子结构</p><ul><li>整体的最优括号化方案可以通过寻找使最终标量乘法次数最小的两个最优括号化子方案得到，形如：$(A_1A_{i+1}\dots A_k)(A_{k+1}\dots A_n)$</li></ul></li><li><p>递推求解方案</p><ul><li>递推求解公式</li></ul><img src="Chp4-矩阵链乘递归式.png" style="zoom: 80%;" /><ul><li>使用$s[i,j]$保存$A_iA_{i+1}\dots A_j$最优括号化方案的分割点位置$k$</li></ul></li><li><p>计算最优代价</p><ul><li><p>对应子问题为$\Theta(n^2)$个，存在<strong>子问题重叠</strong>现象，同最优子结构性一样，这也是应用动态规划的标识。</p></li><li><p>采用自底向上法替代该递推求解公式</p><ul><li><p>算法的输入为序列$p&#x3D;\langle p_0,p_1,\dots,p_n\rangle$，长度为$p.length&#x3D;n+1$</p></li><li><p>算法伪代码如下：</p><img src="Chp4-MATRIX-CHAIN-ORDER.png" style="zoom: 50%;" /><blockquote><p>第$3\thicksim 4$行计算$m[i,i]&#x3D;0$</p><p>第$5\thicksim 13$行计算不同矩阵链长度下$m[i,i+l-1]$的最小计算代价，长度依次递增计算。</p><p>可以使用一个上三角矩阵表表示$m[i,j]$和$s[i,j]$</p><p>具体实例如下：</p><img src="Chp4-MATRIX-CHAIN-ORDER-SAMPLE.png" style="zoom: 67%;" /></blockquote></li><li><p>算法运行时间为$\Omega(n^3)$，空间复杂度为$\Theta(n^2)$</p></li></ul></li></ul></li><li><p>构造最优解</p><ul><li><p>$s[i,j]$记录了$A_iA_{i+1}\dots A_j$的最优括号化方案的“首个”分割点$k$。基于$s[i,j]$，对$A_iA_{i+1}\dots A_j$的括号化方案是：</p><p>​       $(A_iA_{i+1}\dots A_{s[i,j]})(A_{s[i,j]+1}\dots A_j)$</p></li><li><p>打印结果的伪代码如下：</p><img src="Chp4-PRINT-OPTIMAL-PARENS.png" style="zoom: 50%;" /></li></ul></li></ul><h3 id="6-最长公共子序列"><a href="#6-最长公共子序列" class="headerlink" title="6.最长公共子序列"></a>6.最长公共子序列</h3><h4 id="1-基本背景-1"><a href="#1-基本背景-1" class="headerlink" title="(1)基本背景"></a>(1)基本背景</h4><ul><li><p>子序列</p><p>给定两个序列$X&#x3D;&lt;X_1,X_2,\dots,X_n&gt;$和序列$Z&#x3D;&lt;z_1,z_2,\dots,z_k&gt;$，若存在$X$的一个严格递增下标序列$&lt;i_1,i_2,\dots,i_k&gt;$,使得对所有$j&#x3D;1,2,\dots,k$，有$x_{i_j}&#x3D;z_j$，则称$Z$是$X$的子序列。</p><blockquote><p>$Z&#x3D;&lt;B,C,D,B&gt;$是$X&#x3D;&lt;A,B,C,B,D,A,B&gt;$的一个子序列，对应下标序列为$&lt;2,3,5,7&gt;$。</p></blockquote></li><li><p>公共子序列</p><p>对给定的两个序列$X$和$Y$，若序列$Z$既是$X$的的子序列，也是$Y$的子序列，则称$Z$是$X$和$Y$的公共子序列。</p><blockquote><p>$X&#x3D;&lt;A,B,C,B,D,A,B&gt;$，$Y&#x3D;&lt;B,D,C,A,B,A&gt;$，则序列$&lt;B,C,A&gt;$是$X$和$Y$的一个公共子序列。</p></blockquote></li><li><p>最长公共子序列(LCS)</p><p>两个序列的长度最大的公共子序列称为它们的最长公共子序列。</p><blockquote><p>$&lt;B,C,A&gt;$是上面$X$和$Y$的一个公共子序列，但不是$X$和$Y$的最长公共子<br>序列。最长公共子序列是$&lt;B,C,B,A&gt;$。</p></blockquote></li><li><p>前缀</p><p>给定一个序列$X&#x3D;&lt;x_1,x_2,\dots,x_m&gt;$，对于$i&#x3D;0,1,\dots,m$，定义$X$的第$i$个前缀为$X_i&#x3D;&lt;x_1,x_2,\dots,x_i&gt;$，即前$i$个元素构成的子序列。</p><blockquote><p>$X&#x3D;&lt;A,B,C,B,D,A,B&gt;$，则$X_4&#x3D;&lt;A,B,C,B&gt;$，$X_0&#x3D;\Phi$。</p></blockquote></li></ul><h4 id="2-最优子结构性"><a href="#2-最优子结构性" class="headerlink" title="(2)最优子结构性"></a>(2)最优子结构性</h4><p>两个序列的一个$LCS$也包含了两个序列的前缀的$LCS$，即$LCS$问题具有最优子结构性质。</p><blockquote><p>定理：设有序列$X&#x3D;&lt;x_1,x_2,\dots,x_m&gt;$和$Y&#x3D;&lt;y_1,y_2,\dots,y_n&gt;$，并设序列$Z&#x3D;&lt;z_1,z_2,\dots,z_k&gt;$为$X$和$Y$的任意一个**$LCS$**。</p><p>（1）若$x_m＝y_n$，则$z_k&#x3D;x_m&#x3D;y_n$，且$Z_{k-1}$是$X_{m-1}$和$Y_{n-1}$的一个$LCS$。</p><p>（2）若$x_m\ne y_n$，则$z_k\ne x_m$蕴含$Z$是$X_{m-1}$和Y的一个$LCS$。</p><p>（3）若$x_m\ne y_n$，则$z_k\ne y_n$蕴含$Z$是$X$和$Y_{n-1}$的一个$LCS$。</p></blockquote><h4 id="3-递推关系式"><a href="#3-递推关系式" class="headerlink" title="(3)递推关系式"></a>(3)递推关系式</h4><p>记$c[i,j]$为前缀序列$X_i$和$Y_j$的一个$LCS$的长度，则有</p><img src="Chp4-LCS递推关系式.png" style="zoom: 33%;" /><blockquote><p>1）若$i&#x3D;0$或$j&#x3D;0$，即其中一个序列的长度为零，则$LCS$的长度为0，$LCS&#x3D;\Phi$；</p><p>2）若$x_i&#x3D;y_j$，则$X_i$和$Y_j$的$LCS$是在$X_{i-1}$和$Y_{j-1}$的$LCS$之后附加将$x_i$得到的，所以                </p><p>$c[i,j]&#x3D;c[i-1,j-1]+1$；</p><p>3）若$x_i\ne y_j$，则$X_i$和$Y_j$的$LCS$的最后一个字符不会是$x_i$或$y_j$(不可能同时等于两者，或与两者都不同)，此时该$LCS$应等于$X_{i-1}$和$Y_j$的$LCS$与$X_i$和$Y_{j-1}$的$LCS$之中的较长者。所以</p><p>$c[i,j]&#x3D;max(c[i-1,j],c[i,j-1])$。</p></blockquote><h4 id="4-自底向上"><a href="#4-自底向上" class="headerlink" title="(4)自底向上"></a>(4)自底向上</h4><ul><li><p>过程$LCS-LENGTH(X,Y)$用来求序列$X&#x3D;&lt;x_1,x_2,\dots,x_m&gt;$和$Y&#x3D;&lt;y_1,y_2,\dots,y_n&gt;$的$LCS$的长度，其时间复杂度为$O(mn)$。</p><img src="Chp4-LCS-LENGTH.png" style="zoom: 50%;" /><blockquote><p>表$c[1..m,1..n]$中包含每一阶段的$LCS$长度，$c[m,n]$等于$X$和$Y$的$LCS$的长度。</p><p>表$b[1..m,1..n]$记录当前$c[i,j]$的计值情况，以此来构造该$LCS$。</p><p>下图给出了在$X&#x3D;&lt;A,B,C,B,D,A,B&gt;$和$Y&#x3D;&lt;B,D,C,A,B,A&gt;$上运行$LCS-LENGTH$计算出的表：</p><img src="Chp4-LCS-LENGTH-SAMPLE.png" style="zoom: 67%;" /><blockquote><p>1）第$i$行和第$j$列中的方块包含了$c[i,j]$的值以及$b[i,j]$记录的箭头。</p><p>2）对于$i,j＞0$，项$c[i,j]$仅依赖于是否有$x_i&#x3D;y_j$及项$c[i-1,j]$、$c[i,j-1]$、$c[i-1,j-1]$的值。</p><p>3）为了重构一个$LCS$，从右下角开始跟踪$b[i,j]$箭头即可</p><p>4）图中，$c[7,6]&#x3D;4$，$LCS(X,Y)&#x3D;&lt;B,C,B,A&gt;$。</p></blockquote></blockquote></li></ul><h4 id="5-构建最优解"><a href="#5-构建最优解" class="headerlink" title="(5)构建最优解"></a>(5)构建最优解</h4><ul><li><p>借助$b[i,j]$反序输出$LCS$，由于每一次循环使$i$或$j$减1，最终$m&#x3D;0$，$n&#x3D;0$，算法结束，所以$PRINT-LCS$的时间复杂度为$O(m+n)$。</p><img src="Chp4-PRINT-LCS.png" style="zoom: 33%;" /></li><li><p>改进：去掉表$b$，直接基于$c$求$LCS$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PRINT-LCS-WITHOUTAUXI(c, X, Y, i, j)</span><br><span class="line">    if c[i, j] == 0</span><br><span class="line">        return</span><br><span class="line">    if X[i] == Y[j]</span><br><span class="line">        PRINT-LCS-WITHOUTAUXI(c, X, Y, i - 1, j - 1)</span><br><span class="line">        print X[i]</span><br><span class="line">    else if c[i - 1, j] &gt;= c[i, j - 1]</span><br><span class="line">        PRINT-LCS-WITHOUTAUXI(c, X, Y, i - 1, j)</span><br><span class="line">    else</span><br><span class="line">        PRINT-LCS-WITHOUTAUXI(c, X, Y, i, j - 1)</span><br></pre></td></tr></table></figure></li><li><p>改进：算法中，每个$c[i,j]$的计算仅需$c$的两行的数据：正在被计算的一行和前面的一行。</p></li></ul><h3 id="※7-最长公共子串"><a href="#※7-最长公共子串" class="headerlink" title="※7.最长公共子串"></a>※7.最长公共子串</h3><h3 id="8-最优二叉搜索树"><a href="#8-最优二叉搜索树" class="headerlink" title="8.最优二叉搜索树"></a>8.最优二叉搜索树</h3><h4 id="1-基本背景-2"><a href="#1-基本背景-2" class="headerlink" title="(1)基本背景"></a>(1)基本背景</h4><ul><li><p>二叉搜索树$T$是一棵二元树，它或者为空，或者其每个结点含有一个可以比较大小的数据元素，且有：</p><ul><li>$T$的左子树的所有元素比根结点中的元素小；</li><li>$T$的右子树的所有元素比根结点中的元素大；</li><li>$T$的左子树和右子树也是二叉搜索树。</li></ul></li><li><p>给定一个$n$个关键字的升序序列$K&#x3D;&lt;k_1,k_2,\dots,k_n&gt;$，对每个关键字$k_i$，都有一个概率$p_i$表示其被搜索的频率。根据$k_i$和$p_i$构建一个二叉搜索树$T$，每个$k_i$对应树中的一个结点。</p></li><li><p>引入外部结点$d_0,d_1,\dots,d_n$，用来表示不在$K$中的值,称为伪关键字。</p><ul><li><p>伪关键字在$T$中对应外部结点，共有$n+1$个。</p><blockquote><p>​<strong>扩展二叉树</strong>：内结点表示关键字$k_i$，外结点(叶子结点)表示$d_i$。</p></blockquote></li><li><p>每个$d_i$代表一个区间，$d_0$表示所有小于$k_1$的值，$d_n$表示所有大于$k_n$的值，对于$i&#x3D;1,\dots,n-1$，$d_i$表示所有在$k_i$和$k_{i+1}$之间的值。</p></li><li><p>每个$d_i$也有一个概率$q_i$<strong>，</strong>表示搜索对象$x$恰好落入区间$d_i$的频率。</p></li></ul></li><li><p>一次搜索的代价等于从根结点开始访问结点的数量(<strong>包括外部结点</strong>)</p><blockquote><p>从根结点开始访问结点的数量等于<strong>“结点在$T$中的深度+1”</strong>；</p><p>记$depth_{T(i)}$为结点$i$在$T$中的深度</p></blockquote></li><li><p>二叉搜索树$T$的期望代价为</p><img src="Chp4-SEARCH-COST-EXPECTATION.png" style="zoom: 33%;" /></li><li><p><strong>最优二叉搜索树</strong>：对于给定的关键字及其概率集合，期望搜索代价最小的二叉搜索树。</p></li></ul><h4 id="2-动态规划"><a href="#2-动态规划" class="headerlink" title="(2)动态规划"></a>(2)动态规划</h4><ul><li><p>最优二叉搜索树的最优子结构</p><blockquote><p>如果$T$是一棵相对于关键字$k_1,\dots,k_n$和伪关键字$d_0,\dots,d_n$的最优二叉搜索树，则$T$中一棵包含关键字$k_i,\dots,k_j$的子树$T’$必然是相对于关键字$k_i,\dots,k_j$（和伪关键字$d_{i-1},\dots,d_j$）的最优二叉搜索子树。</p></blockquote></li><li><p>构造最优二叉搜索树</p><ul><li><p>求解包含关键字$k_i,\dots,k_j$的最优二叉搜索树，其中$i\geq 1$，$j\leq n$且 $j\geq i-1$</p></li><li><p>定义$e[i,j]$：为包含关键字$k_i,\dots,k_j$的最优二叉搜索树的期望搜索代价。</p></li><li><p>当$j&#x3D;i-1$时，由于子树只包含伪关键字$d_{i-1}$,期望搜索代价为$e[i,i-1]&#x3D;q_{i-1}$</p></li><li><p>当$j\geq i$时，从$k_i,\dots,k_j$中选择出根结点$k_r$，以此构建两个最优左右二叉搜索子树。</p><img src="Chp4-最优二叉搜索树期望搜索代价递归公式.png" style="zoom:67%;" /></li></ul></li><li><p>计算期望搜索代价</p><ul><li><p>定义$root[i,j]$，保存计算$e[i, j]$时，使$e[i, j]$取得最小值的$r$，$k_r$即为关键字$k_i,\dots,k_j$的最优二叉搜索（子）树的树根。在求出$e[1,n]$后，利用$root$即可构造出最终的最优二叉搜索树。</p></li><li><p>$w[1..n+1,0..n]$用于保存子树的结点概率之和，每个$w[i,j]$的计算时间仅为$\Theta(1)$</p><blockquote><p>满足<img src="Chp4-BST-w[i,j].png" style="zoom: 33%;" /></p></blockquote></li><li><p>自底向上的迭代计算，时间复杂度为$\Theta(n^3)$</p><img src="Chp4-OPTIMAL-BST.png" style="zoom:50%;" /></li></ul></li></ul><h2 id="五、贪心算法"><a href="#五、贪心算法" class="headerlink" title="五、贪心算法"></a>五、贪心算法</h2><h3 id="1-基本原理-1"><a href="#1-基本原理-1" class="headerlink" title="1.基本原理"></a>1.基本原理</h3><h4 id="1-基本概念-2"><a href="#1-基本概念-2" class="headerlink" title="(1)基本概念"></a>(1)基本概念</h4><ul><li>分步骤实施，它在每一步仅作出当时看起来最佳的选择，即<strong>局部最优的选择</strong>，并寄希望这样的选择最终能导致<strong>全局最优解</strong>。</li><li>实例：最小生成树问题的$Prim$算法、$Kruskal$算法，单源最短路径$Dijkstra$算法，<strong>分数背包</strong>。</li><li>贪心算法<strong>不总能对所有问题能求解</strong>，只是对一些问题确实有效，可以求出最优解或近似最优解。</li></ul><h4 id="2-贪心算法的步骤"><a href="#2-贪心算法的步骤" class="headerlink" title="(2)贪心算法的步骤"></a>(2)贪心算法的步骤</h4><ul><li><p>提出贪心策略：观察问题特征，构造贪心选择；</p></li><li><p>证明策略正确：假设最优方案，通过替换证明。</p><blockquote><p>对应每个贪心算法，都有一个动态规划算法，但动态规划算法要繁琐的多。</p></blockquote></li></ul><h4 id="3-贪心选择性质"><a href="#3-贪心选择性质" class="headerlink" title="(3)贪心选择性质"></a>(3)贪心选择性质</h4><p>可以通过做出局部最优（贪心）选择来构造全局最优解的性质。</p><p>贪心选择性使得我们进行选择时， 只需做出当前看起来最优的选择，而不用考虑子问题的解。  </p><h3 id="2-活动选择问题"><a href="#2-活动选择问题" class="headerlink" title="2.活动选择问题"></a>2.活动选择问题</h3><h4 id="1-问题描述-7"><a href="#1-问题描述-7" class="headerlink" title="(1)问题描述"></a>(1)问题描述</h4><ul><li><p>假定有一个活动的集合$S$​含有$n$​个活动${a_1,a_2,\dots,a_n}$​，每个活动$a_i$​都有一个开始时间$s_i$​和结束时间$f_i$​，$0\leq s_i&lt;f_i&lt;\infty$。同时，这些活动都要使用同一资源(如演讲会场)，而这个资源在任何时刻只能供一个活动使用。</p></li><li><p>活动的兼容性：如果选择了活动$a_i$，则它在半开时间区间 $[s_i, f_i)$内占用资源。若两个活动$a_i$和$a_j$满足$[s_i, f_i)$与区间$[s_j, f_j)$不重叠，则称它们是<strong>兼容</strong>的。</p></li><li><p><strong>活动选择问题</strong>：假设活动按照结束时间单调递增排序，对给定的包含$n$个活动的集合$S$，在已知每个活动开始时间和结束时间的条件下，从中选出最多可兼容活动的子集合，称为<strong>最大兼容活动集合</strong>。</p><blockquote><p>考虑下列活动集合$S$：</p><img src="Chp5-活动选择问题SAMPLE.png" style="zoom:67%;" /></blockquote></li></ul><h4 id="2-问题分析-3"><a href="#2-问题分析-3" class="headerlink" title="(2)问题分析"></a>(2)问题分析</h4><ul><li><p>设$S_{ij}$表示在$a_i$结束之后开始且在$a_j$开始之前结束的活动集合，$A_{ij}$表示$S_{ij}$的一个最大兼容活动子集，设$A_{ij}$包括活动$a_k$，则得到两个子问题——寻找$S_{ik}$和$S_{kj}$的最大兼容活动集合。</p><blockquote><p>图解如下：</p><img src="Chp5-活动选择问题的最优子结构性.png" style="zoom:50%;" /></blockquote></li><li><p>必有：$A_{ik}$是$S_{ik}$一个最大兼容活动子集，$A_{kj}$是$S_{kj}$一个最大兼容活动子集。</p><blockquote><p>$A_{ij}&#x3D;A_{ik}∪{a_k}∪A_{kj}$</p></blockquote></li><li><p>令$c[i,j]$表示集合$S_{ij}$的最优解大小，可使用动态规划方法解决</p></li></ul><h4 id="3-贪心算法"><a href="#3-贪心算法" class="headerlink" title="(3)贪心算法"></a>(3)贪心算法</h4><ul><li><p>每次总选择具有最早结束时间的兼容活动加入到集合$A$中——使剩余的可安排时间段最大化，以便安排尽可能多的兼容活动。</p></li><li><p>当输入的活动已按结束时间的递增顺序排列，贪心算法只需$O(n)$的时间即可选择出来$n$个活动的最大兼容活动集合。</p><blockquote><p>考虑任意非空子问题$S_k$，令$a_m$是$S_k$中结束时间最早的活动，则$a_m$必在$S_k$的某个最大兼容活动子集中。</p></blockquote></li><li><p>自顶向下的递归方法</p><blockquote><p>首先做出一个选择，然后求解剩下的子问题。每次选择将问题转化成一个规模更小的问题。</p><p>伪代码如下：</p><img src="Chp5-RECURSIVE-ACTIVITY-SELECTOR.png" style="zoom: 50%;" /><blockquote><p>第$2\thicksim 3$行查找$S_k$中最早结束的活动，循环检查$a_{k+1},a_{k+2},\dots,a_n$，直至找到第一个与$a_k$兼容的活动$a_m$，也即满足$s_m\geq f_k$。</p><p>如果成功找到$m$（也即$m\leq n$），则返回${a_m}$与$RECURSIVE-ACTIVITY-SELECTOR(s,f,m,n)$返回的$S_m$的最大子集的并集。</p><p>如果未成功找到$m$，则说明未找到与$a_k$兼容的活动，则返回$\Phi$。</p></blockquote></blockquote></li><li><p>迭代实现的贪心算法</p><blockquote><p>伪代码如下：</p><img src="Chp5-GREEDY-ACTIVITY-SELECTOR.png" style="zoom:50%;" /><blockquote><p>$k$对应最后一个加入$A$的活动，$f_k$是$A$中活动的最大结束时间，若$m$的开始时间大于$f_k$，则$m$就是下一个被选中的活动。</p><p>算法的运行时间是$O(n)$。</p></blockquote></blockquote></li></ul><h3 id="3-带权活动选择问题"><a href="#3-带权活动选择问题" class="headerlink" title="3.带权活动选择问题"></a>3.带权活动选择问题</h3><h4 id="1-问题描述-8"><a href="#1-问题描述-8" class="headerlink" title="(1)问题描述"></a>(1)问题描述</h4><ul><li>在活动选择问题中，如果每个活动都具有权重$w$，现寻找活动子集$S’$，使得权重和最大</li></ul><h4 id="2-问题分析-4"><a href="#2-问题分析-4" class="headerlink" title="(2)问题分析"></a>(2)问题分析</h4><ul><li>存在重叠子问题，可以使用动态规划求解</li><li>设$p[i]$表示在$a_i$开始前最后结束的活动编号</li><li>设$Rec[i]$表示是否选择问题$i$</li><li>设$D[i]$表示集合${a_1,a_2,a_3,\dots,a_i}$中兼容活动最大权重和</li><li>将活动按照结束时间升序进行排序，则可得到$D[i]&#x3D;max{D[p[i]]+w_i,D[i-1]}$；其中不选择$a_i$时，其最大权重和即为$D[i-1]$，选择$a[i]$时，其最大权重和应为在$a_i$开始前最后结束的活动编号对应的最大权重和加上$w_i$，即$D[p[i]]+w_i$。</li></ul><h4 id="3-动态规划-1"><a href="#3-动态规划-1" class="headerlink" title="(3)动态规划"></a>(3)动态规划</h4><ul><li><p>伪代码如下</p><blockquote><img src="Chp5-带权活动选择问题.png" style="zoom:67%;" /></blockquote></li><li><p>时间复杂度为$O(n\log n)$</p></li></ul><h3 id="4-Huffman-编码"><a href="#4-Huffman-编码" class="headerlink" title="4.$Huffman$编码"></a>4.$Huffman$编码</h3><h4 id="1-基本概念-3"><a href="#1-基本概念-3" class="headerlink" title="(1)基本概念"></a>(1)基本概念</h4><ul><li><p>码字：每个字符用唯一的二进制串表示，称为码字。</p></li><li><p>定长编码：每个字符的编码长度一样。</p><blockquote><p>对于$a\thicksim f$六个字符，应采用3位码字编码，则10万个字符需用30万个二进制位编码。</p></blockquote></li><li><p>变长编码：每个字符赋予不同长度的码字。</p><blockquote><p>赋予高频字符短码字，低频字符长码字，字符的码字互不为前缀，这样才能唯一解码，同时能够提高编码效率。如$a$用1位的串0表示，$b$用3位的串101表示，$f$用4位的串1100表示等。</p></blockquote></li><li><p>前缀码$(Prefix code)$：任何码字都不是其它码字的前缀。</p><blockquote><p>前缀码可以简化解码过程，由于没有码字是其它码字的前缀，所以编码文件的开始部分是没有歧义的，可以唯一地转换回原字符。</p></blockquote></li><li><p>编码树：一种为表示字符二进制编码而构造的二叉树。</p><blockquote><img src="Chp5-赫夫曼编码树-SAMPLE.png" style="zoom:50%;" /><p>叶子结点：对应给定的字符，每个字符对应一个叶子结点。</p><p>编码构造：字符的二进制码字由根结点到该字符叶子结点的简单路径</p><p>路径表示：0代表转向左孩子，1代表转向右孩子</p></blockquote></li><li><p>最优字符编码方案总对应一棵<strong>满二叉树</strong>， 即每个非叶子结点都有两个孩子结点。</p></li></ul><h4 id="2-最优字符编码方案"><a href="#2-最优字符编码方案" class="headerlink" title="(2)最优字符编码方案"></a>(2)最优字符编码方案</h4><ul><li><p>符号表示</p><ul><li><p>设$C$为字母表</p><blockquote><p>对字母表$C$中的任意字符$c$，令属性$c.freq$表示字符$c$在文件中出现的频率</p><p>最优前缀码对应的树中恰好有$|C|$个叶子结点，每个叶子结点对应字母表中的一个字符，且恰有$|C|-1$个内部结点。</p></blockquote></li><li><p>设$T$表示一棵前缀编码树</p></li><li><p>设$d_T(c)$表示c的叶子结点在树T中的深度（根到叶子结点的路径长度）</p><blockquote><p>$d_T(c)$也表示字符$c$的码字长度</p></blockquote></li><li><p>设$B(T)$表示采用$T$编码时的文件编码长度，即$B(T)&#x3D;\sum\limits_{c\in C}c.freq\cdot d_T(c)$，称$B(T)$为T的代价。</p><blockquote><p>使得$B(T)$最小的编码称为最优编码。</p><p>对给定的字符集和文件，$Huffman$编码是一种最优编码。</p></blockquote></li></ul></li></ul><h4 id="3-Huffman-编码"><a href="#3-Huffman-编码" class="headerlink" title="(3)$Huffman$编码"></a>(3)$Huffman$编码</h4><ul><li><p>算法$HUFFMAN$从$|C|$个叶子结点开始，每次选择频率最低的两个结点合并，将得到的新结点加入集合继续合并，这样执行$|C|-1$次<strong>“合并”</strong>后即可构造出一棵编码树——$Huffman$树。</p><blockquote><p>伪代码如下：</p><img src="Chp5-HUFFMAN.png" style="zoom:50%;" /><p>第2行用$C$中字符初始化最小优先队列$Q$；</p><p>第$3\thicksim 8$行的循环反复从队列中合并频率最低的结点$x$和$y$，合并为新结点$z$并替代之；</p><p>经过$n-1$次合并后，最后返回剩下的唯一结点——编码树的根结点</p><p>示例如下：</p><blockquote><img src="Chp5-HUFFMAN-SAMPLE.png" style="zoom: 67%;"/></blockquote></blockquote></li><li><p>时间复杂度的分析</p><ul><li><p>假设$Q$使用最小二叉堆实现，则其初始化花费$O(n)$的时间</p></li><li><p>循环的总代价是$O(n\lg n)$</p><blockquote><p>$for$循环共执行了$n-1$次，每次从堆中找出当前频率最小的两个结 点及把合并得到的新结点插入到堆中均花费$O(\lg n)$，所以循环的总代价是$O(n\lg n)$。</p></blockquote></li><li><p>因此，$HUFFMAN$的总运行时间$O(n\lg n)$</p></li></ul></li><li><p>※$Huffman$算法的正确性</p><ul><li>证明贪心选择性</li><li>证明最优子结构性</li></ul></li></ul><h3 id="5-分数背包问题"><a href="#5-分数背包问题" class="headerlink" title="5.分数背包问题"></a>5.分数背包问题</h3><h4 id="1-问题描述-9"><a href="#1-问题描述-9" class="headerlink" title="(1)问题描述"></a>(1)问题描述</h4><ul><li>已知$n$个物品组成的集合O，每个物品有两个属性$v_i$和$p_i$，分别表示体积和价格；</li><li>背包容量为$C$；</li><li>试求解$S&#x3D;{x_i|1\leq i\leq n,0\leq x_i\leq 1}$，使得$max\sum\limits_{x_i\in S}x_ip_i$且$\sum\limits_{x_i\in S}x_iv_i\leq C$。</li></ul><h4 id="2-问题分析-5"><a href="#2-问题分析-5" class="headerlink" title="(2)问题分析"></a>(2)问题分析</h4><ul><li><p>采用贪心算法，每次选择**最高性价比($p_i&#x2F;v_i$)**的物品，证明可得贪心解不劣于最优解</p></li><li><p>伪代码如下</p><blockquote><p>$FractionalKnapsack(n,p,v,C)$</p><img src="Chp5-FractionlKnapsack.png" style="zoom:67%;" /><p>当背包未装满且商品未装完时填入商品，商品体积不大于容量则全部装入，否则装入部分商品填满背包</p></blockquote></li><li><p>算法复杂度为$O(n\log n)$</p></li></ul><h2 id="六、基本图算法"><a href="#六、基本图算法" class="headerlink" title="六、基本图算法"></a>六、基本图算法</h2><h3 id="1-基本概念-4"><a href="#1-基本概念-4" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><ul><li><p>图的定义</p><p>图可以表示为一个二元组$G&#x3D;&lt;V,E&gt;$</p><blockquote><p>相关术语：</p><p>$V$表示非空顶点集，其元素称为顶点(Vertex) ，$|V|$表示顶点数；</p><p>$E$表示边集，其元素称为边(Edge)，$|E$表示顶点数 ；</p><p>$e&#x3D;(u,v)$表示一条边，其中$u\in V,v\in V,e\in E$；</p><p>相邻$(Adjacent)$：边$(u,v)$连接的顶点$u$和$v$相邻；</p><p>关联$(Incident)$：边$(u,v)$和其连接的顶点$u(或v)$相互关联。</p></blockquote></li><li><p>相关数据结构</p><ul><li>子图：如果$V’\subseteq V,E’\subseteq E$，则称图$G’&#x3D;&lt;V’,E’&gt;$为G的一个子图</li><li>生成子图：如果$V’&#x3D;V,E’\subseteq E$，则称图$G’&#x3D;&lt;V’,E’&gt;$为G的一个生成子图</li><li>树：连通、无环图$T&#x3D;&lt;V_T,E_T&gt;$，树有$|V_T|-1$条边</li><li>森林：一至多棵树组成的无环图</li></ul></li><li><p>图的表示</p><ul><li>邻接表<ul><li>邻接表是一个包含$|V|$条链表的数组$Adj$；</li><li>在$Adj$中，每个结点$u\in V$有一条链表$Adj[u]$，包含所有与结点$u$之间有边相连的结点$v$；</li><li>用$G.Adj[u]$表示结点$u$在邻接表$Adj$中的邻接链表；</li><li>稀疏图一般用邻接表表示；</li><li>可用于表示有向图也可用于表示无向图，空间需求均为$O(V+E)$。</li></ul></li><li>邻接矩阵<ul><li>将图$G$中的结点编号为$1,2,\dots,|V|$，则图$G$的邻接矩阵是一个$|V|\times|V|$的矩阵$A&#x3D;(a_{ij})$；</li><li>当$(i,j)\in E$，$a_{ij}&#x3D;1$；否则$a_{ij}&#x3D;0$；</li><li>稠密图更倾向于用邻接矩阵表示；</li><li>可以快速判断任意两个结点之间是否有边相连，空间需求为$O(V^2)$。</li></ul></li><li>权重图<ul><li>权重值通常以权重函数$\omega:E\to R$给出；</li><li>用邻接表表示权重图：<ul><li>将边$(u,v)\in E$的权重值$ω(u,v)$存放在$u$的邻接链表结点中, 作为其属性。</li></ul></li><li>用邻接矩阵表示权重图：<ul><li>对于边$(u,v)\in E$，令邻接矩阵$A[u][v]&#x3D;ω(u,v)$；</li><li>若$(u,v)$不是$E$中的边，则令$A[u][v]&#x3D;NIL$，或$\infty$、0。</li></ul></li></ul></li></ul></li></ul><h3 id="2-图的搜索与周游"><a href="#2-图的搜索与周游" class="headerlink" title="2.图的搜索与周游"></a>2.图的搜索与周游</h3><h4 id="1-宽度优先搜索与周游"><a href="#1-宽度优先搜索与周游" class="headerlink" title="(1)宽度优先搜索与周游"></a>(1)宽度优先搜索与周游</h4><h5 id="①宽度优先搜索"><a href="#①宽度优先搜索" class="headerlink" title="①宽度优先搜索"></a>①宽度优先搜索</h5><ul><li><p>算法过程描述</p><ul><li>从结点$v$开始，首先访问结点$v$，给$v$标上已访问标记；</li><li>访问邻接于$v$且目前尚未被访问的所有结点，此时结点$v$被检测，而$v$的邻接结点是新的未被检测结点。将这些结点依次放置到一个称为**未检测结点表的队列(Q)**中；</li><li>若未检测结点表为空，则算法终止；</li><li>否则<strong>取Q的表头</strong>作为下一个检测结点，重复上述过程。直到$Q$为空，算法终止。</li></ul></li><li><p>算法伪代码</p><blockquote><img src="Chp6-BFS-1.png"  /><img src="Chp6-BFS-2.png"  /></blockquote></li><li><p>复杂度分析</p><ul><li>空间复杂度：$s(V,E)&#x3D;\Theta(n)$</li><li>采用邻接表的时间复杂度：$t(V,E)&#x3D;O(n+e)$</li><li>采用邻接矩阵的时间复杂度：$t(V,E)&#x3D;O(n^2)$</li></ul></li></ul><h5 id="②宽度优先周游"><a href="#②宽度优先周游" class="headerlink" title="②宽度优先周游"></a>②宽度优先周游</h5><ul><li><p>若$G$是无向连通图或强连通有向图，则一次调用$BFS$即可完成对$G$的周游。否则，需要多次调用$BFS$</p></li><li><p>算法伪代码</p><blockquote><img src="Chp6-BFT.png" style="zoom:67%;" /></blockquote></li></ul><h5 id="③宽度优先生成树"><a href="#③宽度优先生成树" class="headerlink" title="③宽度优先生成树"></a>③宽度优先生成树</h5><ul><li><p>向前边：$BFS$中由$u$到达未访问结点$w$的边$(u,w)$称为向前边。 </p></li><li><p>宽度优先生成树： 记$T$是$BFS$中处理的所有向前边集合。若$G$是<strong>连通图</strong>，则$BFS$终止时，$T$构成一棵生成树，称为图$G$的宽度优先生成树。</p></li><li><p>对于图$G&#x3D;(V,E)$和源结点$s$，定义图$G$的<strong>前驱子图</strong>为$G_\pi&#x3D;(V_\pi,E_\pi)$，其中$V_\pi&#x3D;{v\in V:v.\pi\ne NIL}\cup{s}$，$E_\pi&#x3D;{(v.\pi,v):v\in V_\pi-{s}}$。该前驱子图构成一棵广度优先树。</p><blockquote><img src="Chp6-BFS-PRINT-PATH.png" style="zoom:67%;" /></blockquote></li></ul><h4 id="2-深度优先搜索与周游"><a href="#2-深度优先搜索与周游" class="headerlink" title="(2)深度优先搜索与周游"></a>(2)深度优先搜索与周游</h4><h5 id="①深度优先搜索"><a href="#①深度优先搜索" class="headerlink" title="①深度优先搜索"></a>①深度优先搜索</h5><ul><li><p>算法过程描述</p><ul><li>从结点$v$开始，首先访问$v$， 给$v$标上已访问标记；</li><li>然后中止对$v$的检测，并从邻接于$v$且尚未被访问的结点的中找出一个结点$w$开始新的检测；</li><li>在$w$被检测后，再恢复对$v$的检测。当所有可到达的结点全部被检测完毕后，算法终止</li></ul></li><li><p>算法伪代码</p><blockquote><img src="Chp6-DFS.png" style="zoom: 67%;" /></blockquote></li><li><p>复杂度分析</p><ul><li>运行时间为$\Theta(V+E)$</li></ul></li></ul><h5 id="②深度优先周游"><a href="#②深度优先周游" class="headerlink" title="②深度优先周游"></a>②深度优先周游</h5><ul><li><p>算法伪代码</p><blockquote><img src="Chp6-DFT.png" style="zoom: 50%;" /></blockquote></li></ul><h4 id="3-深度检索"><a href="#3-深度检索" class="headerlink" title="(3)深度检索"></a>(3)深度检索</h4><ul><li>改造$BFS$算法，用<strong>栈</strong>来保存未被检测的结点</li></ul><h3 id="3-回溯法"><a href="#3-回溯法" class="headerlink" title="3.回溯法"></a>3.回溯法</h3><h4 id="1-n-皇后问题"><a href="#1-n-皇后问题" class="headerlink" title="(1)$n$-皇后问题"></a>(1)$n$-皇后问题</h4><h4 id="2-子集和问题"><a href="#2-子集和问题" class="headerlink" title="(2)子集和问题"></a>(2)子集和问题</h4><h3 id="4-分支-限界法"><a href="#4-分支-限界法" class="headerlink" title="4.分支-限界法"></a>4.分支-限界法</h3><h4 id="1-n-皇后问题-1"><a href="#1-n-皇后问题-1" class="headerlink" title="(1)$n$-皇后问题"></a>(1)$n$-皇后问题</h4><h4 id="2-子集和问题-1"><a href="#2-子集和问题-1" class="headerlink" title="(2)子集和问题"></a>(2)子集和问题</h4><h2 id="七、最小生成树"><a href="#七、最小生成树" class="headerlink" title="七、最小生成树"></a>七、最小生成树</h2><h3 id="1-问题背景"><a href="#1-问题背景" class="headerlink" title="1.问题背景"></a>1.问题背景</h3><ul><li>生成树**(Spanning Tree)** <ul><li>图$T’&#x3D;&lt;V’,E’&gt;$是无向图$G&lt;V,E,W&gt;$的一个生成子图，并且是连通、无环路的(树)</li><li>权重最小的生成树可能不唯一</li></ul></li></ul><h3 id="2-通用框架"><a href="#2-通用框架" class="headerlink" title="2.通用框架"></a>2.通用框架</h3><ul><li><p>新建一个空边集$A$，边集$A$可逐步扩展为最小生成树</p></li><li><p>每次向边集$A$中新增加一条边，需保证边集$A$仍是一个无环图，且仍是最小生成树的子集</p><blockquote><p>$A$是某棵最小生成树$T$边的子集，$A\subseteq T$；</p><p>$A\cup{(u,v}$仍是$T$边的一个子集，则称$(u,v)$是$A$的安全边。</p><p>若每次向边集$A$中新增安全边，可保证边集$A$是最小生成树的子集</p></blockquote></li><li><p>$Generic-MST(G)$</p><blockquote><img src="Chp7-GENERIC-MST.png" style="zoom:50%;" /></blockquote></li><li><p>为了有效辨识安全边，给出以下定义</p><blockquote><p>割：对于连通无向图$G&#x3D;&lt;V,E&gt;$，<strong>割</strong>$(S,V-S)$将顶点集$V$划分为两部分</p><p>给定割$(S,V-S)$和边$(u,v)$，$u\in S,v\in V-S$，称边$(u,v)$<strong>横跨</strong>割$(S,V-S)$</p><p>轻边：横跨割的所有边中，<strong>权重最小</strong>的称为横跨这个割的一条轻边</p><p>如果一个边集$A$中<strong>没有边横跨某割</strong>，则称该割不妨害边集$A$</p></blockquote></li><li><p>安全边辨识定理</p><blockquote><p>给定图$G&#x3D;&lt;V,E&gt;$是一个带权的连通无向图，令$A$为边集$E$的一个子集，且$A$包含在图$G$的某棵最小生成树中。若割$(S,V-S)$是图$G$中不妨害边集$A$的任意割，且$(u,v)$是横跨该割的轻边，则对于边集$A$，边$(u,v)$是其安全边。</p><img src="Chp6-安全边辨识定理.png" style="zoom: 50%;" /><img src="Chp6-安全边辨识定理推论.png" style="zoom: 50%;" /></blockquote></li><li><p>在算法推进的过程中，集合$A$始终保持无环状态；算法执行的任意时刻，图$G_A&#x3D;(V,A)$是一个森林。对于安全边$(u,v)$，由于$A\cup{(u,v)}$必须无环，所以 $(u,v) $连接的是$G_A$中的两个不同连通分量。</p></li></ul><h3 id="3-Prim-算法"><a href="#3-Prim-算法" class="headerlink" title="3.$Prim$算法"></a>3.$Prim$算法</h3><p>贪心策略：集合$A$始终是<strong>一棵树</strong>，每次加入到$A$中的安全边是连接$A$和$A$之外某个结点的边中权重最小的边。</p><ul><li><p><strong>采用的数据结构：最小优先队列</strong>。</p></li><li><p>步骤1：选择任意一个顶点，作为生成树的起始顶点</p></li><li><p>步骤2：保持边集$A$始终为一棵树，选择割$(V_A,V-V_A)$</p></li><li><p>步骤3：选择横跨割$(V_A,V-V_A)$的轻边，添加到边集$A$中</p></li><li><p>步骤4：重复步骤2和步骤3，直至覆盖所有顶点</p></li><li><p>伪代码：</p><blockquote><img src="Chp6-MST-PRIM.png" style="zoom:67%;" /><p>第$1\thicksim 5$行将每个结点的$key$值设为$\infty$（除了根节点$r$的$key$值为0，以便其为第一个被处理的结点），将每个结点的父节点设为$NIL$，并对最小优先队列$Q$进行初始化；</p><p>在每遍$while$循环前，有</p><ul><li>$A&#x3D;{(v,v.\pi):v\in V-{r}-Q}$</li><li>已经加入到最小生成树的结点为集合$V-Q$</li><li>对于所有结点$v\in Q$，如果$v.\pi\ne NIL$，则$v.key&lt;\infty$且$v.key$是连接结点$v$和最小生成树中某个结点的轻边$(v,v.\pi)$的权重。</li></ul><p>第7行找出结点$u\in Q$，该结点是某条横跨割$(V-Q,Q)$的轻边的一个端点，将$u$从$Q$中删除并将$(u,u.\pi)$加入集合$A$中；</p><p>$for$循环对与$u$相邻却不在树中的结点$v$的属性进行更新。</p></blockquote></li><li><p>优先队列</p><ul><li><p>采用二叉堆实现</p></li><li><p><strong>队列中每个元素有一个关键字，依据关键字大小离开队列</strong></p></li></ul></li></ul><table><thead><tr><th align="center">算法</th><th align="center">说明</th><th align="center">时间复杂度</th></tr></thead><tbody><tr><td align="center">$INSERT()$</td><td align="center">向优先队列中插入元素</td><td align="center">$O(\log n)$</td></tr><tr><td align="center">$EXTRACT-MIN(Q)$</td><td align="center">移除优先队列中的最小元素</td><td align="center">$O(\log n)$</td></tr><tr><td align="center">$DECREASE-KEY(u,u.d)$</td><td align="center">更新距离数组，调整优先队列</td><td align="center">$O(\log n)$</td></tr></tbody></table><ul><li><p>算法复杂度</p><ul><li>算法运行时间取决于$Q$的实现方式，如果实现为二叉最小优先队列，则可以使用$BUILD-MIN-HEAP$执行第$1\thicksim 5$行，时间成本为$O(V)$；</li><li>$while$循环一共执行$|V|$次，$EXTRACT-MIN$需要时间成本为$O(\lg V)$，$for$循环执行次数为$O(E)$，第11行隐藏$DECREASE-KEY$操作，在二叉最小堆上执行时间成本为$O(\lg V)$；</li><li>总成本为$O(E\lg V)$。</li></ul></li></ul><h3 id="4-Kruskal-算法"><a href="#4-Kruskal-算法" class="headerlink" title="4.$Kruskal$算法"></a>4.$Kruskal$算法</h3><p>贪心策略：集合$A$始终是<strong>一个森林</strong>，开始时，其结点集就是$G$的结点集，并且$A$是所有单节点树构成的森林。之后每次加入到集合$A$中的安全边是$G$中连接$A$的两个不同分量的权重最小的边。</p><ul><li><p><strong>采用的数据结构：不相交集合</strong>。</p></li><li><p>伪代码：</p><blockquote><img src="Chp6-MST-KRUSKAL.png" style="zoom: 75%;" /><p>第$1\thicksim 3$行将$A$初始化为空集，并创建$|V|$棵树，每棵树只包含一个结点；</p><p>第$5\thicksim 8$行的$for$循环按照权重从低到高的次序对每条边进行检查，如果不在同一棵树中，则加入到集合$A$中，并将两棵树的结点进行合并。</p><p>证明算法保证选择的边为安全边：</p><img src="Chp6-MST-KRUSKAL-安全边证明.png" style="zoom:50%;" /></blockquote></li><li><p>不相交集合</p><ul><li><p>$MAKE-SET(v)$</p><ul><li><p>初始化集合：创建根结点，并设置一条指向自身的边</p></li><li><p>时间复杂度为$O(1)$</p></li><li><p>&#96;&#96;&#96;pseudocode<br>x.parent&#x3D;x<br>return x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- $FIND-SET(v)$</span><br><span class="line"></span><br><span class="line">  - 判定顶点是否在同一集合：回溯查找树根，检查树根是否相同</span><br><span class="line"></span><br><span class="line">  - 时间复杂度为$O(h)$，且$|V|\geq 2^h$，则为$O(\log |V|)$</span><br><span class="line"></span><br><span class="line">  - ```pseudocode</span><br><span class="line">    while x.parent ≠ x do</span><br><span class="line">    x=x.parent</span><br><span class="line">    end</span><br><span class="line">    return x</span><br></pre></td></tr></table></figure></li></ul></li><li><p>$UNION(u,v)$</p><ul><li><p>合并两棵树</p></li><li><p>时间复杂度为$O(h)$，且$|V|\geq 2^h$，则为$O(\log |V|)$</p></li><li><pre><code class="pseudocode">a=FIND-SET(x)b=FIND-SET(y)if a.height ≤ b.height then    if a.height = b.height then        b.height=b.height+1    end    a.parent=bendelse    b.parent=aend</code></pre></li></ul></li></ul></li><li><p>算法复杂度</p><ul><li>将边按照权重升序排序的时间成本为$O(E\log E)$；</li><li>建立不相交集合的时间成本为$O(V)$；</li><li>$while$循环进行了$|E|$次，内部时间复杂度为$O(\log V)$，也即$while$循环总时间复杂度为$O(E\log V)$；</li><li>假设$E&#x3D;O(V^2)$，则总成本为$O(E\lg V)$。</li></ul></li></ul><h3 id="5-算法对比"><a href="#5-算法对比" class="headerlink" title="5.算法对比"></a>5.算法对比</h3><table><thead><tr><th align="center"></th><th align="center">Prim算法</th><th align="center">Kruskal算法</th></tr></thead><tbody><tr><td align="center">核心思想</td><td align="center">保持一颗树，不断扩展</td><td align="center">子树森林，合并为一棵树</td></tr><tr><td align="center">数据结构</td><td align="center">优先队列</td><td align="center">不相交集合</td></tr><tr><td align="center">求解视角</td><td align="center">微观视角，基于当前点选边</td><td align="center">宏观视角，基于全局顺序选边</td></tr><tr><td align="center">算法策略</td><td align="center">采用贪心策略的图算法</td><td align="center">采用贪心策略的图算法</td></tr></tbody></table><h2 id="八、单源点最短路问题"><a href="#八、单源点最短路问题" class="headerlink" title="八、单源点最短路问题"></a>八、单源点最短路问题</h2><h3 id="1-问题背景-1"><a href="#1-问题背景-1" class="headerlink" title="1.问题背景"></a>1.问题背景</h3><p>给定一个带权重的有向图$G&#x3D;(V,E)$和权重函数$\omega:E\rightarrow R$。图中一条路径$p$的权重$\omega(p)$是构成该路径的所有边的权重之和。从结点$u$到结点$v$的最短路径权重定义为$\delta(u,v)$，当没有从$u$到$v$的路径时，$\delta(u,v)&#x3D;\infty$。</p><p>试找出从给定的源点$s\in V$到其他每个结点$v\in V$的最短路径及其最短路径。</p><ul><li><p>单源点最短路问题(单目的地最短路径问题，单节点对最短路径问题)，所有结点对最短路径问题</p></li><li><p>最优子结构性质：两个结点之间的最短路径的任何子路径都是最短的。</p></li><li><p><strong>松弛操作</strong></p><blockquote><p>对于每个结点$v$，维持一个属性$v.d$，记录从源点$s$到结点$v$的最短路径权重的上界。称$v.d$为$s$到$v$的最短路径估计。$INITIALIZE-SINGLE-SOURCE$过程中，对所有$v\in V-{s}$有，$v.d&#x3D;\infty$，$s.d&#x3D;0$。</p><p>松弛操作中，首先进行测试(对$s$到$v$所经过的最后一个中间结点$u$，比较$v.d$和$u.d+w(u,v)$的值)，如果可以<strong>改善</strong>，则更新$v.d$和$v.\pi$。</p><img src="Chp8-RELAX.png"  /><p>时间复杂度为$O(1)$</p></blockquote></li><li><p><strong>松弛操作的性质</strong></p><blockquote><p>三角不等式性质：$\delta(s,v)\leq\delta(s,u)+\omega(u,v)$</p><p>上界性质：$v.d$是$s$到$v$的最短路径权重$\delta(s,v)$的上界</p><p>非路径性质：假定从源结点$s$到给定点$v$之间不存在路径，则该图在由算法$INITIALIZE-SINGLE-SOURCE(G,s)$进行初始化后，有$v.d\geq \delta(s,v)&#x3D;\infty$， 并且该等式作为不变式一直维持到图$G$的所有松弛操作结束。</p></blockquote></li><li><p>若源点$s$无可达负环，则存在源点$s$的单源最短路径(如果有可达负环，则总有更小距离，最终可以松弛到$-\infty$)</p></li></ul><h3 id="2-Bellman-Ford-算法"><a href="#2-Bellman-Ford-算法" class="headerlink" title="2.$Bellman-Ford$算法"></a>2.$Bellman-Ford$算法</h3><ul><li><p>给定带权图$G&#x3D;&lt;V,E,W&gt;$和源点编号$s$，找到源点$s$到所有其他顶点$t$的最短距离$\delta(s,t)$和最短路径$&lt;s,\dots,t&gt;$或存在源点$s$可达的负环。</p></li><li><p>解决挑战1：图中存在负权边时，如何求解单源最短路径? </p><ul><li>每轮对所有边进行松弛，持续迭代$|V|-1$轮。</li></ul></li><li><p>解决挑战2：图中存在负权边时，如何发现源点可达负环?</p><ul><li>若第$|V|$轮仍松弛成功，存在源点$s$可达的负环。</li></ul></li><li><p>伪代码如下</p><blockquote><img src="Chp8-BELLMAN-FORD.png"  /><p>第1行对所有结点的值进行初始化——$\Theta(V)$；</p><p>第$2\thicksim 4$行对每条边进行$|V|-1$次松弛处理，每次循环中都对每条边进行一次松弛操作——$\Theta(E)$，共进行$|V|-1$次循环，总的时间复杂度为$\Theta(VE)$；</p><p>第$5\thicksim 8$行检查图中是否存在权重为负值的环路并返回检查结果——$\O(E)$；</p><p><strong>总的运行时间为$O(VE)$。</strong></p></blockquote></li><li><p>证明在<strong>无可达负环</strong>的情况下可以正确计算最短路径权重</p><blockquote><p>设$G&#x3D;(V,E)$为一个带权重的源点为$s$的有向图，其权重函数为$\omega:E\rightarrow R$，并假定图$G$中<strong>不包含</strong>从源结点$s$可以到达的权重为负值的环路。则$Bellman-ford$算法的第$2\thicksim 4$行的$for$循环在执行$|V|-1$次 之后，对于所有从源结点$s$可以到达的结点$v$有$v.d&#x3D;\delta(s,v)$。</p><p>证明：<strong>利用路径松弛性质</strong>。</p><p>设$G&#x3D;(V,E)$为一个带权重的源点为$s$的有向图，其权重函数为$\omega:E\rightarrow R$，并假定图$G$中<strong>不包含</strong>从源结点$s$可以到达的权重为负值的环路。则对于所有结点$v\in V$，存在一条从源结点$s$到结点$v$的路径当且仅当$BELLMAN-FORD$算法终止时有$v.d&lt;\infty$。</p></blockquote></li><li><p>证明在<strong>有可达负环</strong>的情况下可以返回FALSE值，否则返回TRUE值</p><blockquote><p>假设不包含可达负环时，可以得到$G_\pi$为一棵最短路径树，则当算法终止时，对于所有边$(u,v)\in E$，有$v.d&#x3D;\delta(s,v)\leq \delta(s,u)+\omega(u,v)&#x3D;u.d+\omega(u,v)$，因此返回TRUE；</p><p>假设包含可达负环时，设该环路为$c&#x3D;&lt;v_0,v_1,\dots,v_k&gt;$，其中$v_0&#x3D;v_k$，则有$\sum\limits_{i&#x3D;1}^{k}\omega(v_{i-1},v_i)&lt;0$，假设返回TRUE值，则有$v_i.d\leq v_{i-1}.d+\omega(v_{i-1},v_i)$，这里$i&#x3D;1,2,\dots,k$。将所有不等式相加得到$\sum\limits_{i&#x3D;1}^{k}v_i.d\leq \sum\limits_{i&#x3D;1}^{k}(v_{i-1}.d+\omega(v_{i-1},v_i))&#x3D;\sum\limits_{i&#x3D;1}^{k}v_{i-1}.d+\sum\limits_{i&#x3D;1}^{k}\omega(v_{i-1},v_i)$，而$v_0&#x3D;v_k$，则得到$\sum\limits_{i&#x3D;1}^{k}v_i.d&#x3D;\sum\limits_{i&#x3D;1}^{k}v_{i-1}.d$，又有$\sum\limits_{i&#x3D;1}^{k}\omega(v_{i-1},v_i)\geq 0$，二者矛盾，得证。</p></blockquote></li></ul><h3 id="3-Dijkstra-算法"><a href="#3-Dijkstra-算法" class="headerlink" title="3.$Dijkstra$算法"></a>3.$Dijkstra$算法</h3><ul><li><p>给定带权图$G&#x3D;&lt;V,E,W&gt;$（所有边的权重为正值）和源点编号$s$，找到源点$s$到所有其他顶点$t$的最短距离$\delta(s,t)$和最短路径$&lt;s,\dots,t&gt;$。</p></li><li><p>算法从结点集$V-S$中选择当前最短路径估计最小的结点$u$，将$u$从$Q$中删除，并加入到$S$中，$u.d$就是源结点$s$到$u$的最短路径的 长度。这里$Q$是一个最小优先队列，保存结点集$V-S$。</p></li><li><p>伪代码如下：</p><blockquote><img src="Chp8-DIJKSTRA.png" style="zoom:80%;" /><p>$while$循环执行次数为$|V|$次，$for$循环执行$|E|$次（也即松弛操作次数）。</p></blockquote></li><li><p>证明算法的正确性</p><blockquote><p>采用反证法，假设顶点$u$被添加到$V_A$时，$u.d\ne \delta(s,u)$，而由上界性质有$u.d&gt; \delta(s,u)$。</p><p>应存在一条长度为$\delta(s,u)$的最短路径，设最短路径为$&lt;s,\dots,x,y,\dots,u&gt;$，其中$(x,y)$横跨割$&lt;S,V-S&gt;$，$x\in S$，$y\in V-S$；将$x$加入$S$时，有$x.d&#x3D;\delta(s,x)$，因此$(x,y)$将被松弛，由于$y$是最短路径$p$上的结点，因此有$\delta(s,y)&#x3D;\delta(s,x)+\omega(x,y)&#x3D;x.d+\omega(x,y)$，$y.d\leq x.d+\omega(x,y)$，得到$y.d&#x3D;\delta(s,y)$，因此有$u.d&gt;\delta(s,u)\geq \delta(s,y)&#x3D;y.d$，显然$u$不是下一个被添加结点，矛盾，得证。</p></blockquote></li><li><p>时间复杂度分析</p><ul><li>总运行时间依赖于$Q$的实现，采用二叉堆实现时，每次找到结点$u$需要$O(\lg V)$的时间，总运行时间为$O((V+E)\lg V)$。</li></ul></li></ul><h3 id="4-算法对比"><a href="#4-算法对比" class="headerlink" title="4.算法对比"></a>4.算法对比</h3><table><thead><tr><th align="center"></th><th align="center">广度优先搜索</th><th align="center">Dijkstra算法</th><th align="center">Bellman-Ford算法</th></tr></thead><tbody><tr><td align="center">适用范围</td><td align="center">无权图</td><td align="center">带权图（所有边权重为正）</td><td align="center">带权图</td></tr><tr><td align="center">松弛次数</td><td align="center">——</td><td align="center">$</td><td align="center">E</td></tr><tr><td align="center">数据结构</td><td align="center">队列</td><td align="center">优先队列</td><td align="center">——</td></tr><tr><td align="center">运行时间</td><td align="center">$O(</td><td align="center">V</td><td align="center">+</td></tr></tbody></table><h3 id="5-差分约束系统"><a href="#5-差分约束系统" class="headerlink" title="5.差分约束系统"></a>5.差分约束系统</h3><ul><li><p>线性规划：给定一个$m\times m$的矩阵$A$、一个$m$维的向量$b$和一个$n$维的向量$c$。试找一$n$维向量$x$，使得在$Ax\leq b$的约束下，目标函数$\sum\limits_{i&#x3D;1}^{n}{c_ix_i}$最大。</p></li><li><p>差分约束系统：矩阵$A$的每一行包括一个1和一个-1，其他所有项均为0。则上述问题转化为$m$个涉及$n$个变量的差额限制条件，每个约束条件均为简单的线性不等关系：$x_j-x_i\leq b_k$，这里$1\leq i,j\leq n,i\ne j,1\leq k\leq m$。</p></li><li><p>解的线性性</p><blockquote><p>$x&#x3D;(x_1,x_2,\dots,x_n)$为解，则$x+d&#x3D;(x_1+d,x_2+d,\dots,x_n+d)$也为解；</p></blockquote></li><li><p>约束图</p><blockquote><img src="Chp6-约束图.png" style="zoom: 80%;" /><p>引入额外结点$v_0$，从其出发可到达任何结点，因此节点集合$V$为${v_0,v_1,\dots,v_n}$</p><p>边集合$E$包含代表每个差分约束的边，同时包含$v_0$到其他所有结点的边$(v_0,v_i)$</p><p>如果$x_j-x_i\leq b_k$是一个差分约束条件，则边$(v_i,v_j)$的权重记为$\omega(v_i,v_j)&#x3D;b_k$，而从$v_0$出发到其他结点的边的权重$\omega(v_0,v_j)&#x3D;0$。</p><img src="Chp6-约束图-SAMPLE.png" style="zoom:67%;" /></blockquote></li><li><p>问题的转换</p></li></ul><p>给定差分约束系统$Ax\leq b$，设$G&#x3D;(V,E)$是该差分约束系统所对应的约束图。如果图$G$不包含权重为负值的回路，则$x&#x3D;(\delta(v_0,v_1),\delta(v_0,v_2),\delta(v_0,v_3),\dots,\delta(v_0,v_n))$是该系统的一个可行解。如果图$G$包含权重为负值的回路，则该系统没有可行解。</p><p><img src="/2022/08/19/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0/Chp6-%E7%BA%A6%E6%9D%9F%E5%9B%BE%E8%AF%81%E6%98%8E.png"></p><p>设未知变量的个数$n&#x3D;|x_i|$，不等式个数为m。则使用$Bellman-Ford$算法时，顶点数为$n+1$，边数为$m+n$，因此可以在$O(n^2+mn)$的时间内完成求解。</p><h2 id="九、所有结点对的最短路径问题"><a href="#九、所有结点对的最短路径问题" class="headerlink" title="九、所有结点对的最短路径问题"></a>九、所有结点对的最短路径问题</h2><h3 id="1-问题背景-2"><a href="#1-问题背景-2" class="headerlink" title="1.问题背景"></a>1.问题背景</h3><p>给定一个带权重的有向图$G&#x3D;(V,E)$和权重函数$\omega:E\rightarrow R$。图中一条路径$p$的权重$\omega(p)$是构成该路径的所有边的权重之和。从结点$u$到结点$v$的最短路径权重定义为$\delta(u,v)$，当没有从$u$到$v$的路径时，$\delta(u,v)&#x3D;\infty$。</p><p>求$\forall u,v\in V$，从$u$到$v$的最短路径。</p><h3 id="2-问题分析-6"><a href="#2-问题分析-6" class="headerlink" title="2.问题分析"></a>2.问题分析</h3><ul><li><p>直观上，可以使用$Dijkstra$算法依次求解所有点，此时存在重叠子问题；</p></li><li><p>使用$Dijkstra$算法依次求解所有点的算法复杂度为$O(|V||E|\log|V|)$，对于稠密图有$|E|&#x3D;O(|V|^2)$，因此算法复杂度为$O(|V|^3\log|V|)$；</p></li><li><p>而观察松弛过程发现，具有最优子结构性：</p></li></ul><img src="Chp9-最优子结构示意图.png" style="zoom:50%;" /><ul><li><p>设$D[k,i,j]$表示：可从前$k$个点选点经过时，$i$到$j$的最短距离，则原始问题为$D[|V|,i,j]$</p><blockquote><p>如果不选第$k$个点经过，则$D[k,i,j]&#x3D;D[k-1,i,j]$；</p><p>如果选则第$k$个点经过，则$D[k,i,j]&#x3D;D[k-1,i,k]+D[k-1,k,j]$；</p><p>因此，$D[k,i,j]&#x3D;min{D[k-1,i,k]+D[k-1,k,j],D[k-1,i,j]}$</p></blockquote></li></ul><h3 id="3-自底向上的-Floyd-Warshall-算法"><a href="#3-自底向上的-Floyd-Warshall-算法" class="headerlink" title="3.自底向上的$Floyd-Warshall$算法"></a>3.自底向上的$Floyd-Warshall$算法</h3><ul><li><p>初始化数组</p><ul><li>$D[0,i,i]&#x3D;0$：起点和终点重合，路径长度为0</li><li>$D[0,i,j]&#x3D;e[i,j]$：任意两点直达距离为边权</li></ul></li><li><p>自底向上计算</p><ul><li>按$k$增加的顺序计算，求解时当前层只依赖上一层</li><li>只需要两层表格——待计算和上一次结果</li><li>当**$k&#x3D;i或k&#x3D;j$**时，$D[k,i,j]&#x3D;D[k-1,i,j]$，可以直接覆盖；</li><li>当**$k\ne i且k\ne j$<strong>时，$D[k-1,i,k]+D[k-1,k,j]$和$D[k-1,i,j]$不是相同子问题，当求出$D[k,i,j]$后，$D[k-1,i,j]$不再被使用，可直接覆盖——</strong>求出新值可直接在原位置覆盖，只需存储一层表格**；</li></ul></li><li><p>构建最优解</p><ul><li><p>使用前驱结点矩阵记录经过的中间点，此处使用追踪数组$Rec$记录经过的中间点</p><blockquote><p>$D_k[i,j]&#x3D;D_{k-1}[i,j]$时$Rec$记录为0，表示没有中间点</p><p>$D[k,i,j]&#x3D;D[k-1,i,k]+D[k-1,k,j]$时$Rec$记录为$k$，表示经过中间点$k$</p></blockquote></li></ul></li><li><p>伪代码如下：</p><blockquote><p>$All-Pairs-Shortest-Paths$：</p><img src="Chp9-ALL-PAIRS-SHORTEST-PATHS-1.png" style="zoom: 33%;" /><p>初始化数组$D$和$Rec$；</p><img src="Chp9-ALL-PAIRS-SHORTEST-PATHS-2.png" style="zoom: 33%;" /><p>按照$k$增大的顺序，对于任意一对$i,j$，进行松弛操作，并更新相关数组。</p><p>$Find-Path$：</p><img src="Chp9-FIND-PATH.png" style="zoom:50%;" /></blockquote></li><li><p>算法复杂度为$O(|V|^3)$</p></li></ul><h3 id="4-最短路径算法小结"><a href="#4-最短路径算法小结" class="headerlink" title="4.最短路径算法小结"></a>4.最短路径算法小结</h3><img src="Chp9-最短路径算法小结.png" style="zoom: 80%;" /><h2 id="十、最大流"><a href="#十、最大流" class="headerlink" title="十、最大流"></a>十、最大流</h2><h3 id="1-最大二分匹配"><a href="#1-最大二分匹配" class="headerlink" title="1.最大二分匹配"></a>1.最大二分匹配</h3><h4 id="1-问题描述-10"><a href="#1-问题描述-10" class="headerlink" title="(1)问题描述"></a>(1)问题描述</h4><ul><li><p>给定一个无向图$G&#x3D;&lt;V,E&gt;$，其中$V&#x3D;L\cup R,L\cap R&#x3D;\Phi$，并且每条边$e\in E$有一个端点在$L$中而另一个端点在$R$中，可记为二分图$G&#x3D;&lt;L,R,E&gt;$。</p></li><li><p>图$G&#x3D;&lt;V,E&gt;$中的一个匹配$M$是图$G$边集$E$的子集$(M\subseteq E)$，其中每个顶点至多关联$M$的一条边。</p></li><li><p>现给定二分图$G&#x3D;&lt;L,R,E&gt;$，求出匹配$M&#x3D;{e_1,e_2,\dots,e_k}$，使得$max|M|$，满足$\forall i,j(i\ne j),e_i&#x3D;(l_i,r_i),e_j&#x3D;(l_j,r_j)$，有$l_i\ne l_j$且$r_i\ne r_j$。</p><blockquote><p>即使得匹配数最大且每个顶点至多关联一条边。</p></blockquote></li></ul><h4 id="2-问题分析-7"><a href="#2-问题分析-7" class="headerlink" title="(2)问题分析"></a>(2)问题分析</h4><ul><li><p>直观上，可以遍历$L$中的顶点，依次检查之并与$R$中顶点进行匹配，这种策略可能达不到最大匹配，需要通过撤销边和连接边来增广原匹配。</p></li><li><p>定义<strong>交替路径</strong>：从未匹配顶点出发，依次经过<strong>“非匹配边、匹配边…非匹配边”</strong>形成的路径</p><blockquote><img src="Chp10-交替路径举例.png" style="zoom:67%;" /></blockquote></li><li><p>不断寻找交替路径进行增广</p><ul><li>依次检测左侧顶点，若相邻顶点<strong>未匹配</strong>，则构成交替路径，<strong>直接进行匹配</strong>；若相邻顶点<strong>已经匹配</strong>，则尝试寻找交替路径，<strong>增广成新匹配</strong>；</li><li>直至所有左侧顶点检测完后结束。</li></ul></li><li><p>辅助数组</p><ul><li><p>$matched$表示$L$与$R$中顶点的匹配关系</p><blockquote><p>以$R$中顶点作为下标，如$match[R_2]\leftarrow L_1$</p></blockquote></li><li><p>$color$表示深度优先搜索辅助数组</p><ul><li>white表示未被搜索过，black已被搜索过</li><li>每次搜索前初始化$color$数组</li></ul></li></ul></li></ul><h4 id="3-匈牙利算法"><a href="#3-匈牙利算法" class="headerlink" title="(3)匈牙利算法"></a>(3)匈牙利算法</h4><ul><li><p>伪代码如下：</p><blockquote><p>$Hungarian(G)$</p><img src="Chp10-Hungarian.png" style="zoom: 50%;" /><p>$DFS-Find(v)$</p><img src="Chp10-DFS-Find.png" style="zoom:49%;" /></blockquote></li><li><p>正确性证明：</p><ul><li>命题1：匈牙利算法得到的匹配$M$无交替路径</li><li>命题2：匹配$M$无交替路径$\Leftrightarrow$匹配$M$是最大匹配</li></ul></li></ul><h3 id="2-最大流算法"><a href="#2-最大流算法" class="headerlink" title="2.最大流算法"></a>2.最大流算法</h3><h4 id="1-问题描述-11"><a href="#1-问题描述-11" class="headerlink" title="(1)问题描述"></a>(1)问题描述</h4><ul><li><p>给定有向图$G&#x3D;&lt;V,E,C&gt;$，称之为流网络，$C$代表边权。</p><ul><li><p>源点为$s$，汇点为$t$</p></li><li><p>容量：每条边的边权$c(e)\geq 0$</p></li><li><p>流量：每条边的被占有容量$f(e)\geq 0$</p></li><li><p>剩余容量：对于每条边，剩余容量为$c(e)-f(e)$</p></li><li><p>总流量&#x3D;源点流出量&#x3D;汇点流入量：$|f|&#x3D;\sum_{e\ out\ of\ s}f(e)&#x3D;\sum_{e\ in\ to\ t}f(e)$</p></li><li><p>容量限制：对于边$e\in E$，有$0\leq f(e)\leq c(e)$</p><blockquote><p>边上的流量不应超过边上的容量</p></blockquote></li><li><p>流量守恒：对顶点$v\in V-{s,t}$，$\sum_{e\ out\ of\ s}f(e)&#x3D;\sum_{e\ in\ to\ t}f(e)$</p><blockquote><p>进入某顶点$v$流量和等于流出此顶点流量和</p></blockquote></li></ul></li><li><p>现根据有向图$G&#x3D;&lt;V,E,C&gt;$，源点$s$，汇点$t$，在满足容量限制和流量守恒的约束条件下，求出最大流量。</p></li></ul><h4 id="2-直观策略"><a href="#2-直观策略" class="headerlink" title="(2)直观策略"></a>(2)直观策略</h4><ul><li><p>算法思想</p><ul><li>对于所有边$e\in E$，初始化流量为$f(e)&#x3D;0$</li><li>寻找一条$s$到$t$的路径$P$，此路径上每条边$e$均满足$f(e)&lt;c(e)$</li><li>按路径$P$上的最小剩余容量增加路径流量</li><li>迭代寻找路径$P$直至无法增加路径流量</li></ul></li><li><p><strong>此方法可能无法达到最大流量</strong></p></li><li><p><strong>不足之处：只能扩充边的流量，不能缩减边的流量</strong></p></li><li><p>如果允许缩减边上的容量 ，则可以进一步增大总流量$\rightarrow$如果寻找路径时允许逆向搜索，可以增大总流量$\rightarrow$引入反向边，实现逆向搜索</p></li><li><p>残存网络</p><ul><li><p>定义反向边权重：可缩减流量的上限，也即原始边上的流量$f(e)$</p></li><li><p>定义正向边权重：可扩充流量的上限，也即原始边上的剩余容量$c(e)-f(e)$</p></li><li><p>则根据流网络$G&#x3D;&lt;V,E,C&gt;$和流量$f$，可得残存网络$G_f&#x3D;&lt;V,E_f&gt;$，其中每条边的残存容量满足上述规则</p></li><li><p>定义增广路径：增广路径$p$是残存网络$G_f$中一条从源点$s$到汇点$t$的简单路径(路径上的各顶点均不互相重复)</p></li><li><p>定义增广路径的残存容量：路径上各边残存容量的最小值</p><blockquote><p>流量扩充的最大值为增广路径的残存容量</p></blockquote></li></ul></li></ul><h4 id="3-Ford-Fulkerson-算法"><a href="#3-Ford-Fulkerson-算法" class="headerlink" title="(3)$Ford-Fulkerson$算法"></a>(3)$Ford-Fulkerson$算法</h4><ul><li>算法思想<ul><li>对于所有边$e\in E$，初始化流量为$f(e)&#x3D;0$</li><li><strong>构造残存网络$G_f$，寻找$s$到$t$的增广路径$P$</strong></li><li>按路径$P$的<strong>残存容量</strong>增加路径流量</li><li>迭代寻找路径$P$直至无法增加路径流量</li></ul></li><li>伪代码如下</li><li>算法复杂度</li><li>正确性证明<ul><li>充分性：$f$是最大流$\Rightarrow$残存网络$G_f$中无增广路径</li><li>必要性：$f$是最大流$\Leftarrow$残存网络$G_f$中无增广路径</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 专业核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
