<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2022/08/23/divide-and-conquer/"/>
      <url>/2022/08/23/divide-and-conquer/</url>
      
        <content type="html"><![CDATA[<p>author: fudonglai, AngelKitty, labuladong</p><p>本页面将介绍递归与分治算法的区别与结合运用。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>递归（英语：Recursion），在数学和计算机科学中是指在函数的定义中使用函数自身的方法，在计算机科学中还额外指一种通过重复将问题分解为同类的子问题而解决问题的方法。</p><p>分治（英语：Divide and Conquer），字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</p><h2 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><blockquote><p>要理解递归，就得先理解什么是递归。</p></blockquote><p>递归的基本思想是某个函数直接或者间接地调用自身，这样原问题的求解就转换为了许多性质相同但是规模更小的子问题。求解时只需要关注如何把原问题划分成符合条件的子问题，而不需要过分关注这个子问题是如何被解决的。</p><p>以下是一些有助于理解递归的例子：</p><ol><li><a href="./divide-and-conquer.md">什么是递归？</a></li><li>如何给一堆数字排序？答：分成两半，先排左半边再排右半边，最后合并就行了，至于怎么排左边和右边，请重新阅读这句话。</li><li>你今年几岁？答：去年的岁数加一岁，1999 年我出生。</li><li><img src="/images/divide-and-conquer-1.png" alt="一个用于理解递归的例子"></li></ol><p>递归在数学中非常常见。例如，集合论对自然数的正式定义是：1 是一个自然数，每个自然数都有一个后继，这一个后继也是自然数。</p><p>递归代码最重要的两个特征：结束条件和自我调用。自我调用是在解决子问题，而结束条件定义了最简子问题的答案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(传入数值)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (终止条件) <span class="keyword">return</span> 最小子问题解;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">func</span>(缩小规模);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="为什么要写递归"><a href="#为什么要写递归" class="headerlink" title="为什么要写递归"></a>为什么要写递归</h4><ol><li><p>结构清晰，可读性强。例如，分别用不同的方法实现 <a href="./merge-sort.md">归并排序</a>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="comment">// 不使用递归的归并排序算法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(vector&lt;T&gt; a)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> seg = <span class="number">1</span>; seg &lt; n; seg = seg + seg)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> start = <span class="number">0</span>; start &lt; n - seg; start += seg + seg)</span><br><span class="line">      <span class="built_in">merge</span>(a, start, start + seg - <span class="number">1</span>, std::<span class="built_in">min</span>(start + seg + seg - <span class="number">1</span>, n - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用递归的归并排序算法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(vector&lt;T&gt; a, <span class="type">int</span> front, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (front &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> mid = front + (end - front) / <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">merge_sort</span>(a, front, mid);</span><br><span class="line">  <span class="built_in">merge_sort</span>(a, mid + <span class="number">1</span>, end);</span><br><span class="line">  <span class="built_in">merge</span>(a, front, mid, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python Version</span></span><br><span class="line"><span class="comment">#不使用递归的归并排序算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">a</span>):</span><br><span class="line">  n = <span class="built_in">len</span>(a)</span><br><span class="line">  seg, start = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> seg &lt; n:</span><br><span class="line">      <span class="keyword">while</span> start &lt; n - seg:</span><br><span class="line">          merge(a, start, start + seg - <span class="number">1</span>, <span class="built_in">min</span>(start + seg + seg - <span class="number">1</span>, n - <span class="number">1</span>))</span><br><span class="line">          start = start + seg + seg</span><br><span class="line">      seg = seg + seg</span><br><span class="line">  </span><br><span class="line"><span class="comment">#使用递归的归并排序算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">a, front, end</span>):</span><br><span class="line">  <span class="keyword">if</span> front &gt;= end:</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">  mid = front + (end - front) / <span class="number">2</span></span><br><span class="line">  merge_sort(a, front, mid)</span><br><span class="line">  merge_sort(a, mid + <span class="number">1</span>, end)</span><br><span class="line">  merge(a, front, mid, end)</span><br></pre></td></tr></table></figure><p>显然，递归版本比非递归版本更易理解。递归版本的做法一目了然：把左半边排序，把右半边排序，最后合并两边。而非递归版本看起来不知所云，充斥着各种难以理解的边界计算细节，特别容易出 bug，且难以调试。</p></li><li><p>练习分析问题的结构。当发现问题可以被分解成相同结构的小问题时，递归写多了就能敏锐发现这个特点，进而高效解决问题。</p></li></ol><h4 id="递归的缺点"><a href="#递归的缺点" class="headerlink" title="递归的缺点"></a>递归的缺点</h4><p>在程序执行中，递归是利用堆栈来实现的。每当进入一个函数调用，栈就会增加一层栈帧，每次函数返回，栈就会减少一层栈帧。而栈不是无限大的，当递归层数过多时，就会造成 <strong>栈溢出</strong> 的后果。</p><p>显然有时候递归处理是高效的，比如归并排序；<strong>有时候是低效的</strong>，比如数孙悟空身上的毛，因为堆栈会消耗额外空间，而简单的递推不会消耗空间。比如这个例子，给一个链表头，计算它的长度：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 典型的递推遍历框架</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">(Node *head)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (Node *p = head; p != <span class="literal">nullptr</span>; p = p-&gt;next) size++;</span><br><span class="line">  <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我就是要写递归，递归天下第一</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">size_recursion</span><span class="params">(Node *head)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">size_recursion</span>(head-&gt;next) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/divide-and-conquer-2.png" alt="[二者的对比，compiler 设为 Clang 10.0，优化设为 O1](https://quick-bench.com/q/rZ7jWPmSdltparOO5ndLgmS9BVc)" title="[二者的对比，compiler 设为 Clang 10.0，优化设为 O1](https://quick-bench.com/q/rZ7jWPmSdltparOO5ndLgmS9BVc)"></p><h4 id="递归优化"><a href="#递归优化" class="headerlink" title="递归优化"></a>递归优化</h4><p>主页面：<a href="../search/opt.md">搜索优化</a> 和 <a href="../dp/memo.md">记忆化搜索</a></p><p>比较初级的递归实现可能递归次数太多，容易超时。这时需要对递归进行优化。[^ref1]</p><h3 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h3><p>分治算法的核心思想就是“分而治之”。</p><p>大概的流程可以分为三步：分解 -&gt; 解决 -&gt; 合并。</p><ol><li>分解原问题为结构相同的子问题。</li><li>分解到某个容易求解的边界之后，进行递归求解。</li><li>将子问题的解合并成原问题的解。</li></ol><p>分治法能解决的问题一般有如下特征：</p><ul><li>该问题的规模缩小到一定的程度就可以容易地解决。</li><li>该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质，利用该问题分解出的子问题的解可以合并为该问题的解。</li><li>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。</li></ul><p>???+warning “注意”<br>    如果各子问题是不独立的，则分治法要重复地解公共的子问题，也就做了许多不必要的工作。此时虽然也可用分治法，但一般用 <a href="../dp/basic.md">动态规划</a> 较好。</p><p>以归并排序为例。假设实现归并排序的函数名为 <code>merge_sort</code>。明确该函数的职责，即 <strong>对传入的一个数组排序</strong>。这个问题显然可以分解。给一个数组排序等于给该数组的左右两半分别排序，然后合并成一个数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(一个数组)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (可以很容易处理) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">merge_sort</span>(左半个数组);</span><br><span class="line">  <span class="built_in">merge_sort</span>(右半个数组);</span><br><span class="line">  <span class="built_in">merge</span>(左半个数组, 右半个数组);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传给它半个数组，那么处理完后这半个数组就已经被排好了。注意到，<code>merge_sort</code> 与二叉树的后序遍历模板极其相似。因为分治算法的套路是 <strong>分解 -&gt; 解决（触底）-&gt; 合并（回溯）</strong>，先左右分解，再处理合并，回溯就是在退栈，即相当于后序遍历。</p><p><code>merge</code> 函数的实现方式与两个有序链表的合并一致。</p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><h3 id="写递归的要点"><a href="#写递归的要点" class="headerlink" title="写递归的要点"></a>写递归的要点</h3><p><strong>明白一个函数的作用并相信它能完成这个任务，千万不要跳进这个函数里面企图探究更多细节，</strong> 否则就会陷入无穷的细节无法自拔，人脑能压几个栈啊。</p><p>以遍历二叉树为例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">traverse</span>(root-&gt;left);</span><br><span class="line">  <span class="built_in">traverse</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这几行代码就足以遍历任何一棵二叉树了。对于递归函数 <code>traverse(root)</code>，只要相信给它一个根节点 <code>root</code>，它就能遍历这棵树。所以只需要把这个节点的左右节点再传给这个函数就行了。</p><p>同样扩展到遍历一棵 N 叉树。与二叉树的写法一模一样。不过，对于 N 叉树，显然没有中序遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> child : root-&gt;children) <span class="built_in">traverse</span>(child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><h3 id="递归与枚举的区别"><a href="#递归与枚举的区别" class="headerlink" title="递归与枚举的区别"></a>递归与枚举的区别</h3><p>递归和枚举的区别在于：枚举是横向地把问题划分，然后依次求解子问题；而递归是把问题逐级分解，是纵向的拆分。</p><h3 id="递归与分治的区别"><a href="#递归与分治的区别" class="headerlink" title="递归与分治的区别"></a>递归与分治的区别</h3><p>递归是一种编程技巧，一种解决问题的思维方式；分治算法很大程度上是基于递归的，解决更具体问题的算法思想。</p><h2 id="例题详解"><a href="#例题详解" class="headerlink" title="例题详解"></a>例题详解</h2><p>???+note “<a href="https://leetcode-cn.com/problems/path-sum-iii/">437. 路径总和 III</a>“<br>    给定一个二叉树，它的每个结点都存放着一个整数值。</p><pre><code>找出路径和等于给定数值的路径总数。路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。二叉树不超过 1000 个节点，且节点数值范围是[-1000000,1000000]的整数。示例：<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</span><br><span class="line"></span><br><span class="line">      10</span><br><span class="line">     /  \</span><br><span class="line">    5   -3</span><br><span class="line">   / \    \</span><br><span class="line">  3   2   11</span><br><span class="line"> / \   \</span><br><span class="line">3  -2   1</span><br><span class="line"></span><br><span class="line">返回 3。和等于 8 的路径有：</span><br><span class="line"></span><br><span class="line">1.  5 -&gt; 3</span><br><span class="line">2.  5 -&gt; 2 -&gt; 1</span><br><span class="line">3. -3 -&gt; 11</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树结点的定义</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></code></pre><p>??? note “参考代码”<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pathSum</span><span class="params">(TreeNode *root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">count</span>(root, sum) + <span class="built_in">pathSum</span>(root-&gt;left, sum) +</span><br><span class="line">         <span class="built_in">pathSum</span>(root-&gt;right, sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(TreeNode *node, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> (node-&gt;val == sum) + <span class="built_in">count</span>(node-&gt;left, sum - node-&gt;val) +</span><br><span class="line">         <span class="built_in">count</span>(node-&gt;right, sum - node-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>??? note “题目解析”<br>    题目看起来很复杂，不过代码却极其简洁。</p><pre><code>首先明确，递归求解树的问题必然是要遍历整棵树的，所以二叉树的遍历框架（分别对左右子树递归调用函数本身）必然要出现在主函数 pathSum 中。那么对于每个节点，它们应该干什么呢？它们应该看看，自己和它们的子树包含多少条符合条件的路径。好了，这道题就结束了。按照前面说的技巧，根据刚才的分析来定义清楚每个递归函数应该做的事：`PathSum` 函数：给定一个节点和一个目标值，返回以这个节点为根的树中，和为目标值的路径总数。`count` 函数：给定一个节点和一个目标值，返回以这个节点为根的树中，能凑出几个以该节点为路径开头，和为目标值的路径总数。??? note &quot;参考代码（附注释）&quot;    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pathSum</span><span class="params">(TreeNode *root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> pathImLeading = <span class="built_in">count</span>(root, sum);  <span class="comment">// 自己为开头的路径数</span></span><br><span class="line">  <span class="type">int</span> leftPathSum = <span class="built_in">pathSum</span>(root-&gt;left, sum);  <span class="comment">// 左边路径总数（相信它能算出来）</span></span><br><span class="line">  <span class="type">int</span> rightPathSum =</span><br><span class="line">      <span class="built_in">pathSum</span>(root-&gt;right, sum);  <span class="comment">// 右边路径总数（相信它能算出来）</span></span><br><span class="line">  <span class="keyword">return</span> leftPathSum + rightPathSum + pathImLeading;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(TreeNode *node, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 能不能作为一条单独的路径呢？</span></span><br><span class="line">  <span class="type">int</span> isMe = (node-&gt;val == sum) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 左边的，你那边能凑几个 sum - node.val ？</span></span><br><span class="line">  <span class="type">int</span> leftNode = <span class="built_in">count</span>(node-&gt;left, sum - node-&gt;val);</span><br><span class="line">  <span class="comment">// 右边的，你那边能凑几个 sum - node.val ？</span></span><br><span class="line">  <span class="type">int</span> rightNode = <span class="built_in">count</span>(node-&gt;right, sum - node-&gt;val);</span><br><span class="line">  <span class="keyword">return</span> isMe + leftNode + rightNode;  <span class="comment">// 我这能凑这么多个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>还是那句话，**明白每个函数能做的事，并相信它们能够完成。**总结下，`PathSum` 函数提供了二叉树遍历框架，在遍历中对每个节点调用 `count` 函数（这里用的是先序遍历，不过中序遍历和后序遍历也可以）。`count` 函数也是一个二叉树遍历，用于寻找以该节点开头的目标值路径。</code></pre><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><ul><li><a href="https://leetcode.com/explore/learn/card/recursion-i/">LeetCode 上的递归专题练习</a></li><li><a href="https://leetcode.com/tag/divide-and-conquer/">LeetCode 上的分治算法专项练习</a></li></ul><h2 id="参考资料与注释"><a href="#参考资料与注释" class="headerlink" title="参考资料与注释"></a>参考资料与注释</h2><p>[^ref1]: <a href="https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/di-gui-xiang-jie">labuladong 的算法小抄 - 递归详解</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/08/23/counting-sort/"/>
      <url>/2022/08/23/counting-sort/</url>
      
        <content type="html"><![CDATA[<p>???+ warning<br>    本页面要介绍的不是 <a href="./radix-sort.md"><strong>基数排序</strong></a>。</p><p>本页面将简要介绍计数排序。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>计数排序（英语：Counting sort）是一种线性时间的排序算法。</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>计数排序的工作原理是使用一个额外的数组 $C$，其中第 $i$ 个元素是待排序数组 $A$ 中值等于 $i$ 的元素的个数，然后根据数组 $C$ 来将 $A$ 中的元素排到正确的位置。[^ref1]</p><p>它的工作过程分为三个步骤：</p><ol><li>计算每个数出现了几次；</li><li>求出每个数出现次数的 <a href="./prefix-sum.md">前缀和</a>；</li><li>利用出现次数的前缀和，从右至左计算每个数的排名。</li></ol><p><img src="/images/counting-sort-1-animate-example.svg" alt="counting sort animate example"></p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>计数排序是一种稳定的排序算法。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>计数排序的时间复杂度为 $O(n+w)$，其中 $w$ 代表待排序数据的值域大小。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><p>$$<br>\begin{array}{ll}<br>1 &amp; \textbf{Input. } \text{An array } A \text{ consisting of }n\text{ positive integers no greater than } w. \<br>2 &amp; \textbf{Output. } \text{Array }A\text{ after sorting in nondecreasing order stably.} \<br>3 &amp; \textbf{Method. }  \<br>4 &amp; \textbf{for }i\gets0\textbf{ to }w\<br>5 &amp; \qquad cnt[i]\gets0\<br>6 &amp; \textbf{for }i\gets1\textbf{ to }n\<br>7 &amp; \qquad cnt[A[i]]\gets cnt[A[i]]+1\<br>8 &amp; \textbf{for }i\gets1\textbf{ to }w\<br>9 &amp; \qquad cnt[i]\gets cnt[i]+cnt[i-1]\<br>10 &amp; \textbf{for }i\gets n\textbf{ downto }1\<br>11 &amp; \qquad B[cnt[A[i]]]\gets A[i]\<br>12 &amp; \qquad cnt[A[i]]\gets cnt[A[i]]-1\<br>13 &amp; \textbf{return } B<br>\end{array}<br>$$</p><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> W = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, w, a[N], cnt[W], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">counting_sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnt));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++cnt[a[i]];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= w; ++i) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; --i) b[cnt[a[i]]--] = a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python Version</span></span><br><span class="line">N = W = <span class="number">100010</span></span><br><span class="line">n = w = <span class="number">0</span></span><br><span class="line">a = b = [<span class="number">0</span>] * N</span><br><span class="line">cnt = [<span class="number">0</span>] * W</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">counting_sort</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        cnt[a[i]] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, w + <span class="number">1</span>):</span><br><span class="line">        cnt[i] += cnt[i - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        b[cnt[a[i]] - <span class="number">1</span>] = a[i]</span><br><span class="line">        cnt[a[i]] -= <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="参考资料与注释"><a href="#参考资料与注释" class="headerlink" title="参考资料与注释"></a>参考资料与注释</h2><p>[^ref1]: <a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F">计数排序 - 维基百科，自由的百科全书</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/08/23/construction/"/>
      <url>/2022/08/23/construction/</url>
      
        <content type="html"><![CDATA[<p>author: leoleoasd, yzxoi</p><p>本页面将简要介绍构造题这类题型。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>构造题是比赛中常见的一类题型。</p><p>从形式上来看，问题的答案往往具有某种规律性，使得在问题规模迅速增大的时候，仍然有机会比较容易地得到答案。</p><p>这要求解题时要思考问题规模增长对答案的影响，这种影响是否可以推广。例如，在设计动态规划方法的时候，要考虑从一个状态到后继状态的转移会造成什么影响。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>构造题一个很显著的特点就是高自由度，也就是说一道题的构造方式可能有很多种，但是会有一种较为简单的构造方式满足题意。看起来是放宽了要求，让题目变的简单了，但很多时候，正是这种高自由度导致题目没有明确思路而无从下手。</p><p>构造题另一个特点就是形式灵活，变化多样。并不存在一个通用解法或套路可以解决所有构造题，甚至很难找出解题思路的共性。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>下面将列举一些例题帮助读者体会构造题的一些思想内涵，给予思路上的启发。建议大家深入思考后再查看题解，也欢迎大家参与分享有趣的构造题。</p><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题 1"></a>例题 1</h3><p>???+note “<a href="http://codeforces.com/problemset/problem/743/C">Codeforces Round #384 (Div. 2) C.Vladik and fractions</a>“<br>    构造一组 $x,y,z$，使得对于给定的 $n$，满足 $\dfrac{1}{x}+\dfrac{1}{y}+\dfrac{1}{z}&#x3D;\dfrac{2}{n}$</p><p>??? note “解题思路”<br>    从样例二可以看出本题的构造方法。</p><pre><code>显然 $n,n+1,n(n+1)$ 为一组合法解。特殊地，当 $n=1$ 时，无解，这是因为 $n+1$ 与 $n(n+1)$ 此时相等。至于构造思路是怎么产生的，大概就是观察样例加上一点点数感了吧。此题对于数学直觉较强的人来说并不难。</code></pre><h3 id="例题-2"><a href="#例题-2" class="headerlink" title="例题 2"></a>例题 2</h3><p>???+note “<a href="https://www.luogu.com.cn/problem/P3599">Luogu P3599 Koishi Loves Construction</a>“<br>    Task1：试判断能否构造并构造一个长度为 $n$ 的 $1\dots n$ 的排列，满足其 $n$ 个前缀和在模 $n$ 的意义下互不相同</p><pre><code>Taks2：试判断能否构造并构造一个长度为 $n$ 的 $1\dots n$ 的排列，满足其 $n$ 个前缀积在模 $n$ 的意义下互不相同</code></pre><p>??? note “解题思路”<br>    对于 task1：</p><pre><code>当 $n$ 为奇数时，无法构造出合法解；当 $n$ 为偶数时，可以构造一个形如 $n,1,n-2,3,\cdots$ 这样的数列。首先，我们可以发现 $n$ 必定出现在数列的第一位，否则 $n$ 出现前后的两个前缀和必然会陷入模意义下相等的尴尬境地；然后，我们考虑构造出整个序列的方式：考虑通过构造前缀和序列的方式来获得原数列，可以发现前缀和序列两两之间的差在模意义下不能相等，因为前缀和序列的差分序列对应着原来的排列。因此我们尝试以前缀和数列在模意义下为$$0,1,-1,2,-2,\cdots$$这样的形式来构造这个序列，不难发现它完美地满足所有限制条件。对于 task2：当 $n$ 为除 $4$ 以外的合数时，无法构造出合法解当 $n$ 为质数或 $4$ 时，可以构造一个形如 $1,\dfrac&#123;2&#125;&#123;1&#125;,\dfrac&#123;3&#125;&#123;2&#125;,\cdots,\dfrac&#123;n-1&#125;&#123;n-2&#125;,n$ 这样的数列先考虑什么时候有解：显然，当 $n$ 为合数时无解。因为对于一个合数来说，存在两个比它小的数 $p,q$ 使得 $p\times q \equiv 0 \pmod n$，如 $(3\times6)\%9=0$。那么，当 $p,q$ 均出现过后，数列的前缀积将一直为 $0$，故合数时无解。特殊地，我们可以发现 $4=2\times 2$，无满足条件的 $p,q$，因此存在合法解。我们考虑如何构造这个数列：和 task1 同样的思路，我们发现 $1$ 必定出现在数列的第一位，否则 $1$ 出现前后的两个前缀积必然相等；而 $n$ 必定出现在数列的最后一位，因为 $n$ 出现位置后的所有前缀积在模意义下都为 $0$。手玩几组样例以后发现，所有样例中均有一组合法解满足前缀积在模意义下为 $1,2,3,\cdots,n$，因此我们可以构造出上文所述的数列来满足这个条件。那么我们只需证明这 $n$ 个数互不相同即可。我们发现这些数均为 $1 \cdots n-2$ 的逆元 $+1$，因此各不相同，此题得解。</code></pre><h3 id="例题-3"><a href="#例题-3" class="headerlink" title="例题 3"></a>例题 3</h3><p>???+note “<a href="https://atcoder.jp/contests/agc032/tasks/agc032_b">AtCoder Grand Contest 032 B</a>“<br>    给定一个整数 $N$，试构造一个节点数为 $N$ 无向图。令节点编号为 $1\ldots N$，要求其满足以下条件：</p><pre><code>- 这是一个简单连通图。- 存在一个整数 $S$ 使得对于任意节点，与其相邻节点的下标和为 $S$。保证输入数据有解。</code></pre><p>??? note “解题思路”<br>    手玩一下 $n&#x3D;3,4,5$ 的情况，我们可以找到一个构造思路。</p><pre><code>构造一个完全 $k$ 分图，保证这 $k$ 部分和相等。则每个点的 $S$ 均相等，为 $\dfrac&#123;(k-1)\sum_&#123;i=1&#125;^&#123;n&#125;i&#125;&#123;k&#125;$。如果 $n$ 为偶数，那么我们可以前后两两配对，即 $\&#123;1,n\&#125;,\&#123;2,n-1\&#125;\cdots$如果 $n$ 为奇数，那么我们可以把 $n$ 单拿出来作为一组，剩余的 $n-1$ 个两两配对，即 $\&#123;n\&#125;,\&#123;1,n-1\&#125;,\&#123;2,n-2\&#125;\cdots$这样构造出的图在 $n\ge 3$ 时连通性易证，在此不加赘述。此题得解。</code></pre><h3 id="例题-4"><a href="#例题-4" class="headerlink" title="例题 4"></a>例题 4</h3><p>???+note “BZOJ 4971「Lydsy1708 月赛」记忆中的背包”<br>    经过一天辛苦的工作，小 Q 进入了梦乡。他脑海中浮现出了刚进大学时学 01 背包的情景，那时还是大一萌新的小 Q 解决了一道简单的 01 背包问题。这个问题是这样的：</p><pre><code>给定 $n$ 个物品，每个物品的体积分别为 $v_1,v_2,…,v_n$，请计算从中选择一些物品（也可以不选），使得总体积恰好为 $w$ 的方案数。因为答案可能非常大，你只需要输出答案对 $P$ 取模的结果。因为长期熬夜刷题，他只看到样例输入中的 $w$ 和 $P$，以及样例输出是 $k$，看不清到底有几个物品，也看不清每个物品的体积是多少。直到梦醒，小 Q 也没有看清 $n$ 和 $v$，请写一个程序，帮助小 Q 一起回忆曾经的样例输入。</code></pre><p>??? note “解题思路”<br>    这道题是自由度最高的构造题之一了。这就导致了没有头绪，难以入手的情况。</p><pre><code>首先，不难发现模数是假的。由于我们自由构造数据，我们一定可以让方案数不超过模数。通过奇怪的方式，我们想到可以通过构造 $n$ 个 代价为 $1$ 的小物品和几个代价大于 $\dfrac&#123;w&#125;&#123;2&#125;$ 的大物品。由于大物品只能取一件，所以每个代价为 $x$ 的大物品对方案数的贡献为 $C_&#123;n&#125;^&#123;w-x&#125;$。令 $f_&#123;i,j&#125;$ 表示有 $i$ 个 $1$，方案数为 $j$ 的最小大物品数。用 dp 预处理出 $f$，通过计算可知只需预处理 $i\le 20$ 的所有值即可。此题得解。</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/08/23/complexity/"/>
      <url>/2022/08/23/complexity/</url>
      
        <content type="html"><![CDATA[<p>author: linehk</p><p>时间复杂度和空间复杂度是衡量一个算法效率的重要标准。</p><h2 id="基本操作数"><a href="#基本操作数" class="headerlink" title="基本操作数"></a>基本操作数</h2><p>同一个算法在不同的计算机上运行的速度会有一定的差别，并且实际运行速度难以在理论上进行计算，实际去测量又比较麻烦，所以我们通常考虑的不是算法运行的实际用时，而是算法运行所需要进行的基本操作的数量。</p><p>在普通的计算机上，加减乘除、访问变量（基本数据类型的变量，下同）、给变量赋值等都可以看作基本操作。</p><p>对基本操作的计数或是估测可以作为评判算法用时的指标。</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>衡量一个算法的快慢，一定要考虑数据规模的大小。所谓数据规模，一般指输入的数字个数、输入中给出的图的点数与边数等等。一般来说，数据规模越大，算法的用时就越长。而在算法竞赛中，我们衡量一个算法的效率时，最重要的不是看它在某个数据规模下的用时，而是看它的用时随数据规模而增长的趋势，即 <strong>时间复杂度</strong>。</p><p>考虑用时随数据规模变化的趋势的主要原因有以下几点：</p><ol><li>现代计算机每秒可以处理数亿乃至更多次基本运算，因此我们处理的数据规模通常很大。如果算法 A 在规模为 $n$ 的数据上用时为 $100n$ 而算法 B 在规模为 $n$ 的数据上用时为 $n^2$，在数据规模小于 $100$ 时算法 B 用时更短，但在一秒钟内算法 A 可以处理数百万规模的数据，而算法 B 只能处理数万规模的数据。在允许算法执行时间更久时，时间复杂度对可处理数据规模的影响就会更加明显，远大于同一数据规模下用时的影响。</li><li>我们采用基本操作数来表示算法的用时，而不同的基本操作实际用时是不同的，例如加减法的用时远小于除法的用时。计算时间复杂度而忽略不同基本操作之间的区别以及一次基本操作与十次基本操作之间的区别，可以消除基本操作间用时不同的影响。</li></ol><p>当然，算法的运行用时并非完全由输入规模决定，而是也与输入的内容相关。所以，时间复杂度又分为几种，例如：</p><ol><li>最坏时间复杂度，即每个输入规模下用时最长的输入对应的时间复杂度。在算法竞赛中，由于输入可以在给定的数据范围内任意给定，我们为保证算法能够通过某个数据范围内的任何数据，一般考虑最坏时间复杂度。</li><li>平均（期望）时间复杂度，即每个输入规模下所有可能输入对应用时的平均值的复杂度（随机输入下期望用时的复杂度）。</li></ol><p>所谓“用时随数据规模而增长的趋势”是一个模糊的概念，我们需要借助下文所介绍的 <strong>渐进符号</strong> 来形式化地表示时间复杂度。</p><h2 id="渐进符号"><a href="#渐进符号" class="headerlink" title="渐进符号"></a>渐进符号</h2><p>简单来说，渐进符号忽略了一个函数中增长较慢的部分以及各项的系数（在时间复杂度相关分析中，系数一般被称作“常数”），而保留了可以用来表明该函数增长趋势的重要部分。</p><h3 id="大-Θ-符号"><a href="#大-Θ-符号" class="headerlink" title="大 Θ 符号"></a>大 Θ 符号</h3><p>对于函数 $f(n)$ 和 $g(n)$，$f(n)&#x3D;\Theta(g(n))$，当且仅当 $\exists c_1,c_2,n_0&gt;0$，使得 $\forall n \ge n_0, 0\le c_1\cdot g(n)\le f(n) \le c_2\cdot g(n)$。</p><p>也就是说，如果函数 $f(n)&#x3D;\Theta(g(n))$，那么我们能找到两个正数 $c_1, c_2$ 使得 $f(n)$ 被 $c_1\cdot g(n)$ 和 $c_2\cdot g(n)$ 夹在中间。</p><p>例如，$3n^2+5n-3&#x3D;\Theta(n^2)$,$n\sqrt n + n\log^5 n+m\log m+nm&#x3D;\Theta(n\sqrt n+m\log m+nm)$。</p><h3 id="大-O-符号"><a href="#大-O-符号" class="headerlink" title="大 O 符号"></a>大 O 符号</h3><p>$\Theta$ 符号同时给了我们一个函数的上下界，如果只知道一个函数的渐进上界而不知道其渐进下界，可以使用 $O$ 符号。$f(n)&#x3D;O(g(n))$，当且仅当 $\exists c,n_0$，使得 $\forall n \ge n_0,0\le f(n)\le c\cdot g(n)$。</p><p>研究时间复杂度时通常会使用 $O$ 符号，因为我们关注的通常是程序用时的上界，而不关心其用时的下界。</p><p>需要注意的是，这里的“上界”和“下界”是对于函数的变化趋势而言的，而不是对算法而言的。算法用时的上界对应的是“最坏时间复杂度”而非大 $O$ 记号。所以，使用 $\Theta$ 记号表示最坏时间复杂度是完全可行的，甚至可以说 $\Theta$ 比 $O$ 更加精确，而使用 $O$ 记号的主要原因，一是我们有时只能证明时间复杂度的上界而无法证明其下界（这种情况一般出现在较为复杂的算法以及复杂度分析），二是 $O$ 在电脑上输入更方便一些。</p><h3 id="大-Ω-符号"><a href="#大-Ω-符号" class="headerlink" title="大 Ω 符号"></a>大 Ω 符号</h3><p>同样的，我们使用 $\Omega$ 符号来描述一个函数的渐进下界。$f(n)&#x3D;\Omega(g(n))$，当且仅当 $\exists c,n_0$，使得 $\forall n \ge n_0,0\le c\cdot g(n)\le f(n)$。</p><h3 id="小-o-符号"><a href="#小-o-符号" class="headerlink" title="小 o 符号"></a>小 o 符号</h3><p>如果说 $O$ 符号相当于小于等于号，那么 $o$ 符号就相当于小于号。</p><p>$f(n)&#x3D;o(g(n))$，当且仅当对于任意给定的正数 $c$，$\exists n_0$，使得 $\forall n \ge n_0,0\le f(n)&lt; c\cdot g(n)$。</p><h3 id="小-ω-符号"><a href="#小-ω-符号" class="headerlink" title="小 ω 符号"></a>小 ω 符号</h3><p>如果说 $\Omega$ 符号相当于大于等于号，那么 $\omega$ 符号就相当于大于号。</p><p>$f(n)&#x3D;\omega(g(n))$，当且仅当对于任意给定的正数 $c$，$\exists n_0$，使得 $\forall n \ge n_0,0\le c\cdot g(n)&lt; f(n)$。</p><p><img src="/images/order.png"></p><h3 id="常见性质"><a href="#常见性质" class="headerlink" title="常见性质"></a>常见性质</h3><ul><li>$f(n) &#x3D; \Theta(g(n))\iff f(n)&#x3D;O(g(n))\land f(n)&#x3D;\Omega(g(n))$</li><li>$f_1(n) + f_2(n) &#x3D; O(\max(f_1(n), f_2(n)))$</li><li>$f_1(n) \times f_2(n) &#x3D; O(f_1(n) \times f_2(n))$</li><li>$\forall a \neq 1, \log_a{n} &#x3D; O(\log_2 n)$。由换底公式可以得知，任何对数函数无论底数为何，都具有相同的增长率，因此渐进时间复杂度中对数的底数一般省略不写。</li></ul><h2 id="简单的时间复杂度计算的例子"><a href="#简单的时间复杂度计算的例子" class="headerlink" title="简单的时间复杂度计算的例子"></a>简单的时间复杂度计算的例子</h2><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; m; ++k) &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;hello world\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python Version</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">m = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, m):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果以输入的数值 $n$ 和 $m$ 的大小作为数据规模，则上面这段代码的时间复杂度为 $\Theta(n^2m)$。</p><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>在对一张 $n$ 个点 $m$ 条边的图进行 <a href="../graph/dfs.md">DFS</a> 时，由于每个节点和每条边都只会被访问常数次，复杂度为 $\Theta(n+m)$。</p><h2 id="哪些量是常量？"><a href="#哪些量是常量？" class="headerlink" title="哪些量是常量？"></a>哪些量是常量？</h2><p>当我们要进行若干次操作时，如何判断这若干次操作是否影响时间复杂度呢？例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;hello world\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python Version</span></span><br><span class="line">N = <span class="number">100000</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, N):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果 $N$ 的大小不被看作输入规模，那么这段代码的时间复杂度就是 $O(1)$。</p><p>进行时间复杂度计算时，哪些变量被视作输入规模是很重要的，而所有和输入规模无关的量都被视作常量，计算复杂度时可当作 $1$ 来处理。</p><p>需要注意的是，在进行时间复杂度相关的理论性讨论时，“算法能够解决任何规模的问题”是一个基本假设（当然，在实际中，由于时间和存储空间有限，无法解决规模过大的问题）。因此，能在常量时间内解决数据规模有限的问题（例如，对于数据范围内的每个可能输入预先计算出答案）并不能使一个算法的时间复杂度变为 $O(1)$。</p><h2 id="主定理-Master-Theorem"><a href="#主定理-Master-Theorem" class="headerlink" title="主定理 (Master Theorem)"></a>主定理 (Master Theorem)</h2><p>我们可以使用 Master Theorem 来快速求得关于递归算法的复杂度。<br>假设我们有递推关系式</p><p>$$<br>T(n) &#x3D; a T\left(\frac{n}{b}\right)＋f(n)\qquad \forall n &gt; b<br>$$</p><p>那么</p><p>$$<br>T(n) &#x3D; \begin{cases}\Theta(n^{\log_b a}) &amp; f(n) &#x3D; O(n^{\log_b a-\epsilon}) \ \Theta(f(n)) &amp; f(n) &#x3D; \Omega(n^{\log_b a+\epsilon}) \ \Theta(n^{\log_b a}\log^{k+1} n) &amp; f(n)&#x3D;\Theta(n^{\log_b a}\log^k n),k\ge 0 \end{cases}<br>$$</p><h2 id="均摊复杂度"><a href="#均摊复杂度" class="headerlink" title="均摊复杂度"></a>均摊复杂度</h2><p>算法往往是会对内存中的数据进行修改的，而同一个算法的多次执行，就会通过对数据的修改而互相影响。</p><p>例如快速排序中的“按大小分类”操作，单次执行的最坏时间复杂度，看似是 $O(n)$ 的。<br>但是由于快排的分治过程，先前的“分类”操作每次都减小了数组长度，所以实际的总复杂度 $O(n \log n)$，分摊在每一次“分类”操作上，是 $O(\log n)$。</p><p>多次操作的总复杂度除以操作次数，就是这种操作的 <strong>均摊复杂度</strong>。</p><h2 id="势能分析"><a href="#势能分析" class="headerlink" title="势能分析"></a>势能分析</h2><p>势能分析，是一种求均摊复杂度上界的方法。<br>求均摊复杂度，关键是表达出先前操作对当前操作的影响。势能分析用一个函数来表达此种影响。</p><p>定义“状态”$S$：即某一时刻的所有数据。<em>在快排的例子中，一个“状态”就是当前过程需要排序的下标区间</em></p><p>定义“初始状态”$S_0$：即未进行任何操作时的状态。<em>在快排的例子中，“初始状态”就是整个数组</em></p><p>假设存在从状态到数的函数 $F$，且对于任何状态 $S$，$F(S) \geq F(S_0)$，则有以下推论：</p><p>设 $S_1,S_2, \cdots ,S_m$ 为从 $S_0$ 开始连续做 $m$ 次操作所得的状态序列，$c_i$ 为第 $i$ 次操作的时间开销。</p><p>记 $p_i &#x3D; c_i + F(S_i) - F(S_{i-1})$，则 $m$ 次操作的总时间花销为</p><p>$$<br>\sum_{i&#x3D;1}^m p_i + F(S_0) - F(S_m)<br>$$</p><p>（正负相消，证明显然）</p><p>又因为 $F(S) \geq F(S_0)$，所以有</p><p>$$<br>\sum_{i&#x3D;1}^m p_i \geq \sum_{i&#x3D;1}^m c_i<br>$$</p><p>因此，若 $p_i &#x3D; O(T(n))$，则 $O(T(n))$ 是均摊复杂度的一个上界。</p><p>势能分析使用中有很多技巧，案例在此不题。</p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>类似地，算法所使用的空间随输入规模变化的趋势可以用 <strong>空间复杂度</strong> 来衡量。</p><h2 id="计算复杂性"><a href="#计算复杂性" class="headerlink" title="计算复杂性"></a>计算复杂性</h2><p>本文内容主要是从算法分析的角度对复杂度进行了介绍，如果有兴趣的话可以在 <a href="../misc/cc-basic.md">计算复杂性</a> 进行更深入的了解。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/08/23/bucket-sort/"/>
      <url>/2022/08/23/bucket-sort/</url>
      
        <content type="html"><![CDATA[<p>本页面将简要介绍桶排序。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>桶排序（英文：Bucket sort）是排序算法的一种，适用于待排序数据值域较大但分布比较均匀的情况。</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>桶排序按下列步骤进行：</p><ol><li>设置一个定量的数组当作空桶；</li><li>遍历序列，并将元素一个个放到对应的桶中；</li><li>对每个不是空的桶进行排序；</li><li>从不是空的桶里把元素再放回原来的序列中。</li></ol><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>如果使用稳定的内层排序，并且将元素插入桶中时不改变元素间的相对顺序，那么桶排序就是一种稳定的排序算法。</p><p>由于每块元素不多，一般使用插入排序。此时桶排序是一种稳定的排序算法。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>桶排序的平均时间复杂度为 $O(n + n^2&#x2F;k + k)$（将值域平均分成 $n$ 块 + 排序 + 重新合并元素），当 $k\approx n$ 时为 $O(n)$。[^ref1]</p><p>桶排序的最坏时间复杂度为 $O(n^2)$。</p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, w, a[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; bucket[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertion_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; A.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="type">int</span> key = A[i];</span><br><span class="line">    <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; A[j] &gt; key) &#123;</span><br><span class="line">      A[j + <span class="number">1</span>] = A[j];</span><br><span class="line">      --j;</span><br><span class="line">    &#125;</span><br><span class="line">    A[j + <span class="number">1</span>] = key;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bucket_sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> bucket_size = w / n + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    bucket[i].<span class="built_in">clear</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    bucket[a[i] / bucket_size].<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="built_in">insertion_sort</span>(bucket[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; bucket[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">      a[++p] = bucket[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python Version</span></span><br><span class="line">N = <span class="number">100010</span></span><br><span class="line">w = n = <span class="number">0</span></span><br><span class="line">a = [<span class="number">0</span>] * N</span><br><span class="line">bucket = [[] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insertion_sort</span>(<span class="params">A</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(A)):</span><br><span class="line">        key = A[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> A[j] &gt; key:</span><br><span class="line">            A[j + <span class="number">1</span>] = A[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        A[j + <span class="number">1</span>] = key</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bucket_sort</span>():</span><br><span class="line">    bucket_size = <span class="built_in">int</span>(w / n + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n):</span><br><span class="line">        bucket[i].clear()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        bucket[<span class="built_in">int</span>(a[i] / bucket_size)].append(a[i])</span><br><span class="line">    p = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n):</span><br><span class="line">        insertion_sort(bucket[i])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(bucket[i])):</span><br><span class="line">            a[p] = bucket[i][j]</span><br><span class="line">            p += <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="参考资料与注释"><a href="#参考资料与注释" class="headerlink" title="参考资料与注释"></a>参考资料与注释</h2><p>[^ref1]: <a href="https://en.wikipedia.org/wiki/Bucket_sort#Average-case_analysis">（英文）Bucket sort - Wikipedia</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/08/23/bubble-sort/"/>
      <url>/2022/08/23/bubble-sort/</url>
      
        <content type="html"><![CDATA[<p>本页面将简要介绍冒泡排序。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>冒泡排序（英语：Bubble sort）是一种简单的排序算法。由于在算法的执行过程中，较小的元素像是气泡般慢慢「浮」到数列的顶端，故叫做冒泡排序。</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>它的工作原理是每次检查相邻两个元素，如果前面的元素与后面的元素满足给定的排序条件，就将相邻两个元素交换。当没有相邻的元素需要交换时，排序就完成了。</p><p>经过 $i$ 次扫描后，数列的末尾 $i$ 项必然是最大的 $i$ 项，因此冒泡排序最多需要扫描 $n-1$ 遍数组就能完成排序。</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>冒泡排序是一种稳定的排序算法。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>在序列完全有序时，冒泡排序只需遍历一遍数组，不用执行任何交换操作，时间复杂度为 $O(n)$。</p><p>在最坏情况下，冒泡排序要执行 $\frac{(n-1)n}{2}$ 次交换操作，时间复杂度为 $O(n^2)$。</p><p>冒泡排序的平均时间复杂度为 $O(n^2)$。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><p>$$<br>\begin{array}{ll}<br>1 &amp; \textbf{Input. } \text{An array } A \text{ consisting of }n\text{ elements.} \<br>2 &amp; \textbf{Output. } A\text{ will be sorted in nondecreasing order stably.} \<br>3 &amp; \textbf{Method. }  \<br>4 &amp; flag\gets True\<br>5 &amp; \textbf{while }flag\<br>6 &amp; \qquad flag\gets False\<br>7 &amp; \qquad\textbf{for }i\gets1\textbf{ to }n-1\<br>8 &amp; \qquad\qquad\textbf{if }A[i]&gt;A[i + 1]\<br>9 &amp; \qquad\qquad\qquad flag\gets True\<br>10 &amp; \qquad\qquad\qquad \text{Swap } A[i]\text{ and }A[i + 1]<br>\end{array}<br>$$</p><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="comment">// 假设数组的大小是n+1，冒泡排序从数组下标1开始</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[i] &gt; a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> t = a[i];</span><br><span class="line">        a[i] = a[i + <span class="number">1</span>];</span><br><span class="line">        a[i + <span class="number">1</span>] = t;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python Version</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">a, n</span>):</span><br><span class="line">    flag = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">while</span> flag:</span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> a[i] &gt; a[i + <span class="number">1</span>]:</span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">                a[i], a[i + <span class="number">1</span>] = a[i + <span class="number">1</span>], a[i]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/08/23/binary-lifting/"/>
      <url>/2022/08/23/binary-lifting/</url>
      
        <content type="html"><![CDATA[<p>author: Ir1d, ShadowsEpic, Fomalhauthmj, siger-young, MingqiHuang, Xeonacid, hsfzLZH1, orzAtalod, NachtgeistW</p><p>本页面将简要介绍倍增法。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>倍增法（英语：binary lifting），顾名思义就是翻倍。它能够使线性的处理转化为对数级的处理，大大地优化时间复杂度。</p><p>这个方法在很多算法中均有应用，其中最常用的是 RMQ 问题和求 <a href="../graph/lca.md">LCA（最近公共祖先）</a>。</p><h2 id="RMQ-问题"><a href="#RMQ-问题" class="headerlink" title="RMQ 问题"></a>RMQ 问题</h2><p>参见：<a href="../topic/rmq.md">RMQ 专题</a></p><p>RMQ 是 Range Maximum&#x2F;Minimum Query 的缩写，表示区间最大（最小）值。使用倍增思想解决 RMQ 问题的方法是 <a href="../ds/sparse-table.md">ST 表</a>。</p><h2 id="树上倍增求-LCA"><a href="#树上倍增求-LCA" class="headerlink" title="树上倍增求 LCA"></a>树上倍增求 LCA</h2><p>参见：<a href="../graph/lca.md">最近公共祖先</a></p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="题-1"><a href="#题-1" class="headerlink" title="题 1"></a>题 1</h3><p>???+note “例题”<br>    如何用尽可能少的砝码称量出 $[0,31]$ 之间的所有重量？（只能在天平的一端放砝码）</p><p>??? note “解题思路”<br>    答案是使用 1 2 4 8 16 这五个砝码，可以称量出 $[0,31]$ 之间的所有重量。同样，如果要称量 $[0,127]$ 之间的所有重量，可以使用 1 2 4 8 16 32 64 这七个砝码。每次我们都选择 2 的整次幂作砝码的重量，就可以使用极少的砝码个数量出任意我们所需要的重量。</p><pre><code>为什么说是极少呢？因为如果我们要量出 $[0,1023]$ 之间的所有重量，只需要 10 个砝码，需要量出 $[0,1048575]$ 之间的所有重量，只需要 20 个。如果我们的目标重量翻倍，砝码个数只需要增加 1。这叫“对数级”的增长速度，因为砝码的所需个数与目标重量的范围的对数成正比。</code></pre><h3 id="题-2"><a href="#题-2" class="headerlink" title="题 2"></a>题 2</h3><p>???+note “例题”<br>    给出一个长度为 $n$ 的环和一个常数 $k$，每次会从第 $i$ 个点跳到第 $(i+k)\bmod n+1$ 个点，总共跳了 $m$ 次。每个点都有一个权值，记为 $a_i$，求 $m$ 次跳跃的起点的权值之和对 $10^9+7$ 取模的结果。</p><pre><code>数据范围：$1\leq n\leq 10^6$，$1\leq m\leq 10^&#123;18&#125;$，$1\leq k\leq n$，$0\le a_i\le 10^9$。</code></pre><p>??? note “解题思路”<br>    这里显然不能暴力模拟跳 $m$ 次。因为 $m$ 最大可到 $10^{18}$ 级别，如果暴力模拟的话，时间承受不住。</p><pre><code>所以就需要进行一些预处理，提前整合一些信息，以便于在查询的时候更快得出结果。如果记录下来每一个可能的跳跃次数的结果的话，不论是时间还是空间都难以承受。那么应该如何预处理呢？看看第一道例题。有思路了吗？回到本题。我们要预处理一些信息，然后用预处理的信息尽量快的整合出答案。同时预处理的信息也不能太多。所以可以预处理出以 2 的整次幂为单位的信息，这样的话在预处理的时候只需要处理少量信息，在整合的时候也不需要大费周章。在这题上，就是我们预处理出从每个点开始跳 1、2、4、8 等等步之后的结果（所处点和点权和），然后如果要跳 13 步，只需要跳 1+4+8 步就好了。也就是说先在起始点跳 1 步，然后再在跳了之后的终点跳 4 步，再接着跳 8 步，同时统计一下预先处理好的点权和，就可以知道跳 13 步的点权和了。对于每一个点开始的 $2^i$ 步，记录一个 `go[i][x]` 表示第 $x$ 个点跳 $2^i$ 步之后的终点，而 `sum[i][x]` 表示第 $x$ 个点跳 $2^i$ 步之后能获得的点权和。预处理的时候，开两重循环，对于跳 $2^i$ 步的信息，我们可以看作是先跳了 $2^&#123;i-1&#125;$ 步，再跳 $2^&#123;i-1&#125;$ 步，因为显然有 $2^&#123;i-1&#125;+2^&#123;i-1&#125;=2^i$。即我们有 `sum[i][x] = sum[i-1][x]+sum[i-1][go[i-1][x]]`，且 `go[i][x] = go[i-1][go[i-1][x]]`。当然还有一些实现细节需要注意。为了保证统计的时候不重不漏，我们一般预处理出“左闭右开”的点权和。亦即，对于跳 1 步的情况，我们只记录该点的点权和；对于跳 2 步的情况，我们只记录该点及其下一个点的点权和。相当于总是不将终点的点权和计入 sum。这样在预处理的时候，只需要将两部分的点权和直接相加就可以了，不需要担心第一段的终点和第二段的起点会被重复计算。这题的 $m\leq 10^&#123;18&#125;$，虽然看似恐怖，但是实际上只需要预处理出 $65$ 以内的 $i$，就可以轻松解决，比起暴力枚举快了很多。用行话讲，这个做法的 [时间复杂度](./complexity.md) 是预处理 $\Theta(n\log m)$，查询每次 $\Theta(\log m)$。</code></pre><p>??? note “参考代码”<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">modadd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a + b &gt;= mod) <span class="keyword">return</span> a + b - mod;  <span class="comment">// 减法代替取模，加快运算</span></span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> vi[<span class="number">1000005</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> go[<span class="number">75</span>][<span class="number">1000005</span>];  <span class="comment">// 将数组稍微开大以避免越界，小的一维尽量定义在前面</span></span><br><span class="line"><span class="type">int</span> sum[<span class="number">75</span>][<span class="number">1000005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, k;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, vi + i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    go[<span class="number">0</span>][i] = (i + k) % n + <span class="number">1</span>;</span><br><span class="line">    sum[<span class="number">0</span>][i] = vi[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> logn = <span class="number">31</span> - __builtin_clz(n);  <span class="comment">// 一个快捷的取对数的方法</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= logn; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">      go[i][j] = go[i - <span class="number">1</span>][go[i - <span class="number">1</span>][j]];</span><br><span class="line">      sum[i][j] = <span class="built_in">modadd</span>(sum[i - <span class="number">1</span>][j], sum[i - <span class="number">1</span>][go[i - <span class="number">1</span>][j]]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> m;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;m);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> curx = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; m; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (m &amp; (<span class="number">1</span> &lt;&lt; i)) &#123;  <span class="comment">// 参见位运算的相关内容，意为 m 的第 i 位是否为 1</span></span><br><span class="line">      ans = <span class="built_in">modadd</span>(ans, sum[i][curx]);</span><br><span class="line">      curx = go[i][curx];</span><br><span class="line">      m ^= <span class="number">1ll</span> &lt;&lt; i;  <span class="comment">// 将第 i 位置零</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/08/23/binary/"/>
      <url>/2022/08/23/binary/</url>
      
        <content type="html"><![CDATA[<p>本页面将简要介绍二分查找，由二分法衍生的三分法以及二分答案。</p><h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>二分查找（英语：binary search），也称折半搜索（英语：half-interval search）、对数搜索（英语：logarithmic search），是用来在一个有序数组中查找某一元素的算法。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>以在一个升序数组中查找一个数为例。</p><p>它每次考察数组当前部分的中间元素，如果中间元素刚好是要找的，就结束搜索过程；如果中间元素小于所查找的值，那么左侧的只会更小，不会有所查找的元素，只需到右侧查找；如果中间元素大于所查找的值同理，只需到左侧查找。</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>二分查找的最优时间复杂度为 $O(1)$。</p><p>二分查找的平均时间复杂度和最坏时间复杂度均为 $O(\log n)$。因为在二分搜索过程中，算法每次都把查询的区间减半，所以对于一个长度为 $n$ 的数组，至多会进行 $O(\log n)$ 次查找。</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>迭代版本的二分查找的空间复杂度为 $O(1)$。</p><p>递归（无尾调用消除）版本的二分查找的空间复杂度为 $O(\log n)$。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binary_search</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> ret = <span class="number">-1</span>;  <span class="comment">// 未搜索到数据返回-1下标</span></span><br><span class="line">  <span class="type">int</span> mid;</span><br><span class="line">  <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">    mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);  <span class="comment">// 直接平均可能会溢出，所以用这个算法</span></span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &lt; key)</span><br><span class="line">      start = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; key)</span><br><span class="line">      end = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">// 最后检测相等是因为多数搜索情况不是大于就是小于</span></span><br><span class="line">      ret = mid;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;  <span class="comment">// 单一出口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>???+note<br>    对于 $n$ 是有符号数的情况，当你可以保证 $n\ge 0$ 时，<code>n &gt;&gt; 1</code> 比 <code>n / 2</code> 指令数更少。</p><h3 id="最大值最小化"><a href="#最大值最小化" class="headerlink" title="最大值最小化"></a>最大值最小化</h3><p>注意，这里的有序是广义的有序，如果一个数组中的左侧或者右侧都满足某一种条件，而另一侧都不满足这种条件，也可以看作是一种有序（如果把满足条件看做 $1$，不满足看做 $0$，至少对于这个条件的这一维度是有序的）。换言之，二分搜索法可以用来查找满足某种条件的最大（最小）的值。</p><p>要求满足某种条件的最大值的最小可能情况（最大值最小化），首先的想法是从小到大枚举这个作为答案的「最大值」，然后去判断是否合法。若答案单调，就可以使用二分搜索法来更快地找到答案。因此，要想使用二分搜索法来解这种「最大值最小化」的题目，需要满足以下三个条件：</p><ol><li>答案在一个固定区间内；</li><li>可能查找一个符合条件的值不是很容易，但是要求能比较容易地判断某个值是否是符合条件的；</li><li>可行解对于区间满足一定的单调性。换言之，如果 $x$ 是符合条件的，那么有 $x + 1$ 或者 $x - 1$ 也符合条件。（这样下来就满足了上面提到的单调性）</li></ol><p>当然，最小值最大化是同理的。</p><h3 id="STL-的二分查找"><a href="#STL-的二分查找" class="headerlink" title="STL 的二分查找"></a>STL 的二分查找</h3><p>C++ 标准库中实现了查找首个不小于给定值的元素的函数 <a href="https://zh.cppreference.com/w/cpp/algorithm/lower_bound"><code>std::lower_bound</code></a> 和查找首个大于给定值的元素的函数 <a href="https://zh.cppreference.com/w/cpp/algorithm/upper_bound"><code>std::upper_bound</code></a>，二者均定义于头文件 <code>&lt;algorithm&gt;</code> 中。</p><p>二者均采用二分实现，所以调用前必须保证元素有序。</p><h3 id="bsearch"><a href="#bsearch" class="headerlink" title="bsearch"></a>bsearch</h3><p>bsearch 函数为 C 标准库实现的二分查找，定义在 <code>&lt;stdlib.h&gt;</code> 中。在 C++ 标准库里，该函数定义在 <code>&lt;cstdlib&gt;</code> 中。qsort 和 bsearch 是 C 语言中唯二的两个算法类函数。</p><p>bsearch 函数相比 qsort（<a href="./stl-sort.md">排序相关 STL</a>）的四个参数，在最左边增加了参数“待查元素的地址”。之所以按照地址的形式传入，是为了方便直接套用与 qsort 相同的比较函数，从而实现排序后的立即查找。因此这个参数不能直接传入具体值，而是要先将待查值用一个变量存储，再传入该变量地址。</p><p>于是 bsearch 函数总共有五个参数：待查元素的地址、数组名、元素个数、元素大小、比较规则。比较规则仍然通过指定比较函数实现，详见 <a href="./stl-sort.md">排序相关 STL</a>。</p><p>bsearch 函数的返回值是查找到的元素的地址，该地址为 void 类型。</p><p>注意：bsearch 与上文的 lower_bound 和 upper_bound 有两点不同：</p><ul><li>当符合条件的元素有重复多个的时候，会返回执行二分查找时第一个符合条件的元素，从而这个元素可能位于重复多个元素的中间部分。</li><li>当查找不到相应的元素时，会返回 NULL。</li></ul><p>用 lower_bound 可以实现与 bsearch 完全相同的功能，所以可以使用 bsearch 通过的题目，直接改写成 lower_bound 同样可以实现。但是鉴于上述不同之处的第二点，例如，在序列 1、2、4、5、6 中查找 3，bsearch 实现 lower_bound 的功能会变得困难。</p><p>利用 bsearch 实现 lower_bound 的功能比较困难，是否一定就不能实现？答案是否定的，存在比较 tricky 的技巧。借助编译器处理比较函数的特性：总是将第一个参数指向待查元素，将第二个参数指向待查数组中的元素，也可以用 bsearch 实现 lower_bound 和 upper_bound，如下文示例。只是，这要求待查数组必须是全局数组，从而可以直接传入首地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> A[<span class="number">100005</span>];  <span class="comment">// 示例全局数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找首个不小于待查元素的元素的地址</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lower</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *p1, <span class="type">const</span> <span class="type">void</span> *p2)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> *a = (<span class="type">int</span> *)p1;</span><br><span class="line">  <span class="type">int</span> *b = (<span class="type">int</span> *)p2;</span><br><span class="line">  <span class="keyword">if</span> ((b == A || <span class="built_in">compare</span>(a, b - <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; <span class="built_in">compare</span>(a, b) &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (b != A &amp;&amp; <span class="built_in">compare</span>(a, b - <span class="number">1</span>) &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 用到地址的减法，因此必须指定元素类型</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找首个大于待查元素的元素的地址</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">upper</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *p1, <span class="type">const</span> <span class="type">void</span> *p2)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> *a = (<span class="type">int</span> *)p1;</span><br><span class="line">  <span class="type">int</span> *b = (<span class="type">int</span> *)p2;</span><br><span class="line">  <span class="keyword">if</span> ((b == A || <span class="built_in">compare</span>(a, b - <span class="number">1</span>) &gt;= <span class="number">0</span>) &amp;&amp; <span class="built_in">compare</span>(a, b) &gt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (b != A &amp;&amp; <span class="built_in">compare</span>(a, b - <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 用到地址的减法，因此必须指定元素类型</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为现在的 OI 选手很少写纯 C，并且此方法作用有限，所以不是重点。对于新手而言，建议老老实实地使用 C++ 中的 lower_bound 和 upper_bound 函数。</p><h3 id="二分答案"><a href="#二分答案" class="headerlink" title="二分答案"></a>二分答案</h3><p>解题的时候往往会考虑枚举答案然后检验枚举的值是否正确。若满足单调性，则满足使用二分法的条件。把这里的枚举换成二分，就变成了“二分答案”。</p><p>???+note “<a href="https://www.luogu.com.cn/problem/P1873">Luogu P1873 砍树</a>“<br>    伐木工人米尔科需要砍倒 $M$ 米长的木材。这是一个对米尔科来说很容易的工作，因为他有一个漂亮的新伐木机，可以像野火一样砍倒森林。不过，米尔科只被允许砍倒单行树木。</p><pre><code>米尔科的伐木机工作过程如下：米尔科设置一个高度参数 $H$（米），伐木机升起一个巨大的锯片到高度 $H$，并锯掉所有的树比 $H$ 高的部分（当然，树木不高于 $H$ 米的部分保持不变）。米尔科就得到树木被锯下的部分。例如，如果一行树的高度分别为 $20,~15,~10,~17$，米尔科把锯片升到 $15$ 米的高度，切割后树木剩下的高度将是 $15,~15,~10,~15$，而米尔科将从第 $1$ 棵树得到 $5$ 米木材，从第 $4$ 棵树得到 $2$ 米木材，共 $7$ 米木材。米尔科非常关注生态保护，所以他不会砍掉过多的木材。这正是他尽可能高地设定伐木机锯片的原因。你的任务是帮助米尔科找到伐木机锯片的最大的整数高度 $H$，使得他能得到木材至少为 $M$ 米。即，如果再升高 $1$ 米锯片，则他将得不到 $M$ 米木材。</code></pre><p>??? note “解题思路”<br>    我们可以在 $1$ 到 $10^9$ 中枚举答案，但是这种朴素写法肯定拿不到满分，因为从 $1$ 枚举到 $10^9$ 太耗时间。我们可以在 $[1,~10^9]$ 的区间上进行二分作为答案，然后检查各个答案的可行性（一般使用贪心法）。<strong>这就是二分答案。</strong></p><p>??? note “参考代码”<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">1000005</span>];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;  <span class="comment">// 检查可行性，k 为锯片高度</span></span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)       <span class="comment">// 检查每一棵树</span></span><br><span class="line">    <span class="keyword">if</span> (a[i] &gt; k)                    <span class="comment">// 如果树高于锯片高度</span></span><br><span class="line">      sum += (<span class="type">long</span> <span class="type">long</span>)(a[i] - k);  <span class="comment">// 累加树木长度</span></span><br><span class="line">  <span class="keyword">return</span> sum &gt;= m;                   <span class="comment">// 如果满足最少长度代表可行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">1e9</span> + <span class="number">1</span>;   <span class="comment">// 因为是左闭右开的，所以 10^9 要加 1</span></span><br><span class="line">  <span class="keyword">while</span> (l + <span class="number">1</span> &lt; r) &#123;       <span class="comment">// 如果两点不相邻</span></span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;  <span class="comment">// 取中间值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(mid))         <span class="comment">// 如果可行</span></span><br><span class="line">      l = mid;              <span class="comment">// 升高锯片高度</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      r = mid;  <span class="comment">// 否则降低锯片高度</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> l;  <span class="comment">// 返回左边值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class="line">  cout &lt;&lt; <span class="built_in">find</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><pre><code>看完了上面的代码，你肯定会有两个疑问：1.  为何搜索区间是左闭右开的？    因为搜到最后，会这样（以合法的最大值为例）：    ![](./images/binary-final-1.png)    然后会    ![](./images/binary-final-2.png)    合法的最小值恰恰相反。2.  为何返回左边值？    同上。</code></pre><h2 id="三分法"><a href="#三分法" class="headerlink" title="三分法"></a>三分法</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>三分法可以用来查找凸函数的最大（小）值。</p><p>画一下图能够帮助理解（图待补）</p><ul><li>如果 <code>lmid</code> 和 <code>rmid</code> 在最大（小）值的同一侧：由于单调性，一定是二者中较大（小）的那个离最值近一些，较远的那个点对应的区间不可能包含最值，所以可以舍弃。</li><li>如果在两侧：由于最值在二者中间，我们舍弃两侧的一个区间后，也不会影响最值，所以可以舍弃。</li></ul><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lmid = left + (right - left &gt;&gt; <span class="number">1</span>);</span><br><span class="line">rmid = lmid + (right - lmid &gt;&gt; <span class="number">1</span>);  <span class="comment">// 对右侧区间取半</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">cal</span>(lmid) &gt; <span class="built_in">cal</span>(rmid))</span><br><span class="line">  right = rmid;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  left = lmid;</span><br></pre></td></tr></table></figure><h2 id="分数规划"><a href="#分数规划" class="headerlink" title="分数规划"></a>分数规划</h2><p>参见：<a href="../misc/frac-programming.md">分数规划</a></p><p>分数规划通常描述为下列问题：每个物品有两个属性 $c_i$，$d_i$，要求通过某种方式选出若干个，使得 $\frac{\sum{c_i}}{\sum{d_i}}$ 最大或最小。</p><p>经典的例子有最优比率环、最优比率生成树等等。</p><p>分数规划可以用二分法来解决。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【教程】Windows下安装WSL 2</title>
      <link href="/2022/08/19/%E3%80%90%E6%95%99%E7%A8%8B%E3%80%91Windows%E4%B8%8B%E5%AE%89%E8%A3%85WSL%202/"/>
      <url>/2022/08/19/%E3%80%90%E6%95%99%E7%A8%8B%E3%80%91Windows%E4%B8%8B%E5%AE%89%E8%A3%85WSL%202/</url>
      
        <content type="html"><![CDATA[<h2 id="系统版本要求"><a href="#系统版本要求" class="headerlink" title="系统版本要求"></a>系统版本要求</h2><p>必须运行 Windows 10 版本 2004 及更高版本（内部版本 19041 及更高版本）或 Windows 11</p><blockquote><p>按住<strong>Windows徽标键+R</strong>，键入<strong>winver</strong>来查看电脑版本</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>通过在<strong>管理员模式下</strong>PowerShell 或 Windows 命令提示符中输入以下命令，然后重新启动计算机来安装运行WSL</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">--install</span></span><br></pre></td></tr></table></figure><p>此命令将启用所需的可选组件，下载最新的Linux内核，<strong>将WSL 2设置为默认值</strong>，并为您安装Linux发行版（默认情况下为<strong>Ubuntu</strong>）。</p><p>首次启动新安装的 Linux 发行版时，将打开一个控制台窗口，系统将要求您等待文件解压缩并存储在您的计算机上。</p><h2 id="更改发行版"><a href="#更改发行版" class="headerlink" title="更改发行版"></a>更改发行版</h2><p>通过在<strong>管理员模式下</strong>PowerShell 或 Windows 命令提示符中输入以下命令查看可安装的有效分发</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">-l</span> <span class="literal">-o</span></span><br><span class="line">wsl <span class="literal">--list</span> <span class="literal">--online</span></span><br></pre></td></tr></table></figure><p>通过在<strong>管理员模式下</strong>PowerShell 或 Windows 命令提示符中输入以下命令安装新分发</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">--install</span> <span class="literal">-d</span> &lt;Distribution Name&gt;</span><br></pre></td></tr></table></figure><p>通过在<strong>管理员模式下</strong>PowerShell 或 Windows 命令提示符中输入以下命令用新分发替换旧分发</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">--install</span> <span class="literal">-d</span> &lt;Distribution Name&gt; &lt;Distribution Name&gt;</span><br></pre></td></tr></table></figure><h2 id="查看已安装发行版"><a href="#查看已安装发行版" class="headerlink" title="查看已安装发行版"></a>查看已安装发行版</h2><p>通过在<strong>管理员模式下</strong>PowerShell 或 Windows 命令提示符中输入以下命令查看已安装分发的状态和版本</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">-l</span> <span class="literal">-v</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【笔记】算法设计与分析笔记</title>
      <link href="/2022/08/19/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/08/19/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="一、算法基础"><a href="#一、算法基础" class="headerlink" title="一、算法基础"></a>一、算法基础</h2><h3 id="1-循环不变量的证明"><a href="#1-循环不变量的证明" class="headerlink" title="1.循环不变量的证明"></a>1.循环不变量的证明</h3><ul><li>初始化：证明循环不变量在循环开始前为真；</li><li>保持：证明每次循环之后循环不变式仍为真；</li><li>终止：循环可以有限次终止。</li></ul><h3 id="2-时间复杂度的分析"><a href="#2-时间复杂度的分析" class="headerlink" title="2.时间复杂度的分析"></a>2.时间复杂度的分析</h3><ul><li><p>整个算法的执行时间是执行所有语句的时间之和；</p></li><li><p>算法的执行时间可能依赖于给定的输入，即使规模相同；</p></li><li><p>分析执行时间时可以分析算法的最坏执行情况、最好执行情况、平均执行情况。</p></li></ul><h3 id="3-算法的五个特性"><a href="#3-算法的五个特性" class="headerlink" title="3.算法的五个特性"></a>3.算法的五个特性</h3><ul><li><p>确定性</p></li><li><p>能行性</p></li><li><p>输入</p></li><li><p>输出</p></li><li><p>有穷性</p><div class="note info flat"><p>仅仅不满足有穷性规则的算法称为计算过程，如操作系统</p></div></li></ul><h2 id="二、算法渐近"><a href="#二、算法渐近" class="headerlink" title="二、算法渐近"></a>二、算法渐近</h2><h3 id="1-限界函数"><a href="#1-限界函数" class="headerlink" title="1.限界函数"></a>1.限界函数</h3><h4 id="1-上界函数"><a href="#1-上界函数" class="headerlink" title="(1)上界函数"></a>(1)上界函数</h4><p>上界函数描述了<strong>算法最坏情况下的时间复杂度</strong>，记为$f(n)\inΟ(g(n))$或$f(n)&#x3D;Ο(g(n))$</p><img src="Chp2-上界函数.png" style="zoom: 45%;" /><h4 id="2-下界函数"><a href="#2-下界函数" class="headerlink" title="(2)下界函数"></a>(2)下界函数</h4><p>下界函数描述了<strong>渐进下界</strong>，记为$f(n)\in\Omega(g(n))$或$f(n)&#x3D;\Omega(g(n))$</p><img src="Chp2-下界函数.png" style="zoom: 50%;" /><h4 id="3-渐近紧确界函数"><a href="#3-渐近紧确界函数" class="headerlink" title="(3)渐近紧确界函数"></a>(3)渐近紧确界函数</h4><p>渐近紧确界函数代表<strong>算法在最好和最坏情况下的计算时间就一个常数因子范围内而相同</strong>，<strong>既有$ f(n) &#x3D; \Omega(g(n))$，又有$f(n) &#x3D; Ο(g(n))$</strong></p><img src="Chp2-渐近紧确界.png" style="zoom: 58%;" /><h4 id="4-记号说明"><a href="#4-记号说明" class="headerlink" title="(4)记号说明"></a>(4)记号说明</h4><ul><li>这里的”$&#x3D;$”不是通常相等的含义，<strong>代表属于</strong></li><li>$\Theta(1)$表示具有<strong>常量计算时间</strong>的复杂度，即算法的执行时间为一个固定量，与问题的规模$n$无关</li></ul><h4 id="5-非渐近紧确的上下界"><a href="#5-非渐近紧确的上下界" class="headerlink" title="(5)非渐近紧确的上下界"></a>(5)非渐近紧确的上下界</h4><ul><li><strong>$o$记号</strong></li></ul><p>对任意正常数$c$，存在常数$n_0＞0$，使对所有的$n\geq n_0$，有$\lvert f(n)\rvert\leq c\lvert g(n)\rvert$，则记作：$f(n)&#x3D;o(g(n))$</p><ul><li><strong>$\omega$记号</strong></li></ul><p>对任意正常数$c$，存在常数$n_0＞0$，使对所有的$n\geq n_0$，有$\lvert f(n)\rvert\geq c\lvert g(n)\rvert$，则记作：$f(n)&#x3D;\omega(g(n))$</p><h3 id="2-估算复杂性定理"><a href="#2-估算复杂性定理" class="headerlink" title="2.估算复杂性定理"></a>2.估算复杂性定理</h3><ul><li>多项式定理：关于$n$的$m$次多项式与最高阶$n^m$同阶</li><li>$n^x(\log n)^y&lt;n^{x+\varepsilon}$</li><li>$(\log n)^x&lt;n$</li><li>$n^x&lt;2^n$</li></ul><h3 id="3-上界函数定理"><a href="#3-上界函数定理" class="headerlink" title="3.上界函数定理"></a>3.上界函数定理</h3><ul><li>正线性性：$d(n)&#x3D;O(f(n))$，则$ad(n)&#x3D;O(f(n))$，其中$a&gt;0$</li><li>加法律：$d(n)&#x3D;O(f(n))$，$e(n)&#x3D;O(g(n))$，则$d(n)+e(n)&#x3D;O(f(n)+g(n))$</li><li>乘法律：$d(n)&#x3D;O(f(n))$，$e(n)&#x3D;O(g(n))$，则$d(n)e(n)&#x3D;O(f(n)g(n))$</li><li>指数性质：$n^x&#x3D;O(a^n)$，其中$x&gt;0$，$a&gt;1$</li><li>对数性质1：$\log n^x&#x3D;O(\log n)$，其中$x&gt;0$</li><li>对数性质2：$(\log n)^x&#x3D;O(n^y)$，其中$x&gt;0$，$y&gt;0$</li></ul><h2 id="三、分治思想"><a href="#三、分治思想" class="headerlink" title="三、分治思想"></a>三、分治思想</h2><h3 id="1-分治原理"><a href="#1-分治原理" class="headerlink" title="1.分治原理"></a>1.分治原理</h3><p><strong>分治原理的基本思想：当问题规模比较大而无法直接求解时，将原始问题分解为几个规模较小、但类似于原始问题的子问题，然后递归地求解这些子问题，最后合并子问题的解以得到原始问题的解。</strong></p><ul><li><strong>基本策略：分解原问题，解决子问题，合并问题解</strong>。</li><li><strong>问题形式：跨越子数组的问题类型、合并子问题解的问题类型。</strong></li><li>计算复杂度：<a href="#2.%E9%80%92%E5%BD%92%E5%BC%8F%E6%B1%82%E8%A7%A3">递归式求解</a></li><li>实例：<a href="#3.%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">归并排序</a>——$T(n)&#x3D;2T(n&#x2F;2)+cn$</li><li>实例：<a href="#4.%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98">最大子数组问题</a>——$T(n)&#x3D;2T(n&#x2F;2)+\Theta(n)$</li><li>实例：<a href="#6.%E6%9C%80%E8%BF%91%E7%82%B9%E5%AF%B9%E9%97%AE%E9%A2%98">最近点对问题</a>——$T(n)&#x3D;2T(n&#x2F;2)+O(n)$</li><li>实例：<a href="#7.%E9%80%86%E5%BA%8F%E5%AF%B9%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98">逆序对计数问题</a>——$T(n)&#x3D;2T(n&#x2F;2)+O(n)$</li><li>实例：<a href="#8.%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">随机化快速排序的期望</a>——$T(n)&#x3D;O(n\log n)$</li></ul><h3 id="2-递归式求解"><a href="#2-递归式求解" class="headerlink" title="2.递归式求解"></a>2.递归式求解</h3><h4 id="1-基本形式"><a href="#1-基本形式" class="headerlink" title="(1)基本形式"></a>(1)基本形式</h4><ul><li><p>求解递归式的目的是<strong>将递归式转换为渐近限界函数表示‌</strong>；</p></li><li><p>一般关系为$T(n) &#x3D;T(n_1)+T(n_2)+f(n)$，其中$f(n)$表示<strong>除递归以外的代价</strong>。</p></li></ul><h4 id="2-预处理"><a href="#2-预处理" class="headerlink" title="(2)预处理"></a>(2)预处理</h4><ul><li><p><strong>减去一个低阶项</strong>以便于代换法中的归纳证明，如$cn-d$</p><blockquote><p>减去低阶项往往能够使数学证明顺利进行：</p><img src="Chp3-减去低阶项.png" style="zoom:67%;" /></blockquote></li><li><p>对<strong>取整符号</strong>进行简化</p><blockquote><p>如$T(n)&#x3D;T(\lfloor n&#x2F;2\rfloor)+T(\lceil n&#x2F;2\rceil)+f(n)$，往往忽略上下取整函数，写作以下简单形式：$T(n)&#x3D;2T(n&#x2F;2)+f(n)$</p></blockquote></li><li><p>对<strong>对数或指数</strong>做代数转换</p><blockquote><p>改变变量来简化递归式：</p><img src="Chp3-对指数变量代换.png" style="zoom:67%;" /></blockquote></li><li><p>对<strong>限界函数项</strong>进行展开，便于化简</p><blockquote><p>对于$T(n)&#x3D;3T(\lfloor n&#x2F;4\rfloor)+\Theta(n^2)$，简化为$T(n)&#x3D;3T(n&#x2F;4)+cn^2$。</p></blockquote></li></ul><h4 id="3-求解方法"><a href="#3-求解方法" class="headerlink" title="(3)求解方法"></a>(3)求解方法</h4><h5 id="①代入法"><a href="#①代入法" class="headerlink" title="①代入法"></a>①代入法</h5><ul><li><p>利用熟悉或类似的递归式<strong>猜测解的形式</strong></p></li><li><p>用<strong>数学归纳法</strong>证明猜测的正确性，得出合适的$c$值以满足条件</p></li><li><p>讨论<strong>边界条件的正确性</strong></p><blockquote><p>代入法实例如下：</p><img src="Chp3-代入法实例.png" style="zoom:60%;" /></blockquote></li></ul><h5 id="②递归树"><a href="#②递归树" class="headerlink" title="②递归树"></a>②递归树</h5><ul><li><p>在内部节点中表达除递归以外的代价</p><blockquote><p>对于$T(n)&#x3D;aT(n&#x2F;b)+f(n)$，一般假设$n&#x3D;b^k$，$k&#x3D;\log_bn$简化计算</p></blockquote></li><li><p>列出递归树直至叶子节点，得到递归树高度</p><blockquote><p>递归至叶子节点后，递归树的层数一般为$\log_bn+1$</p><p>举例如下：</p><img src="Chp3-递归树-1.png" style="zoom:67%;" /></blockquote></li><li><p>计算内部某层节点的总代价、叶子节点总代价、树的总代价</p><blockquote><p>通过计算前几层节点的总代价，得到内部某层节点的总代价的<strong>通式</strong>；</p><p>计算叶子节点的数目，假设为$num$，则叶子节点的总代价为$\Theta(num)$；</p><p>根据等比数列求和公式得到总代价。</p><p>计算如下：</p><img src="Chp3-递归树-2.png" style="zoom:67%;" /></blockquote></li><li><p>根据树的总代价猜测渐近限界函数</p><blockquote><p>猜测如下：</p><img src="Chp3-递归树-3.png" style="zoom:67%;" /></blockquote></li><li><p><strong>利用代换法证明</strong>猜测</p><blockquote><p>证明如下：</p><img src="Chp3-递归树-4.png" style="zoom:67%;" /></blockquote></li></ul><h5 id="③主方法"><a href="#③主方法" class="headerlink" title="③主方法"></a>③主方法</h5><p>设$a≥1$，$b&gt;1$，设$f(n)$为渐近正的函数，$T(n)$是定义在非负整数上的递归式：$T(n)&#x3D;aT(n&#x2F;b)+f(n)$，其中$n&#x2F;b$指$\lfloor n&#x2F;b \rfloor$或$\lceil n&#x2F;b \rceil$，则可使用以下定理求解递归式：</p><ul><li><p>若对于某常数$\varepsilon&gt;0$，有$f(n)&#x3D;O(n^{\log_ba-\varepsilon})$，则$T(n)&#x3D;\Theta(n^{\log_ba})$</p><blockquote><p>该情况中$n^{\log_ba}$比较大，$f(n)$需<strong>多项式地小于</strong>$n^{\log_ba}$，即对某个常量$\varepsilon&gt;0$，$f(n)$必须渐近地小于$n^{\log_ba}$，两者相差了一个$n^\varepsilon$因子，如$T(n)&#x3D;2T(n&#x2F;2)+n\log n$和$T(n)&#x3D;4T(n&#x2F;2)+n^2\log n$不满足条件</p></blockquote></li><li><p>若$f(n)&#x3D;\Theta(n^{\log_ba})$，则$T(n)&#x3D;\Theta(n^{\log_ba}\log n)$</p><blockquote><p>该情况中两个函数一样大，乘以对数因子$\log n$</p></blockquote></li><li><p>若对于某常数$\varepsilon&gt;0$，有$f(n)&#x3D;\Omega(n^{\log_ba+\varepsilon})$，且对常数**$c&lt;1$**与足够大的$n$，有$af(n&#x2F;b)\leq cf(n)$，则$T(n)&#x3D;\Theta(f(n))$</p><blockquote><p>该情况中$f(n)$比较大，$f(n)$需<strong>多项式地大于</strong>$n^{\log_ba}$，并需要满足一个规则性条件$af(n&#x2F;b)\leq cf(n)$，注意其中$c&lt; 1$</p></blockquote></li></ul><h3 id="3-归并排序"><a href="#3-归并排序" class="headerlink" title="3.归并排序"></a>3.归并排序</h3><h4 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="(1)问题描述"></a>(1)问题描述</h4><p>已知包含$n$个数字的序列$A[1,\dots,n]$，对其进行升序排序。</p><h4 id="2-问题分析"><a href="#2-问题分析" class="headerlink" title="(2)问题分析"></a>(2)问题分析</h4><ul><li>将数组$A$排序问题分解为$A[1,\dots,\lfloor\frac{n}{2}\rfloor]$和$A[\lfloor\frac{n}{2}\rfloor+1,\dots,n]$排序问题；</li><li>递归解决子问题得到两个有序的子数组；</li><li>然后再将两个子数组合并，合并的代价即为<strong>除递归以外的代价</strong>；</li><li>当数组被分解为长度为1时天然有序，从而产生局部有序性，进而进行两两合并操作。</li></ul><h4 id="3-分治策略"><a href="#3-分治策略" class="headerlink" title="(3)分治策略"></a>(3)分治策略</h4><ul><li><p>算法伪代码：</p><blockquote><p>$MERGE-SORT(A,left,right)$</p><img src="Chp3-MERGE-SORT.png" style="zoom:67%;" /><p>$MERGE(A,left,mid,right)$</p><img src="Chp3-MERGE.png" style="zoom:67%;" /></blockquote></li><li><p>时间复杂度</p><ul><li>递归式为$T(n)&#x3D;2T(n&#x2F;2)+O(n)$，其中$O(n)$为$MERGE$操作的时间代价；</li><li>时间复杂度为$O(n\log n)$。</li></ul></li></ul><h3 id="4-最大子数组问题"><a href="#4-最大子数组问题" class="headerlink" title="4.最大子数组问题"></a>4.最大子数组问题</h3><h4 id="1-问题描述-1"><a href="#1-问题描述-1" class="headerlink" title="(1)问题描述"></a>(1)问题描述</h4><ul><li>寻找和最大的非空连续子数组</li><li>给定一个数组$X[1..n]$，对于任意一对数组下标为$l,r(l\leq r)$的非空子数组，其和记为$S(l,r)&#x3D;\sum\limits_{i&#x3D;l}^{r}X[i]$，求$S(l,r)$的最大值，记为$S_{max}$。</li></ul><h4 id="2-暴力求解"><a href="#2-暴力求解" class="headerlink" title="(2)暴力求解"></a>(2)暴力求解</h4><ul><li>枚举$n+C_n^2$种下标$l,r$组合，求出最大子数组之和；</li><li>处理每对下标组合最少的时间代价为常量；</li><li>时间复杂度为$\Omega(n^2)$。</li></ul><h4 id="3-分治策略-1"><a href="#3-分治策略-1" class="headerlink" title="(3)分治策略"></a>(3)分治策略</h4><ul><li><p>将子数组$A[low…high]$划分为两个规模尽量相等的子子数组；</p></li><li><p>分别求解$A[low…mid]$和$A[mid+1…high]$的最大子数组；</p></li><li><p>基于上述划分，存在三种连续子数组情况：$mid$左侧、跨越$mid$、$mid$右侧；</p></li><li><p>对于跨越$mid$的情况，从$mid$出发，分别向左和向右找出最大子区间并合并，这个步骤的代价即为<strong>除递归以外的代价</strong>，其时间复杂度为$\Theta(n^2)$；</p><blockquote><p> 算法$FIND-MAX-CROSSING-SUBARRAY$如下：</p><img src="img\Chp3-FIND-MAX-CROSSING-SUBARRAY.png" style="zoom: 50%;" /></blockquote></li><li><p>对于其他两种情况，递归调用<strong>FIND-MAXIMUM-SUBARRAY</strong>即可；</p></li><li><p>求最大子数组问题的分治算法</p><blockquote><p><strong>FIND-MAXIMUM-SUBARRAY</strong>如下图：</p><img src="img\Chp3-FIND-MAXIMUM-SUBARRAY.png" style="zoom: 50%;" /></blockquote></li><li><p>时间复杂度</p><ul><li>当$n&#x3D;1$时，$T(n)&#x3D;\Theta(1)$；</li><li>当$n&gt;1$时，$T(n)&#x3D;2T(n&#x2F;2)+\Theta(n)$；</li><li>时间复杂度为$T(n)&#x3D;\Theta(n\lg n)$。</li></ul></li></ul><h4 id="※-4-非递归的线性算法"><a href="#※-4-非递归的线性算法" class="headerlink" title="※(4)非递归的线性算法"></a>※(4)非递归的线性算法</h4><h3 id="※5-Strassen-矩阵乘法"><a href="#※5-Strassen-矩阵乘法" class="headerlink" title="※5.$Strassen$矩阵乘法"></a>※5.$Strassen$矩阵乘法</h3><h3 id="6-最近点对问题"><a href="#6-最近点对问题" class="headerlink" title="6.最近点对问题"></a>6.最近点对问题</h3><h4 id="1-问题描述-2"><a href="#1-问题描述-2" class="headerlink" title="(1)问题描述"></a>(1)问题描述</h4><ul><li>已知平面上分布着点集$P$中的$n$个点$p_1,p_2,\dots,p_n$，点$i$的坐标记为$(x_i,y_i)$，$1\leq i\leq n$。</li><li>找出一对距离最近的点(允许两个点处于同一个位置)</li></ul><h4 id="2-暴力搜索"><a href="#2-暴力搜索" class="headerlink" title="(2)暴力搜索"></a>(2)暴力搜索</h4><ul><li>对每对点都计算距离，然后比较大小，找出其中的最小者</li><li>计算点之间的距离的时间复杂度为$O(n^2)$</li><li>比较得到最小距离的时间复杂度为$O(n^2)$</li></ul><h4 id="3-分治策略-2"><a href="#3-分治策略-2" class="headerlink" title="(3)分治策略"></a>(3)分治策略</h4><ul><li><p>排序：将所有点按照$x$坐标排序——$O(n\log n)$</p></li><li><p>划分：将点集分成左、右两半$P_L$和$P_R$</p><blockquote><p>定义$d_L$为$P_L$中最近点对距离，$d_R$为$P_R$中最近点对距离，$d_C$为跨越分割线的最近点对距离，这与最大子数组问题类似。</p></blockquote></li><li><p>改进：令$\delta&#x3D;min(d_L,d_R)$，则有$d_C&lt;\delta$，即$d_C$对应点对必然落在分割线两侧的$\delta$距离内，称之为$strip$，同时易得，$d_C$的两个点的$y$坐标相差也不会大于$\delta$，因此应该对点的$y$坐标也进行排序。</p></li><li><p>实现：假设搜索到$p_j$时，$p_j$与$p_i$的$y$坐标相差大于$\delta$，那么对于$p_i$而言更远的$p_j$就可以终止搜索，转而处理$p_i$后面的点$p_{i+1}$。</p><blockquote><p>改进后的算法伪代码：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for i=1 to numPointsInStrip do</span><br><span class="line">for j=i+1 to numPointsInStrip do</span><br><span class="line">if y-coordinates of p[i] and p[j] differ by more than δ</span><br><span class="line">break;</span><br><span class="line">else if dist(p[i],p[j])&lt;δ</span><br><span class="line">            δ=dist(p[i],p[j]);</span><br></pre></td></tr></table></figure></blockquote></li><li><p>时间复杂度</p><ul><li>在最坏的情况下，计算$d_C$的时间复杂度为$O(n)$，则最终递归式为$T(n)&#x3D;2T(n&#x2F;2)+O(n)$</li><li>※预排序</li><li>综上得到所有附加工作的总时间复杂度为$O(n)$，则$T(n)&#x3D;2T(n&#x2F;2)+cn&#x3D;O(n\log n)$</li></ul></li></ul><h3 id="7-逆序对计数问题"><a href="#7-逆序对计数问题" class="headerlink" title="7.逆序对计数问题"></a>7.逆序对计数问题</h3><h4 id="1-问题描述-3"><a href="#1-问题描述-3" class="headerlink" title="(1)问题描述"></a>(1)问题描述</h4><ul><li><p>在一个数组$A$中，称满足$i&lt;j$且$A[i]&gt;A[j]$的二元组$(A[i],A[j])$为逆序对</p><blockquote><p>在数组$A&#x3D;{4,6,8,3,5}$中，$(A[1],A[4])$即为一个逆序对</p></blockquote></li><li><p>现已知长度为$n$的数组$A[1..n]$，求其<strong>逆序对的总数</strong>$\sum\limits_{1\leq i\leq j\leq n}X_{i,j}$，其中当$A[i]&gt;A[j]$时$X_{i,j}$为1，否则为0。</p></li></ul><h4 id="2-暴力枚举"><a href="#2-暴力枚举" class="headerlink" title="(2)暴力枚举"></a>(2)暴力枚举</h4><ul><li>对于每个元素$A[i]$，枚举$j(j&gt;i)$，并统计逆序对数目；</li><li>时间复杂度为$O(n^2)$。</li></ul><h4 id="3-分治策略-3"><a href="#3-分治策略-3" class="headerlink" title="(3)分治策略"></a>(3)分治策略</h4><ul><li><p>将子数组$A[low\dots high]$划分为两个规模尽量相等的子子数组；</p></li><li><p>分别递归求解仅在$A[low\dots mid]$和$A[mid+1\dots high]$中的逆序对数目；</p></li><li><p>合并子问题的解时，求解<strong>跨越子数组</strong>的逆序对数目；</p></li><li><p>求解跨越子数组的逆序对数目</p><ul><li><p>直接求解：对于每个$A[j]\in A[mid+1\dots high]$，枚举$A[i]\in A[low\dots mid]$并统计逆序对数目——算法运行时间为$O(n^2)$，得到分治策略运行时间为$O(n^2)$；</p><blockquote><p>运行时间受制于跨越子数组的逆序对计数方法，数组的<strong>有序性</strong>通常有助于提高算法的运行时间。</p></blockquote></li><li><p>排序求解：分别对数组$A[low\dots mid]和$$A[mid+1\dots high]$进行排序，对于每个$A[j]\in A[mid+1\dots high]$，采用二分查找为其在$A[low\dots mid]$中定位，则$A[j]$在$A[low\dots mid]$定位点右侧的元素均可与$A[j]$构成逆序对——算法运行时间为$O(n\log n)$，得到分治策略运行时间为$O(n(\log n)^2)$；</p><blockquote><p>排序和二分查找均无再优化空间，但未将排序过程融入整个算法框架；</p><p><strong>排序未利用子数组有序性质</strong>——使用归并排序；</p><p>合并问题解的同时对数组进行排序，归并过程中可同时计算逆序对数目。</p></blockquote></li><li><p>归并求解：从左到右扫描$A[low\dots mid]和$$A[mid+1\dots high]$，如果$A[i]&gt;A[j]$，统计逆序对，$j$向右移；否则$i$向右移——算法运行时间为$O(n)$，得到分治策略运行时间为$O(n\log n)$。</p></li></ul></li><li><p><strong>分而治之+归并求解</strong></p><blockquote><p>MergeCount：</p><img src="Chp3-MERGECOUNT.png" style="zoom: 72%;" /><p>CountInver：</p><img src="Chp3-COUNTINVER.png" style="zoom: 55%;" /></blockquote></li><li><p>时间复杂度</p><ul><li>归并求解的算法运行时间为$o(n)$；</li><li>$T(n)&#x3D;2T(n&#x2F;2)+O(n)$；</li><li>时间复杂度为$T(n)&#x3D;O(n\lg n)$。</li></ul></li></ul><h3 id="8-快速排序"><a href="#8-快速排序" class="headerlink" title="8.快速排序"></a>8.快速排序</h3><h4 id="1-问题描述-4"><a href="#1-问题描述-4" class="headerlink" title="(1)问题描述"></a>(1)问题描述</h4><ul><li>选择排序和插入排序的时间复杂度均为$O(n^2)$；</li><li>归并排序简化分解，<strong>侧重合并</strong>，快速排序<strong>侧重分解</strong>，简化合并。</li></ul><h4 id="2-分治策略"><a href="#2-分治策略" class="headerlink" title="(2)分治策略"></a>(2)分治策略</h4><ul><li><p>选取固定位置主元$x$，如尾元素；</p></li><li><p>维护两个部分的右端点下标变量$x,y$；</p><img src="Chp3-快速排序示意图.png" style="zoom:50%;" /></li><li><p>考察数组元素$A[j]$，并<strong>只和主元比较</strong>：若$A[j]\leq x$，则交换$A[j]$和$A[i+1]$，$i$和$j$右移，否则$j$右移；</p></li><li><p>到达末尾后，把主元放在中间$(i+1)$处作为分界线；</p></li><li><p>以主元作为数组的划分，得到子数组分别进行PARTITION排序，排序后进行合并</p></li><li><p>伪代码如下：</p><blockquote><p>Partition：对每个子数组进行排序操作，返回主元位置$p$</p><img src="Chp3-PARTITION.png" style="zoom:50%;" /><p>QuickSort：利用Partition和分治策略进行快速排序</p><img src="Chp3-QUICKSORT.png" style="zoom:49%;" /></blockquote></li><li><p>时间复杂度</p><ul><li><p>选取固定位置主元时最好情况下为$O(n\log n)$，最坏情况下为$O(n^2)$</p></li><li><p>选取随机位置主元，可以避免最坏情况的发生</p><blockquote><p>Randomized-Partition：</p><img src="Chp3-RANDOMIZED-PARTITION.png" style="zoom:65%;" /><p>Randomized-QuickSort：</p><img src="Chp3-RANDOMIZED-QUICKSORT.png" style="zoom: 55%;" /></blockquote></li><li><p>随机化的快速排序的期望复杂度为$O(n\log n)$</p></li><li><p><strong>基于比较的排序，其时间复杂度的下界为$\Omega(n\log n)$。</strong></p></li></ul></li></ul><h3 id="9-次序选择问题"><a href="#9-次序选择问题" class="headerlink" title="9.次序选择问题"></a>9.次序选择问题</h3><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="(1)基本概念"></a>(1)基本概念</h4><ul><li><p>顺序统计量：在一个由$n$个元素组成的集合中，第$i$个顺序统计量$(order statistic)$是该集合中的<strong>第$i$小</strong>的元素</p></li><li><p>中位数（<strong>一般指下中位数</strong>）</p><ul><li>下中位数：$i&#x3D;n&#x2F;2$或$i&#x3D;\lfloor(n+1)&#x2F;2\rfloor$</li><li>上中位数：$i&#x3D;n&#x2F;2+1$或$i&#x3D;\lceil(n+1)&#x2F;2\rceil$</li></ul></li><li><p>选择问题：从$n$个元素的集合中选择第$i$个顺序统计量的问题形式化地归结为<strong>“选择问题”</strong></p><ul><li>输入：一个包含$n$个（互异的）数的集合$A$和一个整数$i$，$1\leq i\leq n$</li><li>输出：元素$x\in A$,且$A$中恰好有$i-1$个其他元素小于它</li></ul></li><li><p>采用排序求解的方式解决选择问题时，其时间复杂度为$O(n\log n)$，可以求得所有元素的次序，选择元素的时间复杂度为$O(1)$。</p></li></ul><h4 id="2-期望为线性时间的选择算法"><a href="#2-期望为线性时间的选择算法" class="headerlink" title="(2)期望为线性时间的选择算法"></a>(2)期望为线性时间的选择算法</h4><ul><li><p>受启发于快速排序的Partition过程：</p><blockquote><img src="Chp3-受启发于快速排序.png" style="zoom: 45%;" /></blockquote></li><li><p>选择算法：</p><img src="Chp3-RANDOMIZED-SELECT.png" style="zoom: 50%;" /><blockquote><p>第1行检查$A[p..r]$中只包括一个元素的情况；</p><p>其余情况调用第3行的RANDOMIZED-PARTITION，将数组$A[p..r]$划分为两个子数组$A[p..q-1]$和$A[q+1..r]$<strong>（可能为空）</strong>，使前者的每个元素都小于$A[q]$，后者的每个元素都大于$A[q]$，称$A[q]$为主元；</p><p>第4行计算处于划分的低区的元素个数加1；</p><p>第5行检查$A[q]$是否为第$i$小的元素；</p><p>如果不是，则确定第$i$小的元素是在哪个子数组并在其中递归查找，当$i&gt;k$时，要找的元素必定为$A[q+1..r]$中第$i-k$小的元素。</p></blockquote></li><li><p>最坏情况运行时间为$\Theta(n^2)$，期望运行时间为$\Theta(n)$</p></li></ul><h4 id="※-3-最坏情况为线性时间的选择算法"><a href="#※-3-最坏情况为线性时间的选择算法" class="headerlink" title="※(3)最坏情况为线性时间的选择算法"></a>※(3)最坏情况为线性时间的选择算法</h4><h2 id="四、动态规划"><a href="#四、动态规划" class="headerlink" title="四、动态规划"></a>四、动态规划</h2><h3 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1.基本原理"></a>1.基本原理</h3><h4 id="1-基本概念-1"><a href="#1-基本概念-1" class="headerlink" title="(1)基本概念"></a>(1)基本概念</h4><ul><li>最优化问题：这一类问题的可行解可能有很多个。每个解都有一个值，我们希望寻找具有最优值的解（最小值或最大值）；</li><li>最优解可能有多个；</li><li>根据描述约束条件和目标函数的数学模型的特性和问题的求解方法的不同，可分为：线性规划、整数规划、非线性规划、 动态规划等问题。</li></ul><h4 id="2-动态规划的步骤"><a href="#2-动态规划的步骤" class="headerlink" title="(2)动态规划的步骤"></a>(2)动态规划的步骤</h4><ol><li><p><strong>问题结构分析</strong>：刻画结构特征，<strong>给出问题的表示</strong>，并<strong>明确原始问题</strong>；</p></li><li><p><strong>递推关系建立</strong>：分析最优(子)结构特征，构造递推公式；</p><blockquote><p>问题的最优解由相关子问题最优解组合而成，子问题可以独立求解；</p><p>递推公式又称状态转移方程。</p></blockquote></li><li><p><strong>自底向上计算</strong>：确定计算顺序，计算最优解的值；</p><blockquote><p>子问题的无关性和重叠性</p><ul><li>两个子问题如果不共享资源，它们就是独立的，比如在分治算法中子问题相互独立；</li><li>重叠是指两个子问题实际上是同一个子问题，只是作为不同问题的子问题出现而已，如果暴力枚举，则会导致大量重叠子问题重复计算。</li></ul><p>重叠子问题的解决：动态规划<strong>付出额外空间保存结果</strong>，对每个子问题只求解一次。</p></blockquote></li><li><p><strong>最优方案追踪</strong>：利用辅助数组等记录决策过程，输出最优方案。</p></li></ol><h4 id="3-证明最优子结构性"><a href="#3-证明最优子结构性" class="headerlink" title="(3)证明最优子结构性"></a>(3)证明最优子结构性</h4><ul><li>证明问题满足最优性原理是实施动态规划的必要条件。</li><li>证明的通用模式<ol><li>证明问题最优解的第一个组成部分是做出一个选择，例如，选择钢条第一次切割位置，选择矩阵链的划分位置等。</li><li>利用<strong>“剪切一粘贴”</strong>技术证明<ul><li>作为原问题最优解的组成部分，每个子问题的解就是它本身的最优解。</li><li>利用反证法：假定子问题的解不是其自身的最优解，那么我们就可以从原问题的解中<strong>“剪切”</strong>掉这些非最优解，将最优解<strong>“粘贴”</strong>进去，从而得到原问题一个更优的解，<strong>这与最初的解是原问题最优解的前提假设矛盾</strong>。</li></ul></li></ol></li></ul><h4 id="4-备忘机制"><a href="#4-备忘机制" class="headerlink" title="(4)备忘机制"></a>(4)备忘机制</h4><p>为了避免对重叠子问题的重复计算，在递归过程中加入<strong>备忘</strong>机制。当第一次遇到子问题时，计算其解，并将结果存储在备忘表中；而其后遇到同一个子问题时，通过简单的查表即可返回其解，无需重复计算，节省了时间。</p><h4 id="5-重构最优解"><a href="#5-重构最优解" class="headerlink" title="(5)重构最优解"></a>(5)重构最优解</h4><p>通常定义一个表，<strong>记录每个子问题所做的决策</strong>。当求出最优解的值后，利用该表<strong>回溯</strong>即可得到最优方案。</p><h4 id="6-子问题图"><a href="#6-子问题图" class="headerlink" title="(6)子问题图"></a>(6)子问题图</h4><ul><li><strong>子问题图用于描述子问题与子问题之间的依赖关系</strong>。</li><li>子问题图是一个有向图，每个顶点唯一地对应一个子问题。</li><li>若求子问题$x$的最优解时直接用到子问题$y$的最优解，则在子问题图中就会有一条从子问题$x$的顶点到子问题$y$的顶点的有向边。</li><li>子问题图是<strong>自顶向下递归调用树的“简化版”</strong>。</li><li>在自底向上方法中，对于任何子问题，仅当它依赖的所有子问题都求解完成，才会求解它。</li><li>子问题的数目等于顶点数；</li><li>一个子问题的求解时间与子问题图中对应顶点的“出度”成正比；</li><li>一般情况下，<strong>动态规划算法的运行时间与顶点和边的数量至少呈线性关系</strong>。</li></ul><h3 id="2-01背包问题"><a href="#2-01背包问题" class="headerlink" title="2.01背包问题"></a>2.01背包问题</h3><h4 id="1-问题描述-5"><a href="#1-问题描述-5" class="headerlink" title="(1)问题描述"></a>(1)问题描述</h4><p>$n$个商品组成集合$O$，每个商品有两个属性$v_i$和$p_i$，分别表示体积和价格，背包容量为$C$</p><p>试求解一个商品子集$S\subseteq O$，使得$max\sum\limits_{i\in S}p_i$且$\sum\limits_{i\in S}v_i\leq C$。</p><h4 id="2-问题分析-1"><a href="#2-问题分析-1" class="headerlink" title="(2)问题分析"></a>(2)问题分析</h4><ul><li>可以选取以下策略：<ul><li>策略1：按商品价格由高到低排序，优先挑选价格高的商品</li><li>策略2：按商品体积由小到大排序，优先挑选体积小的商品</li><li>策略3：按商品价值与体积的比由高到低排序，优先挑选比值高的商品</li></ul></li><li>以上三种策略<strong>都不能达到最优解</strong></li></ul><h4 id="3-暴力枚举"><a href="#3-暴力枚举" class="headerlink" title="(3)暴力枚举"></a>(3)暴力枚举</h4><ul><li><p>枚举所有组合共$2^n-1$种情况，并检查体积约束</p></li><li><p>伪代码如下：</p><blockquote><p>$KnapsackSR(i,c)$：前$i$个商品中，容量为$c$时为最优解</p><img src="Chp4-KnapsackSR.png" style="zoom:40%;" /></blockquote></li><li><p>时间复杂度为$O(2^n)$</p></li></ul><h4 id="4-带备忘递归-自顶向下"><a href="#4-带备忘递归-自顶向下" class="headerlink" title="(4)带备忘递归(自顶向下)"></a>(4)带备忘递归(自顶向下)</h4><ul><li><p>记录子问题解，避免重复计算</p></li><li><p>伪代码如下：</p><blockquote><p>$KnapsackMR(i,c)$：带备忘的递归求解</p><img src="Chp4-KnapsackMR.png" style="zoom: 45%;" /><p>构造备忘录$P[i,c]$，表示在前$i$个商品中选择，背包容量为$c$时的最优解</p></blockquote></li></ul><h4 id="5-递推计算-自底向上"><a href="#5-递推计算-自底向上" class="headerlink" title="(5)递推计算(自底向上)"></a>(5)递推计算(自底向上)</h4><ul><li><p>递推公式：$P[i,c]&#x3D;max{P[i-1,c-v[i]]+p[i],P[i-1,c]}$；</p></li><li><p>使用$Rec[i,c]$记录决策过程，选择时为1，否则为0；</p></li><li><p>回溯解决方案时，倒序判断是否选择商品，根据选择结果，确定最优子问题；</p></li><li><p>伪代码如下：</p><blockquote><p>$KnapsackDP(n,p,v,C)$</p><img src="Chp4-KnapsackDP-1.png" style="zoom:50%;" /><p>对数组进行初始化，默认每个商品都不选择；</p><img src="Chp4-KnapsackDP-2.png" style="zoom:48%;" /><p>在$for$循环中依次计算子问题，对于每个子问题，如果商品体积$v[i]\leq c$且选择该商品后得到的总价格$(P[i-1,c-v[i]]+p[i])$高，则选择该商品并更新$P[i,c]$，否则不选择该商品；</p><img src="Chp4-KnapsackDP-3.png" style="zoom:47%;" /><p>倒序判断是否选择了该商品，如果选择了该商品，则回溯子问题。</p></blockquote></li><li><p>求解表格的算法复杂度为$O(n\cdot C)$。</p></li></ul><h3 id="※3-最大子数组问题"><a href="#※3-最大子数组问题" class="headerlink" title="※3.最大子数组问题"></a>※3.最大子数组问题</h3><p>使用分治算法解决最大子数组问题的时间复杂度为$O(n\log n)$，使用动态规划方法能达到时间复杂度仅为$O(n)$的算法。</p><h3 id="4-钢条切割问题"><a href="#4-钢条切割问题" class="headerlink" title="4.钢条切割问题"></a>4.钢条切割问题</h3><h4 id="1-问题描述-6"><a href="#1-问题描述-6" class="headerlink" title="(1)问题描述"></a>(1)问题描述</h4><ul><li><p>给定一段长度为$n$英寸的钢条和一个价格表$P$，切割工序本身没有成本支出，求切割钢条方案，使得销售收益 $r_n$ 最大。</p></li><li><p>假定出售一段长度为i英寸的钢条的价格为$p_i(i&#x3D;1,2,\dots)$，下面是价格表$P$：</p><img src="Chp4-价格表P.png" style="zoom: 50%;" /></li></ul><h4 id="2-问题分析-2"><a href="#2-问题分析-2" class="headerlink" title="(2)问题分析"></a>(2)问题分析</h4><ul><li>每一英寸都可切割，共有$n-1$个切割点，因此长度为$n$英寸的钢条共有$2^{n-1}$中不同的切割方案。</li><li>如果一个最优解将总长度为$n$的钢条切割为$k$段，每段的长度为$i_j(1\leq j\leq k)$，则有$n&#x3D;i_1+i_2+\dots+i_k$，得到的最大收益为$r_n&#x3D;p_{i_1}+p_{i_2}+\dots+p_{i_k}$</li><li>首次切割后，将两段钢条看成<strong>两个独立的钢条切割问题</strong>实例。若分别获得两段钢条的最优切割收益$r_j$和$r_{n-j}$，则原问题的解就可以通过<strong>组合这两个相关子问题的最优子解</strong>获得。</li><li>也即<strong>最优子结构性</strong>——如果$r_n&#x3D;r_i+r_{n-i}$是最优切割收益，则$r_i$、$r_{n-i}$是相应子问题的最优切割收益。</li></ul><h4 id="3-朴素递归"><a href="#3-朴素递归" class="headerlink" title="(3)朴素递归"></a>(3)朴素递归</h4><ul><li><p>$r_n&#x3D;\max\limits_{1\leq i\leq n}{(p_i+r_{n-i})}$</p><img src="Chp4-CUT-ROD.png" style="zoom: 33%;" /></li><li><p>运行效率很差，存在一些相同的子问题重复调用解决</p></li><li><p>$T(n)&#x3D;1+\sum\limits_{j&#x3D;0}^{n-1}T(j)$，也即$T(n)&#x3D;2^n$</p></li></ul><h4 id="4-带备忘递归-自顶向下-1"><a href="#4-带备忘递归-自顶向下-1" class="headerlink" title="(4)带备忘递归(自顶向下)"></a>(4)带备忘递归(自顶向下)</h4><ul><li><p>依旧按照<strong>递归</strong>的形式编写过程，但处理过程中会<strong>保存每个子问题的解</strong>。</p></li><li><p>具体实现如下：</p><blockquote><img src="Chp4-MEMOIZED-CUT-ROD.png" style="zoom: 50%;" /></blockquote><blockquote><img src="Chp4-MEMOIZED-CUT-ROD-AUX.png" style="zoom: 40%;" /></blockquote><blockquote><p>其中辅助数组$r[0\dots n]$用于保存子问题的结果。</p><p>​初始化为$-\infty$；</p><p>​当有新的结果时，$r[n]$保存结果$q$；</p><p>​当$r[n]\geq 0$时，直接引用其中已保存的值。</p></blockquote></li><li><p>运行时间为$\Theta(n^2)$</p></li></ul><h4 id="5-自底向上"><a href="#5-自底向上" class="headerlink" title="(5)自底向上"></a>(5)自底向上</h4><ul><li><p>将子问题按规模排序，按<strong>由小到大的顺序顺次求解</strong>，当求解某个子问题时，它所依赖的<strong>更小子问题都已求解完毕</strong>，结果已经保存，故可以直接引用并组合出它自身的解</p><img src="Chp4-BOTTOM-UP-CUT-ROD.png" style="zoom: 50%;" /></li><li><p>运行时间为$\Theta(n^2)$，相比自顶向下的方法具有更小的系数</p></li></ul><h4 id="6-自底向上-给出切割方案"><a href="#6-自底向上-给出切割方案" class="headerlink" title="(6)自底向上(给出切割方案)"></a>(6)自底向上(给出切割方案)</h4><img src="Chp4-EXTENDED-BOTTOM-UP-CUT-ROD.png" style="zoom: 50%;" /><img src="Chp4-PRINT-CUT-ROD-SOLUTION.png" style="zoom: 50%;" /><h3 id="5-矩阵链乘法问题"><a href="#5-矩阵链乘法问题" class="headerlink" title="5.矩阵链乘法问题"></a>5.矩阵链乘法问题</h3><h4 id="1-基本背景"><a href="#1-基本背景" class="headerlink" title="(1)基本背景"></a>(1)基本背景</h4><ul><li>已知$A$为$p\times r$的矩阵，$B$为$r\times q$的矩阵，则$A$与$B$的乘积是一个$p\times q$的矩阵，矩阵相乘需要进行**$pqr$**次标量乘法运算。</li><li>$n$个要连续相乘的矩阵构成一个矩阵链$&lt;A_1,A_2,\dots,A_n&gt;$，要计算这$n$个矩阵的连乘乘积：$A_1A_2\dots A_n$，称为矩阵链乘问题。<ul><li>矩阵链乘满足结合律，不满足交换律。</li><li>不同的加括号方式代表不同的<strong>计算模式</strong>，而不同的计算模式计算矩阵链乘积的<strong>代价不同</strong>。</li></ul></li></ul><h4 id="2-问题描述"><a href="#2-问题描述" class="headerlink" title="(2)问题描述"></a>(2)问题描述</h4><ul><li>给定$n$个矩阵的链，记为$&lt;A_1,A_2,\dots,A_n&gt;$，其中$i&#x3D;1,\dots,n$，矩阵$A_i$的维数为$p_{i-1}\times P_i$。</li><li>求<strong>“完全括号化方案”</strong>，使得计算乘积$A_1A_2\dots A_n$所需的标量乘法次数最小。</li><li>穷举所有方案的数量：当$n&#x3D;1$时，$P(n)&#x3D;1$，当$n\geq 2$时，$P(n)&#x3D;\sum\limits_{k&#x3D;1}^{n-1}P(k)P(n-k)$，证明得到时间复杂度为$P(n)&#x3D;\Omega(2^n)$</li></ul><h4 id="3-动态规划"><a href="#3-动态规划" class="headerlink" title="(3)动态规划"></a>(3)动态规划</h4><ul><li><p>最优括号化方案的结构特征——寻找最优子结构</p><ul><li>整体的最优括号化方案可以通过寻找使最终标量乘法次数最小的两个最优括号化子方案得到，形如：$(A_1A_{i+1}\dots A_k)(A_{k+1}\dots A_n)$</li></ul></li><li><p>递推求解方案</p><ul><li>递推求解公式</li></ul><img src="Chp4-矩阵链乘递归式.png" style="zoom: 80%;" /><ul><li>使用$s[i,j]$保存$A_iA_{i+1}\dots A_j$最优括号化方案的分割点位置$k$</li></ul></li><li><p>计算最优代价</p><ul><li><p>对应子问题为$\Theta(n^2)$个，存在<strong>子问题重叠</strong>现象，同最优子结构性一样，这也是应用动态规划的标识。</p></li><li><p>采用自底向上法替代该递推求解公式</p><ul><li><p>算法的输入为序列$p&#x3D;\langle p_0,p_1,\dots,p_n\rangle$，长度为$p.length&#x3D;n+1$</p></li><li><p>算法伪代码如下：</p><img src="Chp4-MATRIX-CHAIN-ORDER.png" style="zoom: 50%;" /><blockquote><p>第$3\thicksim 4$行计算$m[i,i]&#x3D;0$</p><p>第$5\thicksim 13$行计算不同矩阵链长度下$m[i,i+l-1]$的最小计算代价，长度依次递增计算。</p><p>可以使用一个上三角矩阵表表示$m[i,j]$和$s[i,j]$</p><p>具体实例如下：</p><img src="Chp4-MATRIX-CHAIN-ORDER-SAMPLE.png" style="zoom: 67%;" /></blockquote></li><li><p>算法运行时间为$\Omega(n^3)$，空间复杂度为$\Theta(n^2)$</p></li></ul></li></ul></li><li><p>构造最优解</p><ul><li><p>$s[i,j]$记录了$A_iA_{i+1}\dots A_j$的最优括号化方案的“首个”分割点$k$。基于$s[i,j]$，对$A_iA_{i+1}\dots A_j$的括号化方案是：</p><p>​       $(A_iA_{i+1}\dots A_{s[i,j]})(A_{s[i,j]+1}\dots A_j)$</p></li><li><p>打印结果的伪代码如下：</p><img src="Chp4-PRINT-OPTIMAL-PARENS.png" style="zoom: 50%;" /></li></ul></li></ul><h3 id="6-最长公共子序列"><a href="#6-最长公共子序列" class="headerlink" title="6.最长公共子序列"></a>6.最长公共子序列</h3><h4 id="1-基本背景-1"><a href="#1-基本背景-1" class="headerlink" title="(1)基本背景"></a>(1)基本背景</h4><ul><li><p>子序列</p><p>给定两个序列$X&#x3D;&lt;X_1,X_2,\dots,X_n&gt;$和序列$Z&#x3D;&lt;z_1,z_2,\dots,z_k&gt;$，若存在$X$的一个严格递增下标序列$&lt;i_1,i_2,\dots,i_k&gt;$,使得对所有$j&#x3D;1,2,\dots,k$，有$x_{i_j}&#x3D;z_j$，则称$Z$是$X$的子序列。</p><blockquote><p>$Z&#x3D;&lt;B,C,D,B&gt;$是$X&#x3D;&lt;A,B,C,B,D,A,B&gt;$的一个子序列，对应下标序列为$&lt;2,3,5,7&gt;$。</p></blockquote></li><li><p>公共子序列</p><p>对给定的两个序列$X$和$Y$，若序列$Z$既是$X$的的子序列，也是$Y$的子序列，则称$Z$是$X$和$Y$的公共子序列。</p><blockquote><p>$X&#x3D;&lt;A,B,C,B,D,A,B&gt;$，$Y&#x3D;&lt;B,D,C,A,B,A&gt;$，则序列$&lt;B,C,A&gt;$是$X$和$Y$的一个公共子序列。</p></blockquote></li><li><p>最长公共子序列(LCS)</p><p>两个序列的长度最大的公共子序列称为它们的最长公共子序列。</p><blockquote><p>$&lt;B,C,A&gt;$是上面$X$和$Y$的一个公共子序列，但不是$X$和$Y$的最长公共子<br>序列。最长公共子序列是$&lt;B,C,B,A&gt;$。</p></blockquote></li><li><p>前缀</p><p>给定一个序列$X&#x3D;&lt;x_1,x_2,\dots,x_m&gt;$，对于$i&#x3D;0,1,\dots,m$，定义$X$的第$i$个前缀为$X_i&#x3D;&lt;x_1,x_2,\dots,x_i&gt;$，即前$i$个元素构成的子序列。</p><blockquote><p>$X&#x3D;&lt;A,B,C,B,D,A,B&gt;$，则$X_4&#x3D;&lt;A,B,C,B&gt;$，$X_0&#x3D;\Phi$。</p></blockquote></li></ul><h4 id="2-最优子结构性"><a href="#2-最优子结构性" class="headerlink" title="(2)最优子结构性"></a>(2)最优子结构性</h4><p>两个序列的一个$LCS$也包含了两个序列的前缀的$LCS$，即$LCS$问题具有最优子结构性质。</p><blockquote><p>定理：设有序列$X&#x3D;&lt;x_1,x_2,\dots,x_m&gt;$和$Y&#x3D;&lt;y_1,y_2,\dots,y_n&gt;$，并设序列$Z&#x3D;&lt;z_1,z_2,\dots,z_k&gt;$为$X$和$Y$的任意一个**$LCS$**。</p><p>（1）若$x_m＝y_n$，则$z_k&#x3D;x_m&#x3D;y_n$，且$Z_{k-1}$是$X_{m-1}$和$Y_{n-1}$的一个$LCS$。</p><p>（2）若$x_m\ne y_n$，则$z_k\ne x_m$蕴含$Z$是$X_{m-1}$和Y的一个$LCS$。</p><p>（3）若$x_m\ne y_n$，则$z_k\ne y_n$蕴含$Z$是$X$和$Y_{n-1}$的一个$LCS$。</p></blockquote><h4 id="3-递推关系式"><a href="#3-递推关系式" class="headerlink" title="(3)递推关系式"></a>(3)递推关系式</h4><p>记$c[i,j]$为前缀序列$X_i$和$Y_j$的一个$LCS$的长度，则有</p><img src="Chp4-LCS递推关系式.png" style="zoom: 33%;" /><blockquote><p>1）若$i&#x3D;0$或$j&#x3D;0$，即其中一个序列的长度为零，则$LCS$的长度为0，$LCS&#x3D;\Phi$；</p><p>2）若$x_i&#x3D;y_j$，则$X_i$和$Y_j$的$LCS$是在$X_{i-1}$和$Y_{j-1}$的$LCS$之后附加将$x_i$得到的，所以                </p><p>$c[i,j]&#x3D;c[i-1,j-1]+1$；</p><p>3）若$x_i\ne y_j$，则$X_i$和$Y_j$的$LCS$的最后一个字符不会是$x_i$或$y_j$(不可能同时等于两者，或与两者都不同)，此时该$LCS$应等于$X_{i-1}$和$Y_j$的$LCS$与$X_i$和$Y_{j-1}$的$LCS$之中的较长者。所以</p><p>$c[i,j]&#x3D;max(c[i-1,j],c[i,j-1])$。</p></blockquote><h4 id="4-自底向上"><a href="#4-自底向上" class="headerlink" title="(4)自底向上"></a>(4)自底向上</h4><ul><li><p>过程$LCS-LENGTH(X,Y)$用来求序列$X&#x3D;&lt;x_1,x_2,\dots,x_m&gt;$和$Y&#x3D;&lt;y_1,y_2,\dots,y_n&gt;$的$LCS$的长度，其时间复杂度为$O(mn)$。</p><img src="Chp4-LCS-LENGTH.png" style="zoom: 50%;" /><blockquote><p>表$c[1..m,1..n]$中包含每一阶段的$LCS$长度，$c[m,n]$等于$X$和$Y$的$LCS$的长度。</p><p>表$b[1..m,1..n]$记录当前$c[i,j]$的计值情况，以此来构造该$LCS$。</p><p>下图给出了在$X&#x3D;&lt;A,B,C,B,D,A,B&gt;$和$Y&#x3D;&lt;B,D,C,A,B,A&gt;$上运行$LCS-LENGTH$计算出的表：</p><img src="Chp4-LCS-LENGTH-SAMPLE.png" style="zoom: 67%;" /><blockquote><p>1）第$i$行和第$j$列中的方块包含了$c[i,j]$的值以及$b[i,j]$记录的箭头。</p><p>2）对于$i,j＞0$，项$c[i,j]$仅依赖于是否有$x_i&#x3D;y_j$及项$c[i-1,j]$、$c[i,j-1]$、$c[i-1,j-1]$的值。</p><p>3）为了重构一个$LCS$，从右下角开始跟踪$b[i,j]$箭头即可</p><p>4）图中，$c[7,6]&#x3D;4$，$LCS(X,Y)&#x3D;&lt;B,C,B,A&gt;$。</p></blockquote></blockquote></li></ul><h4 id="5-构建最优解"><a href="#5-构建最优解" class="headerlink" title="(5)构建最优解"></a>(5)构建最优解</h4><ul><li><p>借助$b[i,j]$反序输出$LCS$，由于每一次循环使$i$或$j$减1，最终$m&#x3D;0$，$n&#x3D;0$，算法结束，所以$PRINT-LCS$的时间复杂度为$O(m+n)$。</p><img src="Chp4-PRINT-LCS.png" style="zoom: 33%;" /></li><li><p>改进：去掉表$b$，直接基于$c$求$LCS$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PRINT-LCS-WITHOUTAUXI(c, X, Y, i, j)</span><br><span class="line">    if c[i, j] == 0</span><br><span class="line">        return</span><br><span class="line">    if X[i] == Y[j]</span><br><span class="line">        PRINT-LCS-WITHOUTAUXI(c, X, Y, i - 1, j - 1)</span><br><span class="line">        print X[i]</span><br><span class="line">    else if c[i - 1, j] &gt;= c[i, j - 1]</span><br><span class="line">        PRINT-LCS-WITHOUTAUXI(c, X, Y, i - 1, j)</span><br><span class="line">    else</span><br><span class="line">        PRINT-LCS-WITHOUTAUXI(c, X, Y, i, j - 1)</span><br></pre></td></tr></table></figure></li><li><p>改进：算法中，每个$c[i,j]$的计算仅需$c$的两行的数据：正在被计算的一行和前面的一行。</p></li></ul><h3 id="※7-最长公共子串"><a href="#※7-最长公共子串" class="headerlink" title="※7.最长公共子串"></a>※7.最长公共子串</h3><h3 id="8-最优二叉搜索树"><a href="#8-最优二叉搜索树" class="headerlink" title="8.最优二叉搜索树"></a>8.最优二叉搜索树</h3><h4 id="1-基本背景-2"><a href="#1-基本背景-2" class="headerlink" title="(1)基本背景"></a>(1)基本背景</h4><ul><li><p>二叉搜索树$T$是一棵二元树，它或者为空，或者其每个结点含有一个可以比较大小的数据元素，且有：</p><ul><li>$T$的左子树的所有元素比根结点中的元素小；</li><li>$T$的右子树的所有元素比根结点中的元素大；</li><li>$T$的左子树和右子树也是二叉搜索树。</li></ul></li><li><p>给定一个$n$个关键字的升序序列$K&#x3D;&lt;k_1,k_2,\dots,k_n&gt;$，对每个关键字$k_i$，都有一个概率$p_i$表示其被搜索的频率。根据$k_i$和$p_i$构建一个二叉搜索树$T$，每个$k_i$对应树中的一个结点。</p></li><li><p>引入外部结点$d_0,d_1,\dots,d_n$，用来表示不在$K$中的值,称为伪关键字。</p><ul><li><p>伪关键字在$T$中对应外部结点，共有$n+1$个。</p><blockquote><p>​<strong>扩展二叉树</strong>：内结点表示关键字$k_i$，外结点(叶子结点)表示$d_i$。</p></blockquote></li><li><p>每个$d_i$代表一个区间，$d_0$表示所有小于$k_1$的值，$d_n$表示所有大于$k_n$的值，对于$i&#x3D;1,\dots,n-1$，$d_i$表示所有在$k_i$和$k_{i+1}$之间的值。</p></li><li><p>每个$d_i$也有一个概率$q_i$<strong>，</strong>表示搜索对象$x$恰好落入区间$d_i$的频率。</p></li></ul></li><li><p>一次搜索的代价等于从根结点开始访问结点的数量(<strong>包括外部结点</strong>)</p><blockquote><p>从根结点开始访问结点的数量等于<strong>“结点在$T$中的深度+1”</strong>；</p><p>记$depth_{T(i)}$为结点$i$在$T$中的深度</p></blockquote></li><li><p>二叉搜索树$T$的期望代价为</p><img src="Chp4-SEARCH-COST-EXPECTATION.png" style="zoom: 33%;" /></li><li><p><strong>最优二叉搜索树</strong>：对于给定的关键字及其概率集合，期望搜索代价最小的二叉搜索树。</p></li></ul><h4 id="2-动态规划"><a href="#2-动态规划" class="headerlink" title="(2)动态规划"></a>(2)动态规划</h4><ul><li><p>最优二叉搜索树的最优子结构</p><blockquote><p>如果$T$是一棵相对于关键字$k_1,\dots,k_n$和伪关键字$d_0,\dots,d_n$的最优二叉搜索树，则$T$中一棵包含关键字$k_i,\dots,k_j$的子树$T’$必然是相对于关键字$k_i,\dots,k_j$（和伪关键字$d_{i-1},\dots,d_j$）的最优二叉搜索子树。</p></blockquote></li><li><p>构造最优二叉搜索树</p><ul><li><p>求解包含关键字$k_i,\dots,k_j$的最优二叉搜索树，其中$i\geq 1$，$j\leq n$且 $j\geq i-1$</p></li><li><p>定义$e[i,j]$：为包含关键字$k_i,\dots,k_j$的最优二叉搜索树的期望搜索代价。</p></li><li><p>当$j&#x3D;i-1$时，由于子树只包含伪关键字$d_{i-1}$,期望搜索代价为$e[i,i-1]&#x3D;q_{i-1}$</p></li><li><p>当$j\geq i$时，从$k_i,\dots,k_j$中选择出根结点$k_r$，以此构建两个最优左右二叉搜索子树。</p><img src="Chp4-最优二叉搜索树期望搜索代价递归公式.png" style="zoom:67%;" /></li></ul></li><li><p>计算期望搜索代价</p><ul><li><p>定义$root[i,j]$，保存计算$e[i, j]$时，使$e[i, j]$取得最小值的$r$，$k_r$即为关键字$k_i,\dots,k_j$的最优二叉搜索（子）树的树根。在求出$e[1,n]$后，利用$root$即可构造出最终的最优二叉搜索树。</p></li><li><p>$w[1..n+1,0..n]$用于保存子树的结点概率之和，每个$w[i,j]$的计算时间仅为$\Theta(1)$</p><blockquote><p>满足<img src="Chp4-BST-w[i,j].png" style="zoom: 33%;" /></p></blockquote></li><li><p>自底向上的迭代计算，时间复杂度为$\Theta(n^3)$</p><img src="Chp4-OPTIMAL-BST.png" style="zoom:50%;" /></li></ul></li></ul><h2 id="五、贪心算法"><a href="#五、贪心算法" class="headerlink" title="五、贪心算法"></a>五、贪心算法</h2><h3 id="1-基本原理-1"><a href="#1-基本原理-1" class="headerlink" title="1.基本原理"></a>1.基本原理</h3><h4 id="1-基本概念-2"><a href="#1-基本概念-2" class="headerlink" title="(1)基本概念"></a>(1)基本概念</h4><ul><li>分步骤实施，它在每一步仅作出当时看起来最佳的选择，即<strong>局部最优的选择</strong>，并寄希望这样的选择最终能导致<strong>全局最优解</strong>。</li><li>实例：最小生成树问题的$Prim$算法、$Kruskal$算法，单源最短路径$Dijkstra$算法，<strong>分数背包</strong>。</li><li>贪心算法<strong>不总能对所有问题能求解</strong>，只是对一些问题确实有效，可以求出最优解或近似最优解。</li></ul><h4 id="2-贪心算法的步骤"><a href="#2-贪心算法的步骤" class="headerlink" title="(2)贪心算法的步骤"></a>(2)贪心算法的步骤</h4><ul><li><p>提出贪心策略：观察问题特征，构造贪心选择；</p></li><li><p>证明策略正确：假设最优方案，通过替换证明。</p><blockquote><p>对应每个贪心算法，都有一个动态规划算法，但动态规划算法要繁琐的多。</p></blockquote></li></ul><h4 id="3-贪心选择性质"><a href="#3-贪心选择性质" class="headerlink" title="(3)贪心选择性质"></a>(3)贪心选择性质</h4><p>可以通过做出局部最优（贪心）选择来构造全局最优解的性质。</p><p>贪心选择性使得我们进行选择时， 只需做出当前看起来最优的选择，而不用考虑子问题的解。  </p><h3 id="2-活动选择问题"><a href="#2-活动选择问题" class="headerlink" title="2.活动选择问题"></a>2.活动选择问题</h3><h4 id="1-问题描述-7"><a href="#1-问题描述-7" class="headerlink" title="(1)问题描述"></a>(1)问题描述</h4><ul><li><p>假定有一个活动的集合$S$​含有$n$​个活动${a_1,a_2,\dots,a_n}$​，每个活动$a_i$​都有一个开始时间$s_i$​和结束时间$f_i$​，$0\leq s_i&lt;f_i&lt;\infty$。同时，这些活动都要使用同一资源(如演讲会场)，而这个资源在任何时刻只能供一个活动使用。</p></li><li><p>活动的兼容性：如果选择了活动$a_i$，则它在半开时间区间 $[s_i, f_i)$内占用资源。若两个活动$a_i$和$a_j$满足$[s_i, f_i)$与区间$[s_j, f_j)$不重叠，则称它们是<strong>兼容</strong>的。</p></li><li><p><strong>活动选择问题</strong>：假设活动按照结束时间单调递增排序，对给定的包含$n$个活动的集合$S$，在已知每个活动开始时间和结束时间的条件下，从中选出最多可兼容活动的子集合，称为<strong>最大兼容活动集合</strong>。</p><blockquote><p>考虑下列活动集合$S$：</p><img src="Chp5-活动选择问题SAMPLE.png" style="zoom:67%;" /></blockquote></li></ul><h4 id="2-问题分析-3"><a href="#2-问题分析-3" class="headerlink" title="(2)问题分析"></a>(2)问题分析</h4><ul><li><p>设$S_{ij}$表示在$a_i$结束之后开始且在$a_j$开始之前结束的活动集合，$A_{ij}$表示$S_{ij}$的一个最大兼容活动子集，设$A_{ij}$包括活动$a_k$，则得到两个子问题——寻找$S_{ik}$和$S_{kj}$的最大兼容活动集合。</p><blockquote><p>图解如下：</p><img src="Chp5-活动选择问题的最优子结构性.png" style="zoom:50%;" /></blockquote></li><li><p>必有：$A_{ik}$是$S_{ik}$一个最大兼容活动子集，$A_{kj}$是$S_{kj}$一个最大兼容活动子集。</p><blockquote><p>$A_{ij}&#x3D;A_{ik}∪{a_k}∪A_{kj}$</p></blockquote></li><li><p>令$c[i,j]$表示集合$S_{ij}$的最优解大小，可使用动态规划方法解决</p></li></ul><h4 id="3-贪心算法"><a href="#3-贪心算法" class="headerlink" title="(3)贪心算法"></a>(3)贪心算法</h4><ul><li><p>每次总选择具有最早结束时间的兼容活动加入到集合$A$中——使剩余的可安排时间段最大化，以便安排尽可能多的兼容活动。</p></li><li><p>当输入的活动已按结束时间的递增顺序排列，贪心算法只需$O(n)$的时间即可选择出来$n$个活动的最大兼容活动集合。</p><blockquote><p>考虑任意非空子问题$S_k$，令$a_m$是$S_k$中结束时间最早的活动，则$a_m$必在$S_k$的某个最大兼容活动子集中。</p></blockquote></li><li><p>自顶向下的递归方法</p><blockquote><p>首先做出一个选择，然后求解剩下的子问题。每次选择将问题转化成一个规模更小的问题。</p><p>伪代码如下：</p><img src="Chp5-RECURSIVE-ACTIVITY-SELECTOR.png" style="zoom: 50%;" /><blockquote><p>第$2\thicksim 3$行查找$S_k$中最早结束的活动，循环检查$a_{k+1},a_{k+2},\dots,a_n$，直至找到第一个与$a_k$兼容的活动$a_m$，也即满足$s_m\geq f_k$。</p><p>如果成功找到$m$（也即$m\leq n$），则返回${a_m}$与$RECURSIVE-ACTIVITY-SELECTOR(s,f,m,n)$返回的$S_m$的最大子集的并集。</p><p>如果未成功找到$m$，则说明未找到与$a_k$兼容的活动，则返回$\Phi$。</p></blockquote></blockquote></li><li><p>迭代实现的贪心算法</p><blockquote><p>伪代码如下：</p><img src="Chp5-GREEDY-ACTIVITY-SELECTOR.png" style="zoom:50%;" /><blockquote><p>$k$对应最后一个加入$A$的活动，$f_k$是$A$中活动的最大结束时间，若$m$的开始时间大于$f_k$，则$m$就是下一个被选中的活动。</p><p>算法的运行时间是$O(n)$。</p></blockquote></blockquote></li></ul><h3 id="3-带权活动选择问题"><a href="#3-带权活动选择问题" class="headerlink" title="3.带权活动选择问题"></a>3.带权活动选择问题</h3><h4 id="1-问题描述-8"><a href="#1-问题描述-8" class="headerlink" title="(1)问题描述"></a>(1)问题描述</h4><ul><li>在活动选择问题中，如果每个活动都具有权重$w$，现寻找活动子集$S’$，使得权重和最大</li></ul><h4 id="2-问题分析-4"><a href="#2-问题分析-4" class="headerlink" title="(2)问题分析"></a>(2)问题分析</h4><ul><li>存在重叠子问题，可以使用动态规划求解</li><li>设$p[i]$表示在$a_i$开始前最后结束的活动编号</li><li>设$Rec[i]$表示是否选择问题$i$</li><li>设$D[i]$表示集合${a_1,a_2,a_3,\dots,a_i}$中兼容活动最大权重和</li><li>将活动按照结束时间升序进行排序，则可得到$D[i]&#x3D;max{D[p[i]]+w_i,D[i-1]}$；其中不选择$a_i$时，其最大权重和即为$D[i-1]$，选择$a[i]$时，其最大权重和应为在$a_i$开始前最后结束的活动编号对应的最大权重和加上$w_i$，即$D[p[i]]+w_i$。</li></ul><h4 id="3-动态规划-1"><a href="#3-动态规划-1" class="headerlink" title="(3)动态规划"></a>(3)动态规划</h4><ul><li><p>伪代码如下</p><blockquote><img src="Chp5-带权活动选择问题.png" style="zoom:67%;" /></blockquote></li><li><p>时间复杂度为$O(n\log n)$</p></li></ul><h3 id="4-Huffman-编码"><a href="#4-Huffman-编码" class="headerlink" title="4.$Huffman$编码"></a>4.$Huffman$编码</h3><h4 id="1-基本概念-3"><a href="#1-基本概念-3" class="headerlink" title="(1)基本概念"></a>(1)基本概念</h4><ul><li><p>码字：每个字符用唯一的二进制串表示，称为码字。</p></li><li><p>定长编码：每个字符的编码长度一样。</p><blockquote><p>对于$a\thicksim f$六个字符，应采用3位码字编码，则10万个字符需用30万个二进制位编码。</p></blockquote></li><li><p>变长编码：每个字符赋予不同长度的码字。</p><blockquote><p>赋予高频字符短码字，低频字符长码字，字符的码字互不为前缀，这样才能唯一解码，同时能够提高编码效率。如$a$用1位的串0表示，$b$用3位的串101表示，$f$用4位的串1100表示等。</p></blockquote></li><li><p>前缀码$(Prefix code)$：任何码字都不是其它码字的前缀。</p><blockquote><p>前缀码可以简化解码过程，由于没有码字是其它码字的前缀，所以编码文件的开始部分是没有歧义的，可以唯一地转换回原字符。</p></blockquote></li><li><p>编码树：一种为表示字符二进制编码而构造的二叉树。</p><blockquote><img src="Chp5-赫夫曼编码树-SAMPLE.png" style="zoom:50%;" /><p>叶子结点：对应给定的字符，每个字符对应一个叶子结点。</p><p>编码构造：字符的二进制码字由根结点到该字符叶子结点的简单路径</p><p>路径表示：0代表转向左孩子，1代表转向右孩子</p></blockquote></li><li><p>最优字符编码方案总对应一棵<strong>满二叉树</strong>， 即每个非叶子结点都有两个孩子结点。</p></li></ul><h4 id="2-最优字符编码方案"><a href="#2-最优字符编码方案" class="headerlink" title="(2)最优字符编码方案"></a>(2)最优字符编码方案</h4><ul><li><p>符号表示</p><ul><li><p>设$C$为字母表</p><blockquote><p>对字母表$C$中的任意字符$c$，令属性$c.freq$表示字符$c$在文件中出现的频率</p><p>最优前缀码对应的树中恰好有$|C|$个叶子结点，每个叶子结点对应字母表中的一个字符，且恰有$|C|-1$个内部结点。</p></blockquote></li><li><p>设$T$表示一棵前缀编码树</p></li><li><p>设$d_T(c)$表示c的叶子结点在树T中的深度（根到叶子结点的路径长度）</p><blockquote><p>$d_T(c)$也表示字符$c$的码字长度</p></blockquote></li><li><p>设$B(T)$表示采用$T$编码时的文件编码长度，即$B(T)&#x3D;\sum\limits_{c\in C}c.freq\cdot d_T(c)$，称$B(T)$为T的代价。</p><blockquote><p>使得$B(T)$最小的编码称为最优编码。</p><p>对给定的字符集和文件，$Huffman$编码是一种最优编码。</p></blockquote></li></ul></li></ul><h4 id="3-Huffman-编码"><a href="#3-Huffman-编码" class="headerlink" title="(3)$Huffman$编码"></a>(3)$Huffman$编码</h4><ul><li><p>算法$HUFFMAN$从$|C|$个叶子结点开始，每次选择频率最低的两个结点合并，将得到的新结点加入集合继续合并，这样执行$|C|-1$次<strong>“合并”</strong>后即可构造出一棵编码树——$Huffman$树。</p><blockquote><p>伪代码如下：</p><img src="Chp5-HUFFMAN.png" style="zoom:50%;" /><p>第2行用$C$中字符初始化最小优先队列$Q$；</p><p>第$3\thicksim 8$行的循环反复从队列中合并频率最低的结点$x$和$y$，合并为新结点$z$并替代之；</p><p>经过$n-1$次合并后，最后返回剩下的唯一结点——编码树的根结点</p><p>示例如下：</p><blockquote><img src="Chp5-HUFFMAN-SAMPLE.png" style="zoom: 67%;"/></blockquote></blockquote></li><li><p>时间复杂度的分析</p><ul><li><p>假设$Q$使用最小二叉堆实现，则其初始化花费$O(n)$的时间</p></li><li><p>循环的总代价是$O(n\lg n)$</p><blockquote><p>$for$循环共执行了$n-1$次，每次从堆中找出当前频率最小的两个结 点及把合并得到的新结点插入到堆中均花费$O(\lg n)$，所以循环的总代价是$O(n\lg n)$。</p></blockquote></li><li><p>因此，$HUFFMAN$的总运行时间$O(n\lg n)$</p></li></ul></li><li><p>※$Huffman$算法的正确性</p><ul><li>证明贪心选择性</li><li>证明最优子结构性</li></ul></li></ul><h3 id="5-分数背包问题"><a href="#5-分数背包问题" class="headerlink" title="5.分数背包问题"></a>5.分数背包问题</h3><h4 id="1-问题描述-9"><a href="#1-问题描述-9" class="headerlink" title="(1)问题描述"></a>(1)问题描述</h4><ul><li>已知$n$个物品组成的集合O，每个物品有两个属性$v_i$和$p_i$，分别表示体积和价格；</li><li>背包容量为$C$；</li><li>试求解$S&#x3D;{x_i|1\leq i\leq n,0\leq x_i\leq 1}$，使得$max\sum\limits_{x_i\in S}x_ip_i$且$\sum\limits_{x_i\in S}x_iv_i\leq C$。</li></ul><h4 id="2-问题分析-5"><a href="#2-问题分析-5" class="headerlink" title="(2)问题分析"></a>(2)问题分析</h4><ul><li><p>采用贪心算法，每次选择**最高性价比($p_i&#x2F;v_i$)**的物品，证明可得贪心解不劣于最优解</p></li><li><p>伪代码如下</p><blockquote><p>$FractionalKnapsack(n,p,v,C)$</p><img src="Chp5-FractionlKnapsack.png" style="zoom:67%;" /><p>当背包未装满且商品未装完时填入商品，商品体积不大于容量则全部装入，否则装入部分商品填满背包</p></blockquote></li><li><p>算法复杂度为$O(n\log n)$</p></li></ul><h2 id="六、基本图算法"><a href="#六、基本图算法" class="headerlink" title="六、基本图算法"></a>六、基本图算法</h2><h3 id="1-基本概念-4"><a href="#1-基本概念-4" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><ul><li><p>图的定义</p><p>图可以表示为一个二元组$G&#x3D;&lt;V,E&gt;$</p><blockquote><p>相关术语：</p><p>$V$表示非空顶点集，其元素称为顶点(Vertex) ，$|V|$表示顶点数；</p><p>$E$表示边集，其元素称为边(Edge)，$|E$表示顶点数 ；</p><p>$e&#x3D;(u,v)$表示一条边，其中$u\in V,v\in V,e\in E$；</p><p>相邻$(Adjacent)$：边$(u,v)$连接的顶点$u$和$v$相邻；</p><p>关联$(Incident)$：边$(u,v)$和其连接的顶点$u(或v)$相互关联。</p></blockquote></li><li><p>相关数据结构</p><ul><li>子图：如果$V’\subseteq V,E’\subseteq E$，则称图$G’&#x3D;&lt;V’,E’&gt;$为G的一个子图</li><li>生成子图：如果$V’&#x3D;V,E’\subseteq E$，则称图$G’&#x3D;&lt;V’,E’&gt;$为G的一个生成子图</li><li>树：连通、无环图$T&#x3D;&lt;V_T,E_T&gt;$，树有$|V_T|-1$条边</li><li>森林：一至多棵树组成的无环图</li></ul></li><li><p>图的表示</p><ul><li>邻接表<ul><li>邻接表是一个包含$|V|$条链表的数组$Adj$；</li><li>在$Adj$中，每个结点$u\in V$有一条链表$Adj[u]$，包含所有与结点$u$之间有边相连的结点$v$；</li><li>用$G.Adj[u]$表示结点$u$在邻接表$Adj$中的邻接链表；</li><li>稀疏图一般用邻接表表示；</li><li>可用于表示有向图也可用于表示无向图，空间需求均为$O(V+E)$。</li></ul></li><li>邻接矩阵<ul><li>将图$G$中的结点编号为$1,2,\dots,|V|$，则图$G$的邻接矩阵是一个$|V|\times|V|$的矩阵$A&#x3D;(a_{ij})$；</li><li>当$(i,j)\in E$，$a_{ij}&#x3D;1$；否则$a_{ij}&#x3D;0$；</li><li>稠密图更倾向于用邻接矩阵表示；</li><li>可以快速判断任意两个结点之间是否有边相连，空间需求为$O(V^2)$。</li></ul></li><li>权重图<ul><li>权重值通常以权重函数$\omega:E\to R$给出；</li><li>用邻接表表示权重图：<ul><li>将边$(u,v)\in E$的权重值$ω(u,v)$存放在$u$的邻接链表结点中, 作为其属性。</li></ul></li><li>用邻接矩阵表示权重图：<ul><li>对于边$(u,v)\in E$，令邻接矩阵$A[u][v]&#x3D;ω(u,v)$；</li><li>若$(u,v)$不是$E$中的边，则令$A[u][v]&#x3D;NIL$，或$\infty$、0。</li></ul></li></ul></li></ul></li></ul><h3 id="2-图的搜索与周游"><a href="#2-图的搜索与周游" class="headerlink" title="2.图的搜索与周游"></a>2.图的搜索与周游</h3><h4 id="1-宽度优先搜索与周游"><a href="#1-宽度优先搜索与周游" class="headerlink" title="(1)宽度优先搜索与周游"></a>(1)宽度优先搜索与周游</h4><h5 id="①宽度优先搜索"><a href="#①宽度优先搜索" class="headerlink" title="①宽度优先搜索"></a>①宽度优先搜索</h5><ul><li><p>算法过程描述</p><ul><li>从结点$v$开始，首先访问结点$v$，给$v$标上已访问标记；</li><li>访问邻接于$v$且目前尚未被访问的所有结点，此时结点$v$被检测，而$v$的邻接结点是新的未被检测结点。将这些结点依次放置到一个称为**未检测结点表的队列(Q)**中；</li><li>若未检测结点表为空，则算法终止；</li><li>否则<strong>取Q的表头</strong>作为下一个检测结点，重复上述过程。直到$Q$为空，算法终止。</li></ul></li><li><p>算法伪代码</p><blockquote><img src="Chp6-BFS-1.png"  /><img src="Chp6-BFS-2.png"  /></blockquote></li><li><p>复杂度分析</p><ul><li>空间复杂度：$s(V,E)&#x3D;\Theta(n)$</li><li>采用邻接表的时间复杂度：$t(V,E)&#x3D;O(n+e)$</li><li>采用邻接矩阵的时间复杂度：$t(V,E)&#x3D;O(n^2)$</li></ul></li></ul><h5 id="②宽度优先周游"><a href="#②宽度优先周游" class="headerlink" title="②宽度优先周游"></a>②宽度优先周游</h5><ul><li><p>若$G$是无向连通图或强连通有向图，则一次调用$BFS$即可完成对$G$的周游。否则，需要多次调用$BFS$</p></li><li><p>算法伪代码</p><blockquote><img src="Chp6-BFT.png" style="zoom:67%;" /></blockquote></li></ul><h5 id="③宽度优先生成树"><a href="#③宽度优先生成树" class="headerlink" title="③宽度优先生成树"></a>③宽度优先生成树</h5><ul><li><p>向前边：$BFS$中由$u$到达未访问结点$w$的边$(u,w)$称为向前边。 </p></li><li><p>宽度优先生成树： 记$T$是$BFS$中处理的所有向前边集合。若$G$是<strong>连通图</strong>，则$BFS$终止时，$T$构成一棵生成树，称为图$G$的宽度优先生成树。</p></li><li><p>对于图$G&#x3D;(V,E)$和源结点$s$，定义图$G$的<strong>前驱子图</strong>为$G_\pi&#x3D;(V_\pi,E_\pi)$，其中$V_\pi&#x3D;{v\in V:v.\pi\ne NIL}\cup{s}$，$E_\pi&#x3D;{(v.\pi,v):v\in V_\pi-{s}}$。该前驱子图构成一棵广度优先树。</p><blockquote><img src="Chp6-BFS-PRINT-PATH.png" style="zoom:67%;" /></blockquote></li></ul><h4 id="2-深度优先搜索与周游"><a href="#2-深度优先搜索与周游" class="headerlink" title="(2)深度优先搜索与周游"></a>(2)深度优先搜索与周游</h4><h5 id="①深度优先搜索"><a href="#①深度优先搜索" class="headerlink" title="①深度优先搜索"></a>①深度优先搜索</h5><ul><li><p>算法过程描述</p><ul><li>从结点$v$开始，首先访问$v$， 给$v$标上已访问标记；</li><li>然后中止对$v$的检测，并从邻接于$v$且尚未被访问的结点的中找出一个结点$w$开始新的检测；</li><li>在$w$被检测后，再恢复对$v$的检测。当所有可到达的结点全部被检测完毕后，算法终止</li></ul></li><li><p>算法伪代码</p><blockquote><img src="Chp6-DFS.png" style="zoom: 67%;" /></blockquote></li><li><p>复杂度分析</p><ul><li>运行时间为$\Theta(V+E)$</li></ul></li></ul><h5 id="②深度优先周游"><a href="#②深度优先周游" class="headerlink" title="②深度优先周游"></a>②深度优先周游</h5><ul><li><p>算法伪代码</p><blockquote><img src="Chp6-DFT.png" style="zoom: 50%;" /></blockquote></li></ul><h4 id="3-深度检索"><a href="#3-深度检索" class="headerlink" title="(3)深度检索"></a>(3)深度检索</h4><ul><li>改造$BFS$算法，用<strong>栈</strong>来保存未被检测的结点</li></ul><h3 id="3-回溯法"><a href="#3-回溯法" class="headerlink" title="3.回溯法"></a>3.回溯法</h3><h4 id="1-n-皇后问题"><a href="#1-n-皇后问题" class="headerlink" title="(1)$n$-皇后问题"></a>(1)$n$-皇后问题</h4><h4 id="2-子集和问题"><a href="#2-子集和问题" class="headerlink" title="(2)子集和问题"></a>(2)子集和问题</h4><h3 id="4-分支-限界法"><a href="#4-分支-限界法" class="headerlink" title="4.分支-限界法"></a>4.分支-限界法</h3><h4 id="1-n-皇后问题-1"><a href="#1-n-皇后问题-1" class="headerlink" title="(1)$n$-皇后问题"></a>(1)$n$-皇后问题</h4><h4 id="2-子集和问题-1"><a href="#2-子集和问题-1" class="headerlink" title="(2)子集和问题"></a>(2)子集和问题</h4><h2 id="七、最小生成树"><a href="#七、最小生成树" class="headerlink" title="七、最小生成树"></a>七、最小生成树</h2><h3 id="1-问题背景"><a href="#1-问题背景" class="headerlink" title="1.问题背景"></a>1.问题背景</h3><ul><li>生成树**(Spanning Tree)** <ul><li>图$T’&#x3D;&lt;V’,E’&gt;$是无向图$G&lt;V,E,W&gt;$的一个生成子图，并且是连通、无环路的(树)</li><li>权重最小的生成树可能不唯一</li></ul></li></ul><h3 id="2-通用框架"><a href="#2-通用框架" class="headerlink" title="2.通用框架"></a>2.通用框架</h3><ul><li><p>新建一个空边集$A$，边集$A$可逐步扩展为最小生成树</p></li><li><p>每次向边集$A$中新增加一条边，需保证边集$A$仍是一个无环图，且仍是最小生成树的子集</p><blockquote><p>$A$是某棵最小生成树$T$边的子集，$A\subseteq T$；</p><p>$A\cup{(u,v}$仍是$T$边的一个子集，则称$(u,v)$是$A$的安全边。</p><p>若每次向边集$A$中新增安全边，可保证边集$A$是最小生成树的子集</p></blockquote></li><li><p>$Generic-MST(G)$</p><blockquote><img src="Chp7-GENERIC-MST.png" style="zoom:50%;" /></blockquote></li><li><p>为了有效辨识安全边，给出以下定义</p><blockquote><p>割：对于连通无向图$G&#x3D;&lt;V,E&gt;$，<strong>割</strong>$(S,V-S)$将顶点集$V$划分为两部分</p><p>给定割$(S,V-S)$和边$(u,v)$，$u\in S,v\in V-S$，称边$(u,v)$<strong>横跨</strong>割$(S,V-S)$</p><p>轻边：横跨割的所有边中，<strong>权重最小</strong>的称为横跨这个割的一条轻边</p><p>如果一个边集$A$中<strong>没有边横跨某割</strong>，则称该割不妨害边集$A$</p></blockquote></li><li><p>安全边辨识定理</p><blockquote><p>给定图$G&#x3D;&lt;V,E&gt;$是一个带权的连通无向图，令$A$为边集$E$的一个子集，且$A$包含在图$G$的某棵最小生成树中。若割$(S,V-S)$是图$G$中不妨害边集$A$的任意割，且$(u,v)$是横跨该割的轻边，则对于边集$A$，边$(u,v)$是其安全边。</p><img src="Chp6-安全边辨识定理.png" style="zoom: 50%;" /><img src="Chp6-安全边辨识定理推论.png" style="zoom: 50%;" /></blockquote></li><li><p>在算法推进的过程中，集合$A$始终保持无环状态；算法执行的任意时刻，图$G_A&#x3D;(V,A)$是一个森林。对于安全边$(u,v)$，由于$A\cup{(u,v)}$必须无环，所以 $(u,v) $连接的是$G_A$中的两个不同连通分量。</p></li></ul><h3 id="3-Prim-算法"><a href="#3-Prim-算法" class="headerlink" title="3.$Prim$算法"></a>3.$Prim$算法</h3><p>贪心策略：集合$A$始终是<strong>一棵树</strong>，每次加入到$A$中的安全边是连接$A$和$A$之外某个结点的边中权重最小的边。</p><ul><li><p><strong>采用的数据结构：最小优先队列</strong>。</p></li><li><p>步骤1：选择任意一个顶点，作为生成树的起始顶点</p></li><li><p>步骤2：保持边集$A$始终为一棵树，选择割$(V_A,V-V_A)$</p></li><li><p>步骤3：选择横跨割$(V_A,V-V_A)$的轻边，添加到边集$A$中</p></li><li><p>步骤4：重复步骤2和步骤3，直至覆盖所有顶点</p></li><li><p>伪代码：</p><blockquote><img src="Chp6-MST-PRIM.png" style="zoom:67%;" /><p>第$1\thicksim 5$行将每个结点的$key$值设为$\infty$（除了根节点$r$的$key$值为0，以便其为第一个被处理的结点），将每个结点的父节点设为$NIL$，并对最小优先队列$Q$进行初始化；</p><p>在每遍$while$循环前，有</p><ul><li>$A&#x3D;{(v,v.\pi):v\in V-{r}-Q}$</li><li>已经加入到最小生成树的结点为集合$V-Q$</li><li>对于所有结点$v\in Q$，如果$v.\pi\ne NIL$，则$v.key&lt;\infty$且$v.key$是连接结点$v$和最小生成树中某个结点的轻边$(v,v.\pi)$的权重。</li></ul><p>第7行找出结点$u\in Q$，该结点是某条横跨割$(V-Q,Q)$的轻边的一个端点，将$u$从$Q$中删除并将$(u,u.\pi)$加入集合$A$中；</p><p>$for$循环对与$u$相邻却不在树中的结点$v$的属性进行更新。</p></blockquote></li><li><p>优先队列</p><ul><li><p>采用二叉堆实现</p></li><li><p><strong>队列中每个元素有一个关键字，依据关键字大小离开队列</strong></p></li></ul></li></ul><table><thead><tr><th align="center">算法</th><th align="center">说明</th><th align="center">时间复杂度</th></tr></thead><tbody><tr><td align="center">$INSERT()$</td><td align="center">向优先队列中插入元素</td><td align="center">$O(\log n)$</td></tr><tr><td align="center">$EXTRACT-MIN(Q)$</td><td align="center">移除优先队列中的最小元素</td><td align="center">$O(\log n)$</td></tr><tr><td align="center">$DECREASE-KEY(u,u.d)$</td><td align="center">更新距离数组，调整优先队列</td><td align="center">$O(\log n)$</td></tr></tbody></table><ul><li><p>算法复杂度</p><ul><li>算法运行时间取决于$Q$的实现方式，如果实现为二叉最小优先队列，则可以使用$BUILD-MIN-HEAP$执行第$1\thicksim 5$行，时间成本为$O(V)$；</li><li>$while$循环一共执行$|V|$次，$EXTRACT-MIN$需要时间成本为$O(\lg V)$，$for$循环执行次数为$O(E)$，第11行隐藏$DECREASE-KEY$操作，在二叉最小堆上执行时间成本为$O(\lg V)$；</li><li>总成本为$O(E\lg V)$。</li></ul></li></ul><h3 id="4-Kruskal-算法"><a href="#4-Kruskal-算法" class="headerlink" title="4.$Kruskal$算法"></a>4.$Kruskal$算法</h3><p>贪心策略：集合$A$始终是<strong>一个森林</strong>，开始时，其结点集就是$G$的结点集，并且$A$是所有单节点树构成的森林。之后每次加入到集合$A$中的安全边是$G$中连接$A$的两个不同分量的权重最小的边。</p><ul><li><p><strong>采用的数据结构：不相交集合</strong>。</p></li><li><p>伪代码：</p><blockquote><img src="Chp6-MST-KRUSKAL.png" style="zoom: 75%;" /><p>第$1\thicksim 3$行将$A$初始化为空集，并创建$|V|$棵树，每棵树只包含一个结点；</p><p>第$5\thicksim 8$行的$for$循环按照权重从低到高的次序对每条边进行检查，如果不在同一棵树中，则加入到集合$A$中，并将两棵树的结点进行合并。</p><p>证明算法保证选择的边为安全边：</p><img src="Chp6-MST-KRUSKAL-安全边证明.png" style="zoom:50%;" /></blockquote></li><li><p>不相交集合</p><ul><li><p>$MAKE-SET(v)$</p><ul><li><p>初始化集合：创建根结点，并设置一条指向自身的边</p></li><li><p>时间复杂度为$O(1)$</p></li><li><p>&#96;&#96;&#96;pseudocode<br>x.parent&#x3D;x<br>return x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- $FIND-SET(v)$</span><br><span class="line"></span><br><span class="line">  - 判定顶点是否在同一集合：回溯查找树根，检查树根是否相同</span><br><span class="line"></span><br><span class="line">  - 时间复杂度为$O(h)$，且$|V|\geq 2^h$，则为$O(\log |V|)$</span><br><span class="line"></span><br><span class="line">  - ```pseudocode</span><br><span class="line">    while x.parent ≠ x do</span><br><span class="line">    x=x.parent</span><br><span class="line">    end</span><br><span class="line">    return x</span><br></pre></td></tr></table></figure></li></ul></li><li><p>$UNION(u,v)$</p><ul><li><p>合并两棵树</p></li><li><p>时间复杂度为$O(h)$，且$|V|\geq 2^h$，则为$O(\log |V|)$</p></li><li><pre><code class="pseudocode">a=FIND-SET(x)b=FIND-SET(y)if a.height ≤ b.height then    if a.height = b.height then        b.height=b.height+1    end    a.parent=bendelse    b.parent=aend</code></pre></li></ul></li></ul></li><li><p>算法复杂度</p><ul><li>将边按照权重升序排序的时间成本为$O(E\log E)$；</li><li>建立不相交集合的时间成本为$O(V)$；</li><li>$while$循环进行了$|E|$次，内部时间复杂度为$O(\log V)$，也即$while$循环总时间复杂度为$O(E\log V)$；</li><li>假设$E&#x3D;O(V^2)$，则总成本为$O(E\lg V)$。</li></ul></li></ul><h3 id="5-算法对比"><a href="#5-算法对比" class="headerlink" title="5.算法对比"></a>5.算法对比</h3><table><thead><tr><th align="center"></th><th align="center">Prim算法</th><th align="center">Kruskal算法</th></tr></thead><tbody><tr><td align="center">核心思想</td><td align="center">保持一颗树，不断扩展</td><td align="center">子树森林，合并为一棵树</td></tr><tr><td align="center">数据结构</td><td align="center">优先队列</td><td align="center">不相交集合</td></tr><tr><td align="center">求解视角</td><td align="center">微观视角，基于当前点选边</td><td align="center">宏观视角，基于全局顺序选边</td></tr><tr><td align="center">算法策略</td><td align="center">采用贪心策略的图算法</td><td align="center">采用贪心策略的图算法</td></tr></tbody></table><h2 id="八、单源点最短路问题"><a href="#八、单源点最短路问题" class="headerlink" title="八、单源点最短路问题"></a>八、单源点最短路问题</h2><h3 id="1-问题背景-1"><a href="#1-问题背景-1" class="headerlink" title="1.问题背景"></a>1.问题背景</h3><p>给定一个带权重的有向图$G&#x3D;(V,E)$和权重函数$\omega:E\rightarrow R$。图中一条路径$p$的权重$\omega(p)$是构成该路径的所有边的权重之和。从结点$u$到结点$v$的最短路径权重定义为$\delta(u,v)$，当没有从$u$到$v$的路径时，$\delta(u,v)&#x3D;\infty$。</p><p>试找出从给定的源点$s\in V$到其他每个结点$v\in V$的最短路径及其最短路径。</p><ul><li><p>单源点最短路问题(单目的地最短路径问题，单节点对最短路径问题)，所有结点对最短路径问题</p></li><li><p>最优子结构性质：两个结点之间的最短路径的任何子路径都是最短的。</p></li><li><p><strong>松弛操作</strong></p><blockquote><p>对于每个结点$v$，维持一个属性$v.d$，记录从源点$s$到结点$v$的最短路径权重的上界。称$v.d$为$s$到$v$的最短路径估计。$INITIALIZE-SINGLE-SOURCE$过程中，对所有$v\in V-{s}$有，$v.d&#x3D;\infty$，$s.d&#x3D;0$。</p><p>松弛操作中，首先进行测试(对$s$到$v$所经过的最后一个中间结点$u$，比较$v.d$和$u.d+w(u,v)$的值)，如果可以<strong>改善</strong>，则更新$v.d$和$v.\pi$。</p><img src="Chp8-RELAX.png"  /><p>时间复杂度为$O(1)$</p></blockquote></li><li><p><strong>松弛操作的性质</strong></p><blockquote><p>三角不等式性质：$\delta(s,v)\leq\delta(s,u)+\omega(u,v)$</p><p>上界性质：$v.d$是$s$到$v$的最短路径权重$\delta(s,v)$的上界</p><p>非路径性质：假定从源结点$s$到给定点$v$之间不存在路径，则该图在由算法$INITIALIZE-SINGLE-SOURCE(G,s)$进行初始化后，有$v.d\geq \delta(s,v)&#x3D;\infty$， 并且该等式作为不变式一直维持到图$G$的所有松弛操作结束。</p></blockquote></li><li><p>若源点$s$无可达负环，则存在源点$s$的单源最短路径(如果有可达负环，则总有更小距离，最终可以松弛到$-\infty$)</p></li></ul><h3 id="2-Bellman-Ford-算法"><a href="#2-Bellman-Ford-算法" class="headerlink" title="2.$Bellman-Ford$算法"></a>2.$Bellman-Ford$算法</h3><ul><li><p>给定带权图$G&#x3D;&lt;V,E,W&gt;$和源点编号$s$，找到源点$s$到所有其他顶点$t$的最短距离$\delta(s,t)$和最短路径$&lt;s,\dots,t&gt;$或存在源点$s$可达的负环。</p></li><li><p>解决挑战1：图中存在负权边时，如何求解单源最短路径? </p><ul><li>每轮对所有边进行松弛，持续迭代$|V|-1$轮。</li></ul></li><li><p>解决挑战2：图中存在负权边时，如何发现源点可达负环?</p><ul><li>若第$|V|$轮仍松弛成功，存在源点$s$可达的负环。</li></ul></li><li><p>伪代码如下</p><blockquote><img src="Chp8-BELLMAN-FORD.png"  /><p>第1行对所有结点的值进行初始化——$\Theta(V)$；</p><p>第$2\thicksim 4$行对每条边进行$|V|-1$次松弛处理，每次循环中都对每条边进行一次松弛操作——$\Theta(E)$，共进行$|V|-1$次循环，总的时间复杂度为$\Theta(VE)$；</p><p>第$5\thicksim 8$行检查图中是否存在权重为负值的环路并返回检查结果——$\O(E)$；</p><p><strong>总的运行时间为$O(VE)$。</strong></p></blockquote></li><li><p>证明在<strong>无可达负环</strong>的情况下可以正确计算最短路径权重</p><blockquote><p>设$G&#x3D;(V,E)$为一个带权重的源点为$s$的有向图，其权重函数为$\omega:E\rightarrow R$，并假定图$G$中<strong>不包含</strong>从源结点$s$可以到达的权重为负值的环路。则$Bellman-ford$算法的第$2\thicksim 4$行的$for$循环在执行$|V|-1$次 之后，对于所有从源结点$s$可以到达的结点$v$有$v.d&#x3D;\delta(s,v)$。</p><p>证明：<strong>利用路径松弛性质</strong>。</p><p>设$G&#x3D;(V,E)$为一个带权重的源点为$s$的有向图，其权重函数为$\omega:E\rightarrow R$，并假定图$G$中<strong>不包含</strong>从源结点$s$可以到达的权重为负值的环路。则对于所有结点$v\in V$，存在一条从源结点$s$到结点$v$的路径当且仅当$BELLMAN-FORD$算法终止时有$v.d&lt;\infty$。</p></blockquote></li><li><p>证明在<strong>有可达负环</strong>的情况下可以返回FALSE值，否则返回TRUE值</p><blockquote><p>假设不包含可达负环时，可以得到$G_\pi$为一棵最短路径树，则当算法终止时，对于所有边$(u,v)\in E$，有$v.d&#x3D;\delta(s,v)\leq \delta(s,u)+\omega(u,v)&#x3D;u.d+\omega(u,v)$，因此返回TRUE；</p><p>假设包含可达负环时，设该环路为$c&#x3D;&lt;v_0,v_1,\dots,v_k&gt;$，其中$v_0&#x3D;v_k$，则有$\sum\limits_{i&#x3D;1}^{k}\omega(v_{i-1},v_i)&lt;0$，假设返回TRUE值，则有$v_i.d\leq v_{i-1}.d+\omega(v_{i-1},v_i)$，这里$i&#x3D;1,2,\dots,k$。将所有不等式相加得到$\sum\limits_{i&#x3D;1}^{k}v_i.d\leq \sum\limits_{i&#x3D;1}^{k}(v_{i-1}.d+\omega(v_{i-1},v_i))&#x3D;\sum\limits_{i&#x3D;1}^{k}v_{i-1}.d+\sum\limits_{i&#x3D;1}^{k}\omega(v_{i-1},v_i)$，而$v_0&#x3D;v_k$，则得到$\sum\limits_{i&#x3D;1}^{k}v_i.d&#x3D;\sum\limits_{i&#x3D;1}^{k}v_{i-1}.d$，又有$\sum\limits_{i&#x3D;1}^{k}\omega(v_{i-1},v_i)\geq 0$，二者矛盾，得证。</p></blockquote></li></ul><h3 id="3-Dijkstra-算法"><a href="#3-Dijkstra-算法" class="headerlink" title="3.$Dijkstra$算法"></a>3.$Dijkstra$算法</h3><ul><li><p>给定带权图$G&#x3D;&lt;V,E,W&gt;$（所有边的权重为正值）和源点编号$s$，找到源点$s$到所有其他顶点$t$的最短距离$\delta(s,t)$和最短路径$&lt;s,\dots,t&gt;$。</p></li><li><p>算法从结点集$V-S$中选择当前最短路径估计最小的结点$u$，将$u$从$Q$中删除，并加入到$S$中，$u.d$就是源结点$s$到$u$的最短路径的 长度。这里$Q$是一个最小优先队列，保存结点集$V-S$。</p></li><li><p>伪代码如下：</p><blockquote><img src="Chp8-DIJKSTRA.png" style="zoom:80%;" /><p>$while$循环执行次数为$|V|$次，$for$循环执行$|E|$次（也即松弛操作次数）。</p></blockquote></li><li><p>证明算法的正确性</p><blockquote><p>采用反证法，假设顶点$u$被添加到$V_A$时，$u.d\ne \delta(s,u)$，而由上界性质有$u.d&gt; \delta(s,u)$。</p><p>应存在一条长度为$\delta(s,u)$的最短路径，设最短路径为$&lt;s,\dots,x,y,\dots,u&gt;$，其中$(x,y)$横跨割$&lt;S,V-S&gt;$，$x\in S$，$y\in V-S$；将$x$加入$S$时，有$x.d&#x3D;\delta(s,x)$，因此$(x,y)$将被松弛，由于$y$是最短路径$p$上的结点，因此有$\delta(s,y)&#x3D;\delta(s,x)+\omega(x,y)&#x3D;x.d+\omega(x,y)$，$y.d\leq x.d+\omega(x,y)$，得到$y.d&#x3D;\delta(s,y)$，因此有$u.d&gt;\delta(s,u)\geq \delta(s,y)&#x3D;y.d$，显然$u$不是下一个被添加结点，矛盾，得证。</p></blockquote></li><li><p>时间复杂度分析</p><ul><li>总运行时间依赖于$Q$的实现，采用二叉堆实现时，每次找到结点$u$需要$O(\lg V)$的时间，总运行时间为$O((V+E)\lg V)$。</li></ul></li></ul><h3 id="4-算法对比"><a href="#4-算法对比" class="headerlink" title="4.算法对比"></a>4.算法对比</h3><table><thead><tr><th align="center"></th><th align="center">广度优先搜索</th><th align="center">Dijkstra算法</th><th align="center">Bellman-Ford算法</th></tr></thead><tbody><tr><td align="center">适用范围</td><td align="center">无权图</td><td align="center">带权图（所有边权重为正）</td><td align="center">带权图</td></tr><tr><td align="center">松弛次数</td><td align="center">——</td><td align="center">$</td><td align="center">E</td></tr><tr><td align="center">数据结构</td><td align="center">队列</td><td align="center">优先队列</td><td align="center">——</td></tr><tr><td align="center">运行时间</td><td align="center">$O(</td><td align="center">V</td><td align="center">+</td></tr></tbody></table><h3 id="5-差分约束系统"><a href="#5-差分约束系统" class="headerlink" title="5.差分约束系统"></a>5.差分约束系统</h3><ul><li><p>线性规划：给定一个$m\times m$的矩阵$A$、一个$m$维的向量$b$和一个$n$维的向量$c$。试找一$n$维向量$x$，使得在$Ax\leq b$的约束下，目标函数$\sum\limits_{i&#x3D;1}^{n}{c_ix_i}$最大。</p></li><li><p>差分约束系统：矩阵$A$的每一行包括一个1和一个-1，其他所有项均为0。则上述问题转化为$m$个涉及$n$个变量的差额限制条件，每个约束条件均为简单的线性不等关系：$x_j-x_i\leq b_k$，这里$1\leq i,j\leq n,i\ne j,1\leq k\leq m$。</p></li><li><p>解的线性性</p><blockquote><p>$x&#x3D;(x_1,x_2,\dots,x_n)$为解，则$x+d&#x3D;(x_1+d,x_2+d,\dots,x_n+d)$也为解；</p></blockquote></li><li><p>约束图</p><blockquote><img src="Chp6-约束图.png" style="zoom: 80%;" /><p>引入额外结点$v_0$，从其出发可到达任何结点，因此节点集合$V$为${v_0,v_1,\dots,v_n}$</p><p>边集合$E$包含代表每个差分约束的边，同时包含$v_0$到其他所有结点的边$(v_0,v_i)$</p><p>如果$x_j-x_i\leq b_k$是一个差分约束条件，则边$(v_i,v_j)$的权重记为$\omega(v_i,v_j)&#x3D;b_k$，而从$v_0$出发到其他结点的边的权重$\omega(v_0,v_j)&#x3D;0$。</p><img src="Chp6-约束图-SAMPLE.png" style="zoom:67%;" /></blockquote></li><li><p>问题的转换</p></li></ul><p>给定差分约束系统$Ax\leq b$，设$G&#x3D;(V,E)$是该差分约束系统所对应的约束图。如果图$G$不包含权重为负值的回路，则$x&#x3D;(\delta(v_0,v_1),\delta(v_0,v_2),\delta(v_0,v_3),\dots,\delta(v_0,v_n))$是该系统的一个可行解。如果图$G$包含权重为负值的回路，则该系统没有可行解。</p><p><img src="/2022/08/19/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0/Chp6-%E7%BA%A6%E6%9D%9F%E5%9B%BE%E8%AF%81%E6%98%8E.png"></p><p>设未知变量的个数$n&#x3D;|x_i|$，不等式个数为m。则使用$Bellman-Ford$算法时，顶点数为$n+1$，边数为$m+n$，因此可以在$O(n^2+mn)$的时间内完成求解。</p><h2 id="九、所有结点对的最短路径问题"><a href="#九、所有结点对的最短路径问题" class="headerlink" title="九、所有结点对的最短路径问题"></a>九、所有结点对的最短路径问题</h2><h3 id="1-问题背景-2"><a href="#1-问题背景-2" class="headerlink" title="1.问题背景"></a>1.问题背景</h3><p>给定一个带权重的有向图$G&#x3D;(V,E)$和权重函数$\omega:E\rightarrow R$。图中一条路径$p$的权重$\omega(p)$是构成该路径的所有边的权重之和。从结点$u$到结点$v$的最短路径权重定义为$\delta(u,v)$，当没有从$u$到$v$的路径时，$\delta(u,v)&#x3D;\infty$。</p><p>求$\forall u,v\in V$，从$u$到$v$的最短路径。</p><h3 id="2-问题分析-6"><a href="#2-问题分析-6" class="headerlink" title="2.问题分析"></a>2.问题分析</h3><ul><li><p>直观上，可以使用$Dijkstra$算法依次求解所有点，此时存在重叠子问题；</p></li><li><p>使用$Dijkstra$算法依次求解所有点的算法复杂度为$O(|V||E|\log|V|)$，对于稠密图有$|E|&#x3D;O(|V|^2)$，因此算法复杂度为$O(|V|^3\log|V|)$；</p></li><li><p>而观察松弛过程发现，具有最优子结构性：</p></li></ul><img src="Chp9-最优子结构示意图.png" style="zoom:50%;" /><ul><li><p>设$D[k,i,j]$表示：可从前$k$个点选点经过时，$i$到$j$的最短距离，则原始问题为$D[|V|,i,j]$</p><blockquote><p>如果不选第$k$个点经过，则$D[k,i,j]&#x3D;D[k-1,i,j]$；</p><p>如果选则第$k$个点经过，则$D[k,i,j]&#x3D;D[k-1,i,k]+D[k-1,k,j]$；</p><p>因此，$D[k,i,j]&#x3D;min{D[k-1,i,k]+D[k-1,k,j],D[k-1,i,j]}$</p></blockquote></li></ul><h3 id="3-自底向上的-Floyd-Warshall-算法"><a href="#3-自底向上的-Floyd-Warshall-算法" class="headerlink" title="3.自底向上的$Floyd-Warshall$算法"></a>3.自底向上的$Floyd-Warshall$算法</h3><ul><li><p>初始化数组</p><ul><li>$D[0,i,i]&#x3D;0$：起点和终点重合，路径长度为0</li><li>$D[0,i,j]&#x3D;e[i,j]$：任意两点直达距离为边权</li></ul></li><li><p>自底向上计算</p><ul><li>按$k$增加的顺序计算，求解时当前层只依赖上一层</li><li>只需要两层表格——待计算和上一次结果</li><li>当**$k&#x3D;i或k&#x3D;j$**时，$D[k,i,j]&#x3D;D[k-1,i,j]$，可以直接覆盖；</li><li>当**$k\ne i且k\ne j$<strong>时，$D[k-1,i,k]+D[k-1,k,j]$和$D[k-1,i,j]$不是相同子问题，当求出$D[k,i,j]$后，$D[k-1,i,j]$不再被使用，可直接覆盖——</strong>求出新值可直接在原位置覆盖，只需存储一层表格**；</li></ul></li><li><p>构建最优解</p><ul><li><p>使用前驱结点矩阵记录经过的中间点，此处使用追踪数组$Rec$记录经过的中间点</p><blockquote><p>$D_k[i,j]&#x3D;D_{k-1}[i,j]$时$Rec$记录为0，表示没有中间点</p><p>$D[k,i,j]&#x3D;D[k-1,i,k]+D[k-1,k,j]$时$Rec$记录为$k$，表示经过中间点$k$</p></blockquote></li></ul></li><li><p>伪代码如下：</p><blockquote><p>$All-Pairs-Shortest-Paths$：</p><img src="Chp9-ALL-PAIRS-SHORTEST-PATHS-1.png" style="zoom: 33%;" /><p>初始化数组$D$和$Rec$；</p><img src="Chp9-ALL-PAIRS-SHORTEST-PATHS-2.png" style="zoom: 33%;" /><p>按照$k$增大的顺序，对于任意一对$i,j$，进行松弛操作，并更新相关数组。</p><p>$Find-Path$：</p><img src="Chp9-FIND-PATH.png" style="zoom:50%;" /></blockquote></li><li><p>算法复杂度为$O(|V|^3)$</p></li></ul><h3 id="4-最短路径算法小结"><a href="#4-最短路径算法小结" class="headerlink" title="4.最短路径算法小结"></a>4.最短路径算法小结</h3><img src="Chp9-最短路径算法小结.png" style="zoom: 80%;" /><h2 id="十、最大流"><a href="#十、最大流" class="headerlink" title="十、最大流"></a>十、最大流</h2><h3 id="1-最大二分匹配"><a href="#1-最大二分匹配" class="headerlink" title="1.最大二分匹配"></a>1.最大二分匹配</h3><h4 id="1-问题描述-10"><a href="#1-问题描述-10" class="headerlink" title="(1)问题描述"></a>(1)问题描述</h4><ul><li><p>给定一个无向图$G&#x3D;&lt;V,E&gt;$，其中$V&#x3D;L\cup R,L\cap R&#x3D;\Phi$，并且每条边$e\in E$有一个端点在$L$中而另一个端点在$R$中，可记为二分图$G&#x3D;&lt;L,R,E&gt;$。</p></li><li><p>图$G&#x3D;&lt;V,E&gt;$中的一个匹配$M$是图$G$边集$E$的子集$(M\subseteq E)$，其中每个顶点至多关联$M$的一条边。</p></li><li><p>现给定二分图$G&#x3D;&lt;L,R,E&gt;$，求出匹配$M&#x3D;{e_1,e_2,\dots,e_k}$，使得$max|M|$，满足$\forall i,j(i\ne j),e_i&#x3D;(l_i,r_i),e_j&#x3D;(l_j,r_j)$，有$l_i\ne l_j$且$r_i\ne r_j$。</p><blockquote><p>即使得匹配数最大且每个顶点至多关联一条边。</p></blockquote></li></ul><h4 id="2-问题分析-7"><a href="#2-问题分析-7" class="headerlink" title="(2)问题分析"></a>(2)问题分析</h4><ul><li><p>直观上，可以遍历$L$中的顶点，依次检查之并与$R$中顶点进行匹配，这种策略可能达不到最大匹配，需要通过撤销边和连接边来增广原匹配。</p></li><li><p>定义<strong>交替路径</strong>：从未匹配顶点出发，依次经过<strong>“非匹配边、匹配边…非匹配边”</strong>形成的路径</p><blockquote><img src="Chp10-交替路径举例.png" style="zoom:67%;" /></blockquote></li><li><p>不断寻找交替路径进行增广</p><ul><li>依次检测左侧顶点，若相邻顶点<strong>未匹配</strong>，则构成交替路径，<strong>直接进行匹配</strong>；若相邻顶点<strong>已经匹配</strong>，则尝试寻找交替路径，<strong>增广成新匹配</strong>；</li><li>直至所有左侧顶点检测完后结束。</li></ul></li><li><p>辅助数组</p><ul><li><p>$matched$表示$L$与$R$中顶点的匹配关系</p><blockquote><p>以$R$中顶点作为下标，如$match[R_2]\leftarrow L_1$</p></blockquote></li><li><p>$color$表示深度优先搜索辅助数组</p><ul><li>white表示未被搜索过，black已被搜索过</li><li>每次搜索前初始化$color$数组</li></ul></li></ul></li></ul><h4 id="3-匈牙利算法"><a href="#3-匈牙利算法" class="headerlink" title="(3)匈牙利算法"></a>(3)匈牙利算法</h4><ul><li><p>伪代码如下：</p><blockquote><p>$Hungarian(G)$</p><img src="Chp10-Hungarian.png" style="zoom: 50%;" /><p>$DFS-Find(v)$</p><img src="Chp10-DFS-Find.png" style="zoom:49%;" /></blockquote></li><li><p>正确性证明：</p><ul><li>命题1：匈牙利算法得到的匹配$M$无交替路径</li><li>命题2：匹配$M$无交替路径$\Leftrightarrow$匹配$M$是最大匹配</li></ul></li></ul><h3 id="2-最大流算法"><a href="#2-最大流算法" class="headerlink" title="2.最大流算法"></a>2.最大流算法</h3><h4 id="1-问题描述-11"><a href="#1-问题描述-11" class="headerlink" title="(1)问题描述"></a>(1)问题描述</h4><ul><li><p>给定有向图$G&#x3D;&lt;V,E,C&gt;$，称之为流网络，$C$代表边权。</p><ul><li><p>源点为$s$，汇点为$t$</p></li><li><p>容量：每条边的边权$c(e)\geq 0$</p></li><li><p>流量：每条边的被占有容量$f(e)\geq 0$</p></li><li><p>剩余容量：对于每条边，剩余容量为$c(e)-f(e)$</p></li><li><p>总流量&#x3D;源点流出量&#x3D;汇点流入量：$|f|&#x3D;\sum_{e\ out\ of\ s}f(e)&#x3D;\sum_{e\ in\ to\ t}f(e)$</p></li><li><p>容量限制：对于边$e\in E$，有$0\leq f(e)\leq c(e)$</p><blockquote><p>边上的流量不应超过边上的容量</p></blockquote></li><li><p>流量守恒：对顶点$v\in V-{s,t}$，$\sum_{e\ out\ of\ s}f(e)&#x3D;\sum_{e\ in\ to\ t}f(e)$</p><blockquote><p>进入某顶点$v$流量和等于流出此顶点流量和</p></blockquote></li></ul></li><li><p>现根据有向图$G&#x3D;&lt;V,E,C&gt;$，源点$s$，汇点$t$，在满足容量限制和流量守恒的约束条件下，求出最大流量。</p></li></ul><h4 id="2-直观策略"><a href="#2-直观策略" class="headerlink" title="(2)直观策略"></a>(2)直观策略</h4><ul><li><p>算法思想</p><ul><li>对于所有边$e\in E$，初始化流量为$f(e)&#x3D;0$</li><li>寻找一条$s$到$t$的路径$P$，此路径上每条边$e$均满足$f(e)&lt;c(e)$</li><li>按路径$P$上的最小剩余容量增加路径流量</li><li>迭代寻找路径$P$直至无法增加路径流量</li></ul></li><li><p><strong>此方法可能无法达到最大流量</strong></p></li><li><p><strong>不足之处：只能扩充边的流量，不能缩减边的流量</strong></p></li><li><p>如果允许缩减边上的容量 ，则可以进一步增大总流量$\rightarrow$如果寻找路径时允许逆向搜索，可以增大总流量$\rightarrow$引入反向边，实现逆向搜索</p></li><li><p>残存网络</p><ul><li><p>定义反向边权重：可缩减流量的上限，也即原始边上的流量$f(e)$</p></li><li><p>定义正向边权重：可扩充流量的上限，也即原始边上的剩余容量$c(e)-f(e)$</p></li><li><p>则根据流网络$G&#x3D;&lt;V,E,C&gt;$和流量$f$，可得残存网络$G_f&#x3D;&lt;V,E_f&gt;$，其中每条边的残存容量满足上述规则</p></li><li><p>定义增广路径：增广路径$p$是残存网络$G_f$中一条从源点$s$到汇点$t$的简单路径(路径上的各顶点均不互相重复)</p></li><li><p>定义增广路径的残存容量：路径上各边残存容量的最小值</p><blockquote><p>流量扩充的最大值为增广路径的残存容量</p></blockquote></li></ul></li></ul><h4 id="3-Ford-Fulkerson-算法"><a href="#3-Ford-Fulkerson-算法" class="headerlink" title="(3)$Ford-Fulkerson$算法"></a>(3)$Ford-Fulkerson$算法</h4><ul><li>算法思想<ul><li>对于所有边$e\in E$，初始化流量为$f(e)&#x3D;0$</li><li><strong>构造残存网络$G_f$，寻找$s$到$t$的增广路径$P$</strong></li><li>按路径$P$的<strong>残存容量</strong>增加路径流量</li><li>迭代寻找路径$P$直至无法增加路径流量</li></ul></li><li>伪代码如下</li><li>算法复杂度</li><li>正确性证明<ul><li>充分性：$f$是最大流$\Rightarrow$残存网络$G_f$中无增广路径</li><li>必要性：$f$是最大流$\Leftarrow$残存网络$G_f$中无增广路径</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 专业核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 专业课程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
