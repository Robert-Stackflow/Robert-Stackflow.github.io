<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>苍岚 | 苍岚</title><meta name="author" content="余湍"><meta name="copyright" content="余湍"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="author: hydingsy, Link-cute, Ir1d, greyqz, LuoshuiTianyi, Odeinjul, xyf007 前置知识：动态规划部分简介。 在具体讲何为「背包 dp」前，先来看如下的例题： ???+note “「USACO07 DEC」Charm Bracelet“    题意概要：有 $n$ 个物品和一个容量为 $W$ 的背包，每个物品有重量 $w_{i}"><meta property="og:type" content="article"><meta property="og:title" content="苍岚"><meta property="og:url" content="https://cloudchewie.com/2022/08/23/knapsack/index.html"><meta property="og:site_name" content="苍岚"><meta property="og:description" content="author: hydingsy, Link-cute, Ir1d, greyqz, LuoshuiTianyi, Odeinjul, xyf007 前置知识：动态规划部分简介。 在具体讲何为「背包 dp」前，先来看如下的例题： ???+note “「USACO07 DEC」Charm Bracelet“    题意概要：有 $n$ 个物品和一个容量为 $W$ 的背包，每个物品有重量 $w_{i}"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><meta property="article:published_time" content="2022-08-23T03:32:08.177Z"><meta property="article:modified_time" content="2022-04-30T07:32:28.286Z"><meta property="article:author" content="余湍"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://cloudchewie.com/2022/08/23/knapsack/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:{appId:"6IRW362MI1",apiKey:"a4043bbe3b536f100259866d9ff0ed57",indexName:"search_index_cloudchewie",hits:{per_page:6},languages:{input_placeholder:"搜索文章",hits_empty:"找不到您查询的内容：${query}",hits_stats:"找到 ${hits} 条结果，用时 ${time} 毫秒"}},localSearch:void 0,translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!0,post:!1},runtime:"",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:{copy_success:"复制成功",chs_to_cht:"你已切换为繁体中文",cht_to_chs:"你已切换为简体中文",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",comment_barrage_open:"打开评论弹幕",comment_barrage_close:"关闭评论弹幕",bgLight:"#49b1f5",bgDark:"#1f1f1f",position:"top-right"},source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!0,islazyload:!1,isAnchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"苍岚",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-04-30 15:32:28"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const a=864e5*o,c={value:t,expiry:(new Date).getTime()+a};localStorage.setItem(e,JSON.stringify(c))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise(((t,o)=>{const a=document.createElement("script");a.src=e,a.async=!0,a.onerror=o,a.onload=a.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)})),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme"),o=window.matchMedia("(prefers-color-scheme: dark)").matches,a=window.matchMedia("(prefers-color-scheme: light)").matches,c=window.matchMedia("(prefers-color-scheme: no-preference)").matches,n=!o&&!a&&!c;if(void 0===t){if(a)activateLightMode();else if(o)activateDarkMode();else if(c||n){const e=(new Date).getHours();e<=6||e>=18?activateDarkMode():activateLightMode()}window.matchMedia("(prefers-color-scheme: dark)").addListener((function(e){void 0===saveToLocal.get("theme")&&(e.matches?activateDarkMode():activateLightMode())}))}else"light"===t?activateLightMode():activateDarkMode();const i=saveToLocal.get("aside-status");void 0!==i&&("hide"===i?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/mystyle.css" media="defer" onload='this.media="all"'><style id="barragesColor"></style><link rel="stylesheet" href="/css/commentBarrage.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiper.min.css"><link rel="stylesheet" href="/css/swiperstyle.css"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="苍岚" type="application/atom+xml"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="img/loading.gif" data-original="/img/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/guestbook/"><i class="fa-fw fas fa-message"></i> <span>留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-circle-info"></i> <span>关于</span></a></div><div class="menus_item"><a class="site-page" href="javascript:rmf.switchDarkMode()"><i class="fa-fw fas fa-adjust"></i> <span>深色模式</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">苍岚</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/guestbook/"><i class="fa-fw fas fa-message"></i> <span>留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-circle-info"></i> <span>关于</span></a></div><div class="menus_item"><a class="site-page" href="javascript:rmf.switchDarkMode()"><i class="fa-fw fas fa-adjust"></i> <span>深色模式</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-23T03:32:08.177Z" title="发表于 2022-08-23 11:32:08">2022-08-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-30T07:32:28.286Z" title="更新于 2022-04-30 15:32:28">2022-04-30</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>18分钟</span></span><span class="post-meta-separator">|</span><span data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2022/08/23/knapsack/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div><article class="post-content" id="article-container"><p>author: hydingsy, Link-cute, Ir1d, greyqz, LuoshuiTianyi, Odeinjul, xyf007</p><p>前置知识：<a href="./index.md">动态规划部分简介</a>。</p><p>在具体讲何为「背包 dp」前，先来看如下的例题：</p><p>???+note “<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2871">「USACO07 DEC」Charm Bracelet</a>“<br>题意概要：有 $n$ 个物品和一个容量为 $W$ 的背包，每个物品有重量 $w_{i}$ 和价值 $v_{i}$ 两种属性，要求选若干物品放入背包使背包中物品的总价值最大且背包中物品的总重量不超过背包的容量。</p><p>在上述例题中，由于每个物体只有两种可能的状态（取与不取），对应二进制中的 $0$ 和 $1$，这类问题便被称为「0-1 背包问题」。</p><h2 id="0-1-背包"><a href="#0-1-背包" class="headerlink" title="0-1 背包"></a>0-1 背包</h2><p>例题中已知条件有第 $i$ 个物品的重量 $w_{i}$，价值 $v_{i}$，以及背包的总容量 $W$。</p><p>设 DP 状态 $f_{i,j}$ 为在只能放前 $i$ 个物品的情况下，容量为 $j$ 的背包所能达到的最大总价值。</p><p>考虑转移。假设当前已经处理好了前 $i-1$ 个物品的所有状态，那么对于第 $i$ 个物品，当其不放入背包时，背包的剩余容量不变，背包中物品的总价值也不变，故这种情况的最大价值为 $f_{i-1,j}$；当其放入背包时，背包的剩余容量会减小 $w_{i}$，背包中物品的总价值会增大 $v_{i}$，故这种情况的最大价值为 $f_{i-1,j-w_{i}}+v_{i}$。</p><p>由此可以得出状态转移方程：</p><p>$$<br>f_{i,j}&#x3D;\max(f_{i-1,j},f_{i-1,j-w_{i}}+v_{i})<br>$$</p><p>这里如果直接采用二维数组对状态进行记录，会出现 MLE。可以考虑改用滚动数组的形式来优化。</p><p>由于对 $f_i$ 有影响的只有 $f_{i-1}$，可以去掉第一维，直接用 $f_{i}$ 来表示处理到当前物品时背包容量为 $i$ 的最大价值，得出以下方程：</p><p>$$<br>f_j&#x3D;\max \left(f_j,f_{j-w_i}+v_i\right)<br>$$</p><p><strong>务必牢记并理解这个转移方程，因为大部分背包问题的转移方程都是在此基础上推导出来的。</strong></p><p>还有一点需要注意的是，很容易写出这样的错误核心代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt;= W - w[i]; l++)</span><br><span class="line">    f[l + w[i]] = <span class="built_in">max</span>(f[l] + v[i], f[l + w[i]]);</span><br><span class="line"><span class="comment">// 由 f[i][l + w[i]] = max(max(f[i - 1][l + w[i]],f[i - 1][l] + w[i]),f[i][l +</span></span><br><span class="line"><span class="comment">// w[i]]); 简化而来</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python Version</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    l = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> l &lt;= W - w[i]:</span><br><span class="line">        f[l + w[i]] = <span class="built_in">max</span>(f[l] + v[i], f[l + w[i]])</span><br><span class="line">        l += <span class="number">1</span></span><br><span class="line"><span class="comment"># 由 f[i][l + w[i]] = max(max(f[i - 1][l + w[i]],f[i - 1][l] + w[i]),f[i][l +</span></span><br><span class="line"><span class="comment"># w[i]]) 简化而来</span></span><br></pre></td></tr></table></figure><p>这段代码哪里错了呢？枚举顺序错了。</p><p>仔细观察代码可以发现：对于当前处理的物品 $i$ 和当前状态 $f_{i,j}$，在 $j\geqslant w_{i}$ 时，$f_{i,j}$ 是会被 $f_{i,j-w_{i}}$ 所影响的。这就相当于物品 $i$ 可以多次被放入背包，与题意不符。（事实上，这正是完全背包问题的解法）</p><p>为了避免这种情况发生，我们可以改变枚举的顺序，从 $W$ 枚举到 $w_{i}$，这样就不会出现上述的错误，因为 $f_{i,j}$ 总是在 $f_{i,j-w_{i}}$ 前被更新。</p><p>因此实际核心代码为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> l = W; l &gt;= w[i]; l--) f[l] = <span class="built_in">max</span>(f[l], f[l - w[i]] + v[i]);</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python Version</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    l = W</span><br><span class="line">    <span class="keyword">while</span> l &gt;= w[i]:</span><br><span class="line">        f[l] = <span class="built_in">max</span>(f[l], f[l - w[i]] + v[i])</span><br><span class="line">        l -= <span class="number">1</span></span><br></pre></td></tr></table></figure><p>??? 例题代码<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">-8</span>&lt;-- <span class="string">&quot;docs/dp/code/knapsack/knapsack_1.cpp&quot;</span></span><br></pre></td></tr></table></figure><p></p><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p>完全背包模型与 0-1 背包类似，与 0-1 背包的区别仅在于一个物品可以选取无限次，而非仅能选取一次。</p><p>我们可以借鉴 0-1 背包的思路，进行状态定义：设 $f_{i,j}$ 为只能选前 $i$ 个物品时，容量为 $j$ 的背包可以达到的最大价值。</p><p>需要注意的是，虽然定义与 0-1 背包类似，但是其状态转移方程与 0-1 背包并不相同。</p><p>可以考虑一个朴素的做法：对于第 $i$ 件物品，枚举其选了多少个来转移。这样做的时间复杂度是 $O(n^3)$ 的。</p><p>状态转移方程如下：</p><p>$$<br>f_{i,j}&#x3D;\max_{k&#x3D;0}^{+\infty}(f_{i-1,j-k\times w_i}+v_i\times k)<br>$$</p><p>考虑做一个简单的优化。可以发现，对于 $f_{i,j}$，只要通过 $f_{i,j-w_i}$ 转移就可以了。因此状态转移方程为：</p><p>$$<br>f_{i,j}&#x3D;\max(f_{i-1,j},f_{i,j-w_i}+v_i)<br>$$</p><p>理由是当我们这样转移时，$f_{i,j-w_i}$ 已经由 $f_{i,j-2\times w_i}$ 更新过，那么 $f_{i,j-w_i}$ 就是充分考虑了第 $i$ 件物品所选次数后得到的最优结果。换言之，我们通过局部最优子结构的性质重复使用了之前的枚举过程，优化了枚举的复杂度。</p><p>与 0-1 背包相同，我们可以将第一维去掉来优化空间复杂度。如果理解了 0-1 背包的优化方式，就不难明白压缩后的循环是正向的（也就是上文中提到的错误优化）。</p><p>??? note “<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1616">「Luogu P1616」疯狂的采药</a>“<br>题意概要：有 $n$ 种物品和一个容量为 $W$ 的背包，每种物品有重量 $w_{i}$ 和价值 $v_{i}$ 两种属性，要求选若干个物品放入背包使背包中物品的总价值最大且背包中物品的总重量不超过背包的容量。</p><p>??? 例题代码<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">-8</span>&lt;-- <span class="string">&quot;docs/dp/code/knapsack/knapsack_2.cpp&quot;</span></span><br></pre></td></tr></table></figure><p></p><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p>多重背包也是 0-1 背包的一个变式。与 0-1 背包的区别在于每种物品有 $k_i$ 个，而非一个。</p><p>一个很朴素的想法就是：把「每种物品选 $k_i$ 次」等价转换为「有 $k_i$ 个相同的物品，每个物品选一次」。这样就转换成了一个 0-1 背包模型，套用上文所述的方法就可已解决。状态转移方程如下：</p><p>$$<br>f_{i,j}&#x3D;\max_{k&#x3D;0}^{k_i}(f_{i-1,j-k\times w_i}+v_i\times k)<br>$$</p><p>时间复杂度 $O(W\sum_{i&#x3D;1}^nk_i)$。</p><h3 id="二进制分组优化"><a href="#二进制分组优化" class="headerlink" title="二进制分组优化"></a>二进制分组优化</h3><p>考虑优化。我们仍考虑把多重背包转化成 0-1 背包模型来求解。</p><p>显然，复杂度中的 $O(nW)$ 部分无法再优化了，我们只能从 $O(\sum k_i)$ 处入手。为了表述方便，我们用 $A_{i,j}$ 代表第 $i$ 种物品拆分出的第 $j$ 个物品。</p><p>在朴素的做法中，$\forall j\le k_i$，$A_{i,j}$ 均表示相同物品。那么我们效率低的原因主要在于我们进行了大量重复性的工作。举例来说，我们考虑了「同时选 $A_{i,1},A_{i,2}$」与「同时选 $A_{i,2},A_{i,3}$」这两个完全等效的情况。这样的重复性工作我们进行了许多次。那么优化拆分方式就成为了解决问题的突破口。</p><p>我们可以通过「二进制分组」的方式使拆分方式更加优美。</p><p>具体地说就是令 $A_{i,j}\left(j\in\left[0,\lfloor \log_2(k_i+1)\rfloor-1\right]\right)$ 分别表示由 $2^{j}$ 个单个物品「捆绑」而成的大物品。特殊地，若 $k_i+1$ 不是 $2$ 的整数次幂，则需要在最后添加一个由 $k_i-2^{\lfloor \log_2(k_i+1)\rfloor-1}$ 个单个物品「捆绑」而成的大物品用于补足。</p><p>举几个例子：</p><ul><li>$6&#x3D;1+2+3$</li><li>$8&#x3D;1+2+4+1$</li><li>$18&#x3D;1+2+4+8+3$</li><li>$31&#x3D;1+2+4+8+16$</li></ul><p>显然，通过上述拆分方式，可以表示任意 $\le k_i$ 个物品的等效选择方式。将每种物品按照上述方式拆分后，使用 0-1 背包的方法解决即可。</p><p>时间复杂度 $O(W\sum_{i&#x3D;1}^n\log_2k_i)$</p><p>??? 二进制分组代码<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line">index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">  <span class="type">int</span> c = <span class="number">1</span>, p, h, k;</span><br><span class="line">  cin &gt;&gt; p &gt;&gt; h &gt;&gt; k;</span><br><span class="line">  <span class="keyword">while</span> (k - c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    k -= c;</span><br><span class="line">    list[++index].w = c * p;</span><br><span class="line">    list[index].v = c * h;</span><br><span class="line">    c *= <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  list[++index].w = p * k;</span><br><span class="line">  list[index].v = h * k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python Version</span></span><br><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">    c = <span class="number">1</span></span><br><span class="line">    p, h, k = <span class="built_in">map</span>(<span class="keyword">lambda</span> x:<span class="built_in">int</span>(x), <span class="built_in">input</span>().split())</span><br><span class="line">    <span class="keyword">while</span> k - c &gt; <span class="number">0</span>:</span><br><span class="line">        k -= c</span><br><span class="line">        <span class="built_in">list</span>[index].w = c * p</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">        <span class="built_in">list</span>[index].v = c * h</span><br><span class="line">        c *= <span class="number">2</span></span><br><span class="line">    <span class="built_in">list</span>[index].w = p * k</span><br><span class="line">    index += <span class="number">1</span></span><br><span class="line">    <span class="built_in">list</span>[index].v = h * k</span><br></pre></td></tr></table></figure></code></pre><h3 id="单调队列优化"><a href="#单调队列优化" class="headerlink" title="单调队列优化"></a>单调队列优化</h3><p>见 <a href="./opt/monotonous-queue-stack.md">单调队列&#x2F;单调栈优化</a>。</p><p>习题：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1776">「Luogu P1776」宝物筛选_NOI 导刊 2010 提高（02）</a></p><h2 id="混合背包"><a href="#混合背包" class="headerlink" title="混合背包"></a>混合背包</h2><p>混合背包就是将前面三种的背包问题混合起来，有的只能取一次，有的能取无限次，有的只能取 $k$ 次。</p><p>这种题目看起来很吓人，可是只要领悟了前面几种背包的中心思想，并将其合并在一起就可以了。下面给出伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (循环物品种类) &#123;</span><br><span class="line">  if (是 0 - 1 背包)</span><br><span class="line">    套用 0 - 1 背包代码;</span><br><span class="line">  else if (是完全背包)</span><br><span class="line">    套用完全背包代码;</span><br><span class="line">  else if (是多重背包)</span><br><span class="line">    套用多重背包代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>??? note “<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1833">「Luogu P1833」樱花</a>“<br>题意概要：有 $n$ 种樱花树和长度为 $T$ 的时间，有的樱花树只能看一遍，有的樱花树最多看 $A_{i}$ 遍，有的樱花树可以看无数遍。每棵樱花树都有一个美学值 $C_{i}$，求在 $T$ 的时间内看哪些樱花树能使美学值最高。</p><h2 id="二维费用背包"><a href="#二维费用背包" class="headerlink" title="二维费用背包"></a>二维费用背包</h2><p>???+note “<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1855">「Luogu P1855」榨取 kkksc03</a>“<br>有 $n$ 个任务需要完成，完成第 $i$ 个任务需要花费 $t_i$ 分钟，产生 $c_i$ 元的开支。</p><pre><code>现在有 $T$ 分钟时间，$W$ 元钱来处理这些任务，求最多能完成多少任务。
</code></pre><p>这道题是很明显的 0-1 背包问题，可是不同的是选一个物品会消耗两种价值（经费、时间），只需在状态中增加一维存放第二种价值即可。</p><p>这时候就要注意，再开一维存放物品编号就不合适了，因为容易 MLE。</p><p>例题核心代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = m; i &gt;= mi; i--)    <span class="comment">// 对经费进行一层枚举</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = t; j &gt;= ti; j--)  <span class="comment">// 对时间进行一层枚举</span></span><br><span class="line">      dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - mi][j - ti] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python Version</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    i = m</span><br><span class="line">    <span class="keyword">while</span> i &gt;= mi: <span class="comment"># 对经费进行一层枚举</span></span><br><span class="line">        j = t</span><br><span class="line">        <span class="keyword">while</span> j &gt;= ti: <span class="comment"># 对时间进行一层枚举</span></span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - mi][j - ti] + <span class="number">1</span>)</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        i -= <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h2><p>???+note “<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1757">「Luogu P1757」通天之分组背包</a>“<br>有 $n$ 件物品和一个大小为 $m$ 的背包，第 $i$ 个物品的价值为 $w_i$，体积为 $v_i$。同时，每个物品属于一个组，同组内最多只能选择一个物品。求背包能装载物品的最大总价值。</p><p>这种题怎么想呢？其实是从「在所有物品中选择一件」变成了「从当前组中选择一件」，于是就对每一组进行一次 0-1 背包就可以了。</p><p>再说一说如何进行存储。我们可以将 $t_{k,i}$ 表示第 $k$ 组的第 $i$ 件物品的编号是多少，再用 $\mathit{cnt}_k$ 表示第 $k$ 组物品有多少个。</p><p>例题核心代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= ts; k++)          <span class="comment">// 循环每一组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = m; i &gt;= <span class="number">0</span>; i--)         <span class="comment">// 循环背包容量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt[k]; j++)  <span class="comment">// 循环该组的每一个物品</span></span><br><span class="line">      <span class="keyword">if</span> (i &gt;= w[t[k][j]])</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i],</span><br><span class="line">                    dp[i - w[t[k][j]]] + c[t[k][j]]);  <span class="comment">// 像0-1背包一样状态转移</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python Version</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, ts + <span class="number">1</span>): <span class="comment"># 循环每一组</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m, -<span class="number">1</span>, -<span class="number">1</span>): <span class="comment"># 循环背包容量</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, cnt[k] + <span class="number">1</span>): <span class="comment"># 循环该组的每一个物品</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= w[t[k][j]]:</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], \</span><br><span class="line">                    dp[i - w[t[k][j]]] + c[t[k][j]]) <span class="comment"># 像0-1背包一样状态转移</span></span><br></pre></td></tr></table></figure><p>这里要注意：<strong>一定不能搞错循环顺序</strong>，这样才能保证正确性。</p><h2 id="有依赖的背包"><a href="#有依赖的背包" class="headerlink" title="有依赖的背包"></a>有依赖的背包</h2><p>???+note “<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1064">「Luogu P1064」金明的预算方案</a>“<br>金明有 $n$ 元钱，想要买 $m$ 个物品，第 $i$ 件物品的价格为 $v_i$，重要度为 $p_i$。有些物品是从属于某个主件物品的附件，要买这个物品，必须购买它的主件。</p><pre><code>目标是让所有购买的物品的 $v_i \times p_i$ 之和最大。
</code></pre><p>考虑分类讨论。对于一个主件和它的若干附件，有以下几种可能：只买主件，买主件 + 某些附件。因为这几种可能性只能选一种，所以可以将这看成分组背包。</p><p>如果是多叉树的集合，则要先算子节点的集合，最后算父节点的集合。</p><h2 id="泛化物品的背包"><a href="#泛化物品的背包" class="headerlink" title="泛化物品的背包"></a>泛化物品的背包</h2><p>这种背包，没有固定的费用和价值，它的价值是随着分配给它的费用而定。在背包容量为 $V$ 的背包问题中，当分配给它的费用为 $v_i$ 时，能得到的价值就是 $h\left(v_i\right)$。这时，将固定的价值换成函数的引用即可。</p><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="小优化"><a href="#小优化" class="headerlink" title="小优化"></a>小优化</h3><p>根据贪心原理，当费用相同时，只需保留价值最高的；当价值一定时，只需保留费用最低的；当有两件物品 $i,j$ 且 $i$ 的价值大于 $j$ 的价值并且 $i$ 的费用小于 $j$ 的费用是，只需保留 $j$。</p><h3 id="背包问题变种"><a href="#背包问题变种" class="headerlink" title="背包问题变种"></a>背包问题变种</h3><h4 id="输出方案"><a href="#输出方案" class="headerlink" title="输出方案"></a>输出方案</h4><p>输出方案其实就是记录下来背包中的某一个状态是怎么推出来的。我们可以用 $g_{i,v}$ 表示第 $i$ 件物品占用空间为 $v$ 的时候是否选择了此物品。然后在转移时记录是选用了哪一种策略（选或不选）。输出时的伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> v = V;  <span class="comment">// 记录当前的存储空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为最后一件物品存储的是最终状态，所以从最后一件物品进行循环</span></span><br><span class="line"><span class="keyword">for</span> (从最后一件循环至第一件) &#123;</span><br><span class="line">  <span class="keyword">if</span> (g[i][v]) &#123;</span><br><span class="line">    选了第 i 项物品;</span><br><span class="line">    v -= 第 i 项物品的重量;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    未选第 i 项物品;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="求方案数"><a href="#求方案数" class="headerlink" title="求方案数"></a>求方案数</h4><p>对于给定的一个背包容量、物品费用、其他关系等的问题，求装到一定容量的方案总数。</p><p>这种问题就是把求最大值换成求和即可。</p><p>例如 0-1 背包问题的转移方程就变成了：</p><p>$$<br>\mathit{dp}_i&#x3D;\sum(\mathit{dp}<em>i,\mathit{dp}</em>{i-c_i})<br>$$</p><p>初始条件：$\mathit{dp}_0&#x3D;1$</p><p>因为当容量为 $0$ 时也有一个方案，即什么都不装。</p><h4 id="求最优方案总数"><a href="#求最优方案总数" class="headerlink" title="求最优方案总数"></a>求最优方案总数</h4><p>要求最优方案总数，我们要对 0-1 背包里的 $\mathit{dp}$ 数组的定义稍作修改，DP 状态 $f_{i,j}$ 为在只能放前 $i$ 个物品的情况下，容量为 $j$ 的背包“正好装满”所能达到的最大总价值。</p><p>这样修改之后，每一种 DP 状态都可以用一个 $g_{i,j}$ 来表示方案数。</p><p>$f_{i,j}$ 表示只考虑前 $i$ 个物品时背包体积“正好”是 $j$ 时的最大价值。</p><p>$g_{i,j}$ 表示只考虑前 $i$ 个物品时背包体积“正好”是 $j$ 时的方案数。</p><p>转移方程：</p><p>如果 $f_{i,j} &#x3D; f_{i-1,j}$ 且 $f_{i,j} \neq f_{i-1,j-v}+w$ 说明我们此时不选择把物品放入背包更优，方案数由 $g_{i-1,j}$ 转移过来，</p><p>如果 $f_{i,j} \neq f_{i-1,j}$ 且 $f_{i,j} &#x3D; f_{i-1,j-v}+w$ 说明我们此时选择把物品放入背包更优，方案数由 $g_{i-1,j-v}$ 转移过来，</p><p>如果 $f_{i,j} &#x3D; f_{i-1,j}$ 且 $f_{i,j} &#x3D; f_{i-1,j-v}+w$ 说明放入或不放入都能取得最优解，方案数由 $g_{i-1,j}$ 和 $g_{i-1,j-v}$ 转移过来。</p><p>初始条件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(f, <span class="number">0x3f3f</span>, <span class="built_in">sizeof</span>(f));  <span class="comment">// 避免没有装满而进行了转移</span></span><br><span class="line">f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">g[<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">// 什么都不装是一种方案</span></span><br></pre></td></tr></table></figure><p>因为背包体积最大值有可能装不满，所以最优解不一定是 $f_{m}$。</p><p>最后我们通过找到最优解的价值，把 $g_{j}$ 数组里取到最优解的所有方案数相加即可。</p><p>核心代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = V; j &gt;= v[i]; j--) &#123;</span><br><span class="line">    <span class="type">int</span> tmp = std::<span class="built_in">max</span>(dp[j], dp[j - v[i]] + w[i]);</span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (tmp == dp[j]) c += cnt[j];                       <span class="comment">// 如果从dp[j]转移</span></span><br><span class="line">    <span class="keyword">if</span> (tmp == dp[j - v[i]] + w[i]) c += cnt[j - v[i]];  <span class="comment">// 如果从dp[j-v[i]]转移</span></span><br><span class="line">    dp[j] = tmp;</span><br><span class="line">    cnt[j] = c;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> max = <span class="number">0</span>;  <span class="comment">// 寻找最优解</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= V; i++) &#123;</span><br><span class="line">  max = std::<span class="built_in">max</span>(max, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= V; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (dp[i] == max) &#123;</span><br><span class="line">    res += cnt[i];  <span class="comment">// 求和最优解方案数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="背包的第-k-优解"><a href="#背包的第-k-优解" class="headerlink" title="背包的第 k 优解"></a>背包的第 k 优解</h4><p>普通的 0-1 背包是要求最优解，在普通的背包 DP 方法上稍作改动，增加一维用于记录当前状态下的前 k 优解，即可得到求 0-1 背包第 $k$ 优解的算法。<br>具体来讲：$\mathit{dp_{i,j,k}}$ 记录了前 $i$ 个物品中，选择的物品总体积为 $j$ 时，能够得到的第 $k$ 大的价值和。这个状态可以理解为将普通 0-1 背包只用记录一个数据的 $\mathit{dp_{i,j}}$ 扩展为记录一个有序的优解序列。转移时，普通背包最优解的求法是 $\mathit{dp_{i,j}}&#x3D;\max(\mathit{dp_{i-1,j}},\mathit{dp_{i-1,j-v_{i}}}+w_{i})$，现在我们则是要合并 $\mathit{dp_{i-1,j}}$，$\mathit{dp_{i-1,j-v_{i}}}+w_{i}$ 这两个大小为 $k$ 的递减序列，并保留合并后前 $k$ 大的价值记在 $\mathit{dp_{i,j}}$ 里，这一步利用双指针法，复杂度是 $O(k)$ 的，整体时间复杂度为 $O(nmk)$。空间上，此方法与普通背包一样可以压缩掉第一维，复杂度是 $O(mk)$ 的。</p><p>??? note “<a target="_blank" rel="noopener" href="https://vjudge.net/problem/HDU-2639">例题 hdu 2639 Bone Collector II</a>“<br>求 0-1 背包的严格第 $k$ 优解。$n \leq 100,v \leq 1000,k \leq 30$</p><p>??? note “核心代码”<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line"><span class="type">int</span> i, j, p, x, y, z;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;K);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[i]);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (j = m; j &gt;= c[i]; j--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (p = <span class="number">1</span>; p &lt;= K; p++) &#123;</span><br><span class="line">      a[p] = dp[j - c[i]][p] + w[i];</span><br><span class="line">      b[p] = dp[j][p];</span><br><span class="line">    &#125;</span><br><span class="line">    a[p] = b[p] = <span class="number">-1</span>;</span><br><span class="line">    x = y = z = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (z &lt;= K &amp;&amp; (a[x] != <span class="number">-1</span> || b[y] != <span class="number">-1</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[x] &gt; b[y])</span><br><span class="line">        dp[j][z] = a[x++];</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        dp[j][z] = b[y++];</span><br><span class="line">      <span class="keyword">if</span> (dp[j][z] != dp[j][z - <span class="number">1</span>]) z++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[m][K]);</span><br></pre></td></tr></table></figure><p></p><h3 id="参考资料与注释"><a href="#参考资料与注释" class="headerlink" title="参考资料与注释"></a>参考资料与注释</h3><ul><li><a target="_blank" rel="noopener" href="https://github.com/tianyicui/pack">背包问题九讲 - 崔添翼</a>。</li></ul></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="https://cloudchewie.com">余湍</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://cloudchewie.com/2022/08/23/knapsack/">https://cloudchewie.com/2022/08/23/knapsack/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://cloudchewie.com" target="_blank">苍岚</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/08/23/memo/"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info"></div></div></a></div><div class="next-post pull-right"><a href="/2022/08/23/interval/"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="comment-barrage"></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="img/loading.gif" data-original="/img/avatar.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">余湍</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Robert-stackflow"><i class="fab fa-github"></i><span>Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:2014027378@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-square-rss"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-1-%E8%83%8C%E5%8C%85"><span class="toc-text">0-1 背包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85"><span class="toc-text">完全背包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85"><span class="toc-text">多重背包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E7%BB%84%E4%BC%98%E5%8C%96"><span class="toc-text">二进制分组优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96"><span class="toc-text">单调队列优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E8%83%8C%E5%8C%85"><span class="toc-text">混合背包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E8%B4%B9%E7%94%A8%E8%83%8C%E5%8C%85"><span class="toc-text">二维费用背包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85"><span class="toc-text">分组背包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E4%BE%9D%E8%B5%96%E7%9A%84%E8%83%8C%E5%8C%85"><span class="toc-text">有依赖的背包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%8C%96%E7%89%A9%E5%93%81%E7%9A%84%E8%83%8C%E5%8C%85"><span class="toc-text">泛化物品的背包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%82%E9%A1%B9"><span class="toc-text">杂项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E4%BC%98%E5%8C%96"><span class="toc-text">小优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%8F%98%E7%A7%8D"><span class="toc-text">背包问题变种</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%96%B9%E6%A1%88"><span class="toc-text">输出方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82%E6%96%B9%E6%A1%88%E6%95%B0"><span class="toc-text">求方案数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82%E6%9C%80%E4%BC%98%E6%96%B9%E6%A1%88%E6%80%BB%E6%95%B0"><span class="toc-text">求最优方案总数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%8C%E5%8C%85%E7%9A%84%E7%AC%AC-k-%E4%BC%98%E8%A7%A3"><span class="toc-text">背包的第 k 优解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%E4%B8%8E%E6%B3%A8%E9%87%8A"><span class="toc-text">参考资料与注释</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By 余湍</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-button-list"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏/双栏模式"><i class="fas fa-arrows-alt-h"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><a id="switch_commentBarrage" href="javascript:switchCommentBarrage();" title="开关弹幕"><i class="fas fa-list"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.location.href=&quot;/&quot;;"><i class="fas fa-home"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.switchDarkMode();"><i class="fas fa-adjust"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-general"><a class="rightMenu-item" href="javascript:window.location.href=&quot;/archives/&quot;;"><i class="fas fa-archive"></i><span>归档</span></a><a class="rightMenu-item" href="javascript:window.location.href=&quot;/tags/&quot;;"><i class="fas fa-tags"></i><span>标签</span></a><a class="rightMenu-item" href="javascript:window.location.href=&quot;/categories/&quot;;"><i class="fas fa-folder-open"></i><span>分类</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://cn.bing.com/search?q=&quot;+window.getSelection().toString());window.location.reload();"><i class="fas fa-magnifying-glass"></i><span>必应搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="./#post-comment"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.click()"><i class="fa fa-arrows-alt"></i><span>全屏显示</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line" id="menu-other"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js").then((()=>{pangu.autoSpacingPage()}))}function panguInit(){GLOBAL_CONFIG_SITE.isPost&&panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><script>(()=>{const t=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://cloudchewie-comments.vercel.app/",region:"ap-shanghai",onCommentLoaded:function(){btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null)),GLOBAL_CONFIG_SITE.isPost&&(()=>{const t=document.getElementById("twikoo-count");t&&twikoo.getCommentsCount({envId:"https://cloudchewie-comments.vercel.app/",region:"ap-shanghai",urls:[window.location.pathname],includeReply:!1}).then((function(o){t.innerText=o[0].count})).catch((function(t){console.error(t)}))})()},o=()=>{"object"!=typeof twikoo?getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(t):setTimeout(t,0)};o()})()</script></div><script src="https://cdn1.tianli0.top/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/rightmenu.js"></script><script src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script src="/js/lunar.js"></script><script src="/js/day.js"></script><script src="/js/calendar.js"></script><script src="/js/commentBarrage.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script data-pjax>if(document.getElementById("recent-posts")&&"/"==location.pathname){var parent=document.getElementById("recent-posts"),child='<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="img/loading.gif" data-original="/img/sticky.webp" alt="/img/sticky.webp"/></div><div class="blog-slider__content"><span class="blog-slider__code">2022-08-19</span><a class="blog-slider__title" href="2022/08/19/【教程】Windows下安装WSL 2/">【教程】Windows下安装WSL 2</a><div class="blog-slider__text">Windows下安装Linux子系统教程</div><a class="blog-slider__button" href="2022/08/19/【教程】Windows下安装WSL 2/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="img/loading.gif" data-original="/img/sticky.webp" alt="/img/sticky.webp"/></div><div class="blog-slider__content"><span class="blog-slider__code">2022-08-19</span><a class="blog-slider__title" href="2022/08/19/【笔记】算法设计与分析笔记/">【笔记】算法设计与分析笔记</a><div class="blog-slider__text">华中科技大学计算机科学与技术学院算法设计与分析课程笔记</div><a class="blog-slider__button" href="2022/08/19/【笔记】算法设计与分析笔记/">详情</a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';parent.insertAdjacentHTML("afterbegin",child)}</script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiper.min.js"></script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper@0.18/swiper/swiperindex.js"></script><style></style><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:1,processImages:null}</script><script>window.addEventListener("load",(function(){var a=/\.(gif|jpg|jpeg|tiff|png)$/i,e=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach((function(t){var r=t.parentNode;"A"===r.tagName&&(r.href.match(a)||r.href.match(e))&&(r.href=t.dataset.original)}))}))</script><script>!function(t){t.imageLazyLoadSetting.processImages=o;var e=t.imageLazyLoadSetting.isSPA,n=t.imageLazyLoadSetting.preloadRatio||1,i=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(i=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var o,a=0;a<i.length;a++)0<=(o=(o=i[a]).getBoundingClientRect()).bottom&&0<=o.left&&o.top<=(t.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,o,r=i[a];t=r,e=function(){i=i.filter((function(t){return r!==t}))},n=new Image,o=t.getAttribute("data-original"),n.onload=function(){t.src=o,e&&e()},t.src!==o&&(n.src=o)}()}o(),t.addEventListener("scroll",(function(){var e,n;e=o,n=t,clearTimeout(e.tId),e.tId=setTimeout((function(){e.call(n)}),500)}))}(this)</script></body></html>